{
  "json": [
    {
      "id": "galxegravity-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": "Ethereum (blobs)",
      "hasChallengeMechanism": null,
      "display": {
        "name": "Gravity DAC",
        "slug": "galxegravity",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://gravity.xyz"],
          "apps": ["https://bridge.gravity.xyz/"],
          "documentation": ["https://docs.gravity.xyz/"],
          "explorers": ["https://gscan.xyz/", "https://explorer.gravity.xyz/"],
          "repositories": ["https://github.com/Galxe"],
          "socialMedia": [
            "https://x.com/GravityChain",
            "https://discord.com/invite/GravityChain",
            "https://t.me/GravityChain"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![Anytrust architecture](/images/da-layer-technology/anytrust/architecture1.png#center)\n\n    The DAC uses a data availability solution built on the AnyTrust protocol. It is composed of the following components:\n    - **Sequencer Inbox**: Main entry point for the Sequencer submitting transaction batches.\n    - **Data Availability Committee (DAC)**: A group of members responsible for storing and providing data on demand.\n    - **Data Availability Certificate (DACert)**: A commitment ensuring that data blobs are available without needing full data posting on the L1 chain. \n\n    \n    Committee members run servers that support APIs for storing and retrieving data blobs. \n    The Sequencer API allows the rollup Sequencer to submit data blobs for storage, while the REST API enables anyone to fetch data by hash. \n    When the Sequencer produces a data batch, it sends the batch along with an expiration time to Committee members, who store it and sign it. \n    Once enough signatures are collected, the Sequencer aggregates them into a valid DACert and posts it to the L1 chain inbox. \n    If the Sequencer fails to collect enough signatures, it falls back to posting the full data to the L1 chain. \n\n\n    A DACert includes a hash of the data block, an expiration time, and proof that the required threshold of Committee members have signed off on the data. \n    The proof consists of a hash of the Keyset used in signing, a bitmap indicating which members signed, and a BLS aggregated signature. \n    L2 nodes reading from the sequencer inbox verify the certificate’s validity by checking the number of signers, the aggregated signature, and that the expiration time is at least two weeks ahead of the L2 timestamp. \n    If the DACert is valid, it provides a proof that the corresponding data is available from honest committee members.\n\n    ",
        "risks": null
      },
      "usedIn": [
        { "id": "galxegravity", "name": "Gravity", "slug": "galxegravity" }
      ],
      "bridges": [
        {
          "id": "galxegravity-dac-bridge",
          "type": "DAC",
          "usedIn": [
            { "id": "galxegravity", "name": "Gravity", "slug": "galxegravity" }
          ],
          "createdAt": "1723211933",
          "contracts": {
            "addresses": [
              {
                "name": "SequencerInbox",
                "address": "0x8D99372612e8cFE7163B1a453831Bc40eAeb3cF3",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0xBbc3872E30C91ef69336937838c2a283F79f7E68"],
                  "implementations": [
                    "0x383f16fB2809a56fC639c1eE2c93Ad2aa7Ee130A"
                  ]
                },
                "chain": "ethereum",
                "description": "Main entry point for the Sequencer submitting transaction batches."
              }
            ],
            "risks": []
          },
          "permissions": [
            {
              "name": "Sequencers",
              "accounts": [
                {
                  "address": "0xBa369bd77a346babCd282cB1a015194E8ec54542",
                  "type": "EOA"
                }
              ],
              "description": "Central actors allowed to submit transaction batches to the Sequencer Inbox.",
              "chain": "ethereum"
            },
            {
              "name": "RollupOwner",
              "accounts": [
                {
                  "address": "0x4a4962275DF8C60a80d3a25faEc5AA7De116A746",
                  "type": "MultiSig"
                }
              ],
              "description": "Multisig that can upgrade authorized batch posters via the UpgradeExecutor contract."
            }
          ],
          "chain": 1,
          "requiredMembers": 1,
          "membersCount": 1,
          "transactionDataType": {
            "type": "TransactionDataCompressed",
            "value": "Transaction data (compressed)",
            "description": "TODO"
          },
          "display": {
            "name": "Gravity DAC",
            "slug": "dac",
            "description": "Gravity DAC on Ethereum.",
            "warning": null,
            "redWarning": "Only one signer is required to attest to the availability of the data.",
            "links": {
              "websites": ["https://gravity.xyz"],
              "apps": ["https://bridge.gravity.xyz/"],
              "documentation": ["https://docs.gravity.xyz/"],
              "explorers": [
                "https://gscan.xyz/",
                "https://explorer.gravity.xyz/"
              ],
              "repositories": ["https://github.com/Galxe"],
              "socialMedia": [
                "https://x.com/GravityChain",
                "https://discord.com/invite/GravityChain",
                "https://t.me/GravityChain"
              ]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![Anytrust bridge architecture](/images/da-bridge-technology/anytrust/architectureL2.png#center)\n\n\n    The DA commitments are posted to the L1 through the sequencer inbox, using the inbox as a DA bridge.\n    The DA commitment consists of Data Availability Certificate (DACert), including a hash of the data block, an expiration time, and a proof that the required threshold of Committee members have signed off on the data.\n    The sequencer distributes the data and collects signatures from Committee members offchain. Only the DACert is posted by the sequencer to the L1 chain inbox (the DA bridge), achieving L2 transaction ordering finality in a single onchain transaction.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "1/1",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "immutablex-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": null,
      "hasChallengeMechanism": null,
      "display": {
        "name": "Immutable X DAC",
        "slug": "immutablex",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://immutablex.xyz/"],
          "apps": ["https://app.immutable.com/"],
          "documentation": ["https://docs.immutablex.xyz/"],
          "explorers": ["https://explorer.immutable.com/"],
          "repositories": ["https://github.com/Immutable"],
          "socialMedia": [
            "https://medium.com/@immutablex",
            "https://twitter.com/Immutable"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![starkex architecture](/images/da-layer-technology/starkex/architecture7.png#center)\n\n    The Starkware application utilizes a data availability solution that relies on a Committee Service to ensure data persistence. This architecture comprises the following components:\n\n    - **Availability Gateway**: The primary interface provided by the operator for committee members to access new batch information and submit signed availability claims.\n    - **Data Availability Committee (DAC)**: A group of nodes responsible for storing state data associated with each Merkle root and attesting to data availability by signing claims.\n    - **Data Batches**: Collections of transactions processed in batches that update the state of accounts, resulting in a new Merkle root representing the updated state.\n    \n    Committee members run services that interact with the Availability Gateway to obtain information about new batches and submit their signed availability claims. Each batch includes a unique batch_id, a reference to a previous batch, and a list of account updates. \n    Committee members combine this information with data from the reference batch to compute the new state and verify the Merkle root.\n    \n    When the operator produces a new batch, it must be signed by a minimum number of committee members—as defined by the application's configuration—for it to be accepted onchain. \n    This includes all members designated as mandatory signers. If the operator attempts to submit a batch without the required signatures, it will be rejected, thereby ensuring that data remains available and consistent.\n    \n    Committee members are expected to maintain a database that stores the data associated with each batch, making use of storage solutions with a replication factor of at least 2.\n  \n    ",
        "risks": null
      },
      "usedIn": [
        { "id": "immutablex", "name": "Immutable X", "slug": "immutablex" }
      ],
      "bridges": [
        {
          "id": "immutablex-dac-bridge",
          "type": "DAC",
          "usedIn": [
            { "id": "immutablex", "name": "Immutable X", "slug": "immutablex" }
          ],
          "createdAt": "1723211933",
          "contracts": {
            "addresses": [
              {
                "name": "Committee",
                "address": "0x16BA0f221664A5189cf2C1a7AF0d3AbFc70aA295",
                "upgradeability": null,
                "chain": "ethereum",
                "description": "Data Availability Committee (DAC) contract verifying data availability claim from DAC Members (via multisig check)."
              }
            ],
            "risks": []
          },
          "permissions": [
            {
              "name": "Committee Members",
              "description": "List of addresses authorized to sign data commitments for the DA bridge.",
              "accounts": [
                {
                  "address": "0x1FfBDb8061B586A6D29fb608d025e5D8744f58d1",
                  "type": "EOA"
                },
                {
                  "address": "0x24EeFFC269bB8E540F5B2C8f45750489abf8D54b",
                  "type": "EOA"
                },
                {
                  "address": "0x48AF849535DDFa560A0EB0FbDEf436688169B949",
                  "type": "EOA"
                },
                {
                  "address": "0x51AbdE72a4542500a7b1Cb32B18b13fbe1F9ff2E",
                  "type": "EOA"
                },
                {
                  "address": "0xAfC4589aF46C72CBF550F2eEAE38c97AeDE15d17",
                  "type": "EOA"
                },
                {
                  "address": "0xB71FC111D7BA82D5955BaDdD7717f3467184FF61",
                  "type": "EOA"
                },
                {
                  "address": "0xfF506616E8C53EE5e513b906AC00B5D76664C537",
                  "type": "EOA"
                }
              ]
            }
          ],
          "chain": 1,
          "requiredMembers": 5,
          "membersCount": 7,
          "transactionDataType": {
            "type": "StateDiffs",
            "value": "State diffs",
            "description": "TODO"
          },
          "knownMembers": [
            {
              "external": false,
              "name": "Immutable",
              "href": "https://assets.website-files.com/646557ee455c3e16e4a9bcb3/6499367de527dd82ab7475a3_Immutable%20Whitepaper%20Update%202023%20(3).pdf"
            },
            {
              "external": true,
              "name": "StarkWare",
              "href": "https://assets.website-files.com/646557ee455c3e16e4a9bcb3/6499367de527dd82ab7475a3_Immutable%20Whitepaper%20Update%202023%20(3).pdf"
            },
            {
              "external": true,
              "name": "Deversifi",
              "href": "https://assets.website-files.com/646557ee455c3e16e4a9bcb3/6499367de527dd82ab7475a3_Immutable%20Whitepaper%20Update%202023%20(3).pdf"
            },
            {
              "external": true,
              "name": "Consensys",
              "href": "https://assets.website-files.com/646557ee455c3e16e4a9bcb3/6499367de527dd82ab7475a3_Immutable%20Whitepaper%20Update%202023%20(3).pdf"
            },
            {
              "external": true,
              "name": "Nethermind",
              "href": "https://assets.website-files.com/646557ee455c3e16e4a9bcb3/6499367de527dd82ab7475a3_Immutable%20Whitepaper%20Update%202023%20(3).pdf"
            },
            {
              "external": true,
              "name": "Iqlusion",
              "href": "https://assets.website-files.com/646557ee455c3e16e4a9bcb3/6499367de527dd82ab7475a3_Immutable%20Whitepaper%20Update%202023%20(3).pdf"
            },
            {
              "external": true,
              "name": "Infura",
              "href": "https://assets.website-files.com/646557ee455c3e16e4a9bcb3/6499367de527dd82ab7475a3_Immutable%20Whitepaper%20Update%202023%20(3).pdf"
            },
            {
              "external": true,
              "name": "Cephalopod",
              "href": "https://assets.website-files.com/646557ee455c3e16e4a9bcb3/6499367de527dd82ab7475a3_Immutable%20Whitepaper%20Update%202023%20(3).pdf"
            }
          ],
          "display": {
            "name": "Immutable X DAC",
            "slug": "dac",
            "description": "Immutable X DAC on Ethereum.",
            "warning": null,
            "redWarning": null,
            "links": {
              "websites": ["https://immutablex.xyz/"],
              "apps": ["https://app.immutable.com/"],
              "documentation": ["https://docs.immutablex.xyz/"],
              "explorers": ["https://explorer.immutable.com/"],
              "repositories": ["https://github.com/Immutable"],
              "socialMedia": [
                "https://medium.com/@immutablex",
                "https://twitter.com/Immutable"
              ]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![starkex bridge architecture](/images/da-bridge-technology/starkex/architectureL2.png#center)\n      The DA commitments are posted to the L1 chain, using the Committee Verifier contract as a DA bridge.\n      The DA commitment consists of a data hash of the transaction batch the Committee has signed off on and a concatenation of ec-signatures by signatories.\n      The Committee Verifier contract verifies the signatures and the data hash and if the required threshold of Committee members has signed off on the data, the hash is stored as a registeredFact in the StarkEx contract.\n      In a separate transaction, the operator calls the updateState() function on the StarkEx contract to update the state.\n      Before the state update is accepted, the StarkEx contract verifies the transaction public inputs by calling the isValid() function, which verifies the hash derived from state update inputs matches the hash stored by the Committee Verifier contract.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "5/7",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "real-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": "Ethereum (blobs)",
      "hasChallengeMechanism": null,
      "display": {
        "name": "Re.al DAC",
        "slug": "real",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://re.al"],
          "apps": ["https://re.al/bridge/", "https://re.al/app/bridge/"],
          "documentation": ["https://docs.re.al/"],
          "explorers": ["https://explorer.re.al"],
          "repositories": ["https://github.com/re-al-Foundation"],
          "socialMedia": [
            "https://x.com/real_rwa",
            "https://discord.gg/cKCCCFXvWj",
            "https://mirror.xyz/0xBE105a62f39a2E0b09772C49E3EcF6ef21BEd85C"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![Anytrust architecture](/images/da-layer-technology/anytrust/architecture2.png#center)\n\n    The DAC uses a data availability solution built on the AnyTrust protocol. It is composed of the following components:\n    - **Sequencer Inbox**: Main entry point for the Sequencer submitting transaction batches.\n    - **Data Availability Committee (DAC)**: A group of members responsible for storing and providing data on demand.\n    - **Data Availability Certificate (DACert)**: A commitment ensuring that data blobs are available without needing full data posting on the L1 chain. \n\n    \n    Committee members run servers that support APIs for storing and retrieving data blobs. \n    The Sequencer API allows the rollup Sequencer to submit data blobs for storage, while the REST API enables anyone to fetch data by hash. \n    When the Sequencer produces a data batch, it sends the batch along with an expiration time to Committee members, who store it and sign it. \n    Once enough signatures are collected, the Sequencer aggregates them into a valid DACert and posts it to the L1 chain inbox. \n    If the Sequencer fails to collect enough signatures, it falls back to posting the full data to the L1 chain. \n\n\n    A DACert includes a hash of the data block, an expiration time, and proof that the required threshold of Committee members have signed off on the data. \n    The proof consists of a hash of the Keyset used in signing, a bitmap indicating which members signed, and a BLS aggregated signature. \n    L2 nodes reading from the sequencer inbox verify the certificate’s validity by checking the number of signers, the aggregated signature, and that the expiration time is at least two weeks ahead of the L2 timestamp. \n    If the DACert is valid, it provides a proof that the corresponding data is available from honest committee members.\n\n    ",
        "risks": null
      },
      "usedIn": [{ "id": "real", "name": "Re.al", "slug": "real" }],
      "bridges": [
        {
          "id": "real-dac-bridge",
          "type": "DAC",
          "usedIn": [{ "id": "real", "name": "Re.al", "slug": "real" }],
          "createdAt": "1723211933",
          "contracts": {
            "addresses": [
              {
                "name": "SequencerInbox",
                "address": "0x51C4a227D59E49E26Ea07D8e4E9Af163da4c87A0",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0xB032ff02cd6425e4b816137207AA8560932180f1"],
                  "implementations": [
                    "0x873484Ba63353C8b71210ce123B465512d408B27"
                  ]
                },
                "chain": "ethereum",
                "description": "Main entry point for the Sequencer submitting transaction batches."
              }
            ],
            "risks": []
          },
          "permissions": [
            {
              "name": "Sequencers",
              "accounts": [
                {
                  "address": "0x0e00df1afC8574762Ac4C4D8E5D1a19bD6A8Fa2E",
                  "type": "EOA"
                }
              ],
              "description": "Central actors allowed to submit transaction batches to the Sequencer Inbox.",
              "chain": "ethereum"
            },
            {
              "name": "RollupOwner",
              "accounts": [
                {
                  "address": "0xBeA2Bc852a160B8547273660E22F4F08C2fa9Bbb",
                  "type": "MultiSig"
                }
              ],
              "description": "Multisig that can upgrade authorized batch posters via the UpgradeExecutor contract."
            }
          ],
          "chain": 1,
          "requiredMembers": 1,
          "membersCount": 2,
          "transactionDataType": {
            "type": "TransactionDataCompressed",
            "value": "Transaction data (compressed)",
            "description": "TODO"
          },
          "display": {
            "name": "Re.al DAC",
            "slug": "dac",
            "description": "Re.al DAC on Ethereum.",
            "warning": null,
            "redWarning": "Only one signer is required to attest to the availability of the data.",
            "links": {
              "websites": ["https://re.al"],
              "apps": ["https://re.al/bridge/", "https://re.al/app/bridge/"],
              "documentation": ["https://docs.re.al/"],
              "explorers": ["https://explorer.re.al"],
              "repositories": ["https://github.com/re-al-Foundation"],
              "socialMedia": [
                "https://x.com/real_rwa",
                "https://discord.gg/cKCCCFXvWj",
                "https://mirror.xyz/0xBE105a62f39a2E0b09772C49E3EcF6ef21BEd85C"
              ]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![Anytrust bridge architecture](/images/da-bridge-technology/anytrust/architectureL2.png#center)\n\n\n    The DA commitments are posted to the L1 through the sequencer inbox, using the inbox as a DA bridge.\n    The DA commitment consists of Data Availability Certificate (DACert), including a hash of the data block, an expiration time, and a proof that the required threshold of Committee members have signed off on the data.\n    The sequencer distributes the data and collects signatures from Committee members offchain. Only the DACert is posted by the sequencer to the L1 chain inbox (the DA bridge), achieving L2 transaction ordering finality in a single onchain transaction.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "1/2",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "apex-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": null,
      "hasChallengeMechanism": null,
      "display": {
        "name": "ApeX DAC",
        "slug": "apex",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://apex.exchange/"],
          "apps": ["https://pro.apex.exchange/"],
          "documentation": ["https://apex-pro.gitbook.io/apex-pro?lang=en-US"],
          "explorers": [],
          "repositories": ["https://github.com/ApeX-Protocol/core"],
          "socialMedia": [
            "https://twitter.com/OfficialApeXdex",
            "https://apexdex.medium.com/",
            "https://t.me/ApeXdex",
            "https://discord.com/invite/apexprotocol",
            "https://youtube.com/@apexprotocol"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![starkex architecture](/images/da-layer-technology/starkex/architecture5.png#center)\n\n    The Starkware application utilizes a data availability solution that relies on a Committee Service to ensure data persistence. This architecture comprises the following components:\n\n    - **Availability Gateway**: The primary interface provided by the operator for committee members to access new batch information and submit signed availability claims.\n    - **Data Availability Committee (DAC)**: A group of nodes responsible for storing state data associated with each Merkle root and attesting to data availability by signing claims.\n    - **Data Batches**: Collections of transactions processed in batches that update the state of accounts, resulting in a new Merkle root representing the updated state.\n    \n    Committee members run services that interact with the Availability Gateway to obtain information about new batches and submit their signed availability claims. Each batch includes a unique batch_id, a reference to a previous batch, and a list of account updates. \n    Committee members combine this information with data from the reference batch to compute the new state and verify the Merkle root.\n    \n    When the operator produces a new batch, it must be signed by a minimum number of committee members—as defined by the application's configuration—for it to be accepted onchain. \n    This includes all members designated as mandatory signers. If the operator attempts to submit a batch without the required signatures, it will be rejected, thereby ensuring that data remains available and consistent.\n    \n    Committee members are expected to maintain a database that stores the data associated with each batch, making use of storage solutions with a replication factor of at least 2.\n  \n    ",
        "risks": null
      },
      "usedIn": [{ "id": "apex", "name": "ApeX", "slug": "apex" }],
      "bridges": [
        {
          "id": "apex-dac-bridge",
          "type": "DAC",
          "usedIn": [{ "id": "apex", "name": "ApeX", "slug": "apex" }],
          "createdAt": "1723211933",
          "chain": 1,
          "requiredMembers": 3,
          "membersCount": 5,
          "transactionDataType": {
            "type": "StateDiffs",
            "value": "State diffs",
            "description": "TODO"
          },
          "contracts": {
            "addresses": [
              {
                "name": "CommitteeUSDC",
                "address": "0x23Cab3CF1aa7B929Df5e9f3712aCA3A6Fb9494E4",
                "upgradeability": null,
                "chain": "ethereum",
                "description": "Data Availability Committee (DAC) contract for USDC StarkEx instance, verifying data availability claim from DAC Members (via multisig check)."
              },
              {
                "name": "CommitteeUSDT",
                "address": "0x7249082BfAFE9BCA502d38a686Ef3df37A0cf800",
                "upgradeability": null,
                "chain": "ethereum",
                "description": "Data Availability Committee (DAC) contract for USDT StarkEx instance, verifying data availability claim from DAC Members (via multisig check)."
              }
            ],
            "risks": []
          },
          "permissions": [
            {
              "name": "USDC Committee Members",
              "description": "List of addresses authorized to sign data commitments for the DA bridge.",
              "accounts": [
                {
                  "address": "0x696cC7615A50CF12d1d1B38bF18A5606e9708296",
                  "type": "EOA"
                },
                {
                  "address": "0x81165b6504520416487E5b4935865b4D3eeaa6e5",
                  "type": "EOA"
                },
                {
                  "address": "0xA6d068DE0da2Dc1BeCaB509B118CB88723f72b6A",
                  "type": "EOA"
                },
                {
                  "address": "0x0cbb676d12745948f75aF3A172cb7E4A4f8546e8",
                  "type": "EOA"
                },
                {
                  "address": "0xB0d71Ff040A941bB9CA8453044634EebCE5A053D",
                  "type": "EOA"
                },
                {
                  "address": "0x8f3310cc6951AC11F2B125fC8AC2dfA133A9498c",
                  "type": "EOA"
                }
              ]
            },
            {
              "name": "USDT Committee Members",
              "description": "List of addresses authorized to sign data commitments for the DA bridge.",
              "accounts": [
                {
                  "address": "0x17094A7Cc09686787E0dF95604fd1F9da94B9501",
                  "type": "EOA"
                },
                {
                  "address": "0x8f3310cc6951AC11F2B125fC8AC2dfA133A9498c",
                  "type": "EOA"
                },
                {
                  "address": "0xb557219DC53Af7Da9777540426DEe9c196842420",
                  "type": "EOA"
                },
                {
                  "address": "0x4F753A937318A64b2867b16a55f5aea83A4C44dB",
                  "type": "EOA"
                },
                {
                  "address": "0x81165b6504520416487E5b4935865b4D3eeaa6e5",
                  "type": "EOA"
                }
              ]
            }
          ],
          "display": {
            "name": "ApeX DAC",
            "slug": "dac",
            "description": "ApeX DAC on Ethereum.",
            "warning": null,
            "redWarning": null,
            "links": {
              "websites": ["https://apex.exchange/"],
              "apps": ["https://pro.apex.exchange/"],
              "documentation": [
                "https://apex-pro.gitbook.io/apex-pro?lang=en-US"
              ],
              "explorers": [],
              "repositories": ["https://github.com/ApeX-Protocol/core"],
              "socialMedia": [
                "https://twitter.com/OfficialApeXdex",
                "https://apexdex.medium.com/",
                "https://t.me/ApeXdex",
                "https://discord.com/invite/apexprotocol",
                "https://youtube.com/@apexprotocol"
              ]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![starkex bridge architecture](/images/da-bridge-technology/starkex/architectureL2.png#center)\n      The DA commitments are posted to the L1 chain, using the Committee Verifier contract as a DA bridge.\n      The DA commitment consists of a data hash of the transaction batch the Committee has signed off on and a concatenation of ec-signatures by signatories.\n      The Committee Verifier contract verifies the signatures and the data hash and if the required threshold of Committee members has signed off on the data, the hash is stored as a registeredFact in the StarkEx contract.\n      In a separate transaction, the operator calls the updateState() function on the StarkEx contract to update the state.\n      Before the state update is accepted, the StarkEx contract verifies the transaction public inputs by calling the isValid() function, which verifies the hash derived from state update inputs matches the hash stored by the Committee Verifier contract.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "3/5",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "nova-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": null,
      "hasChallengeMechanism": null,
      "display": {
        "name": "Arbitrum Nova DAC",
        "slug": "nova",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": [
            "https://nova.arbitrum.io/",
            "https://arbitrum.io/",
            "https://arbitrum.foundation/"
          ],
          "apps": [
            "https://bridge.arbitrum.io/?destinationChain=arbitrum-nova&sourceChain=ethereum"
          ],
          "documentation": [
            "https://developer.arbitrum.io/",
            "https://developer.arbitrum.io/inside-arbitrum-nitro/#inside-anytrust"
          ],
          "explorers": [
            "https://nova.arbiscan.io/",
            "https://nova-explorer.arbitrum.io/"
          ],
          "repositories": [
            "https://github.com/ArbitrumFoundation/docs",
            "https://github.com/ArbitrumFoundation/governance",
            "https://github.com/OffchainLabs/nitro"
          ],
          "socialMedia": [
            "https://twitter.com/arbitrum",
            "https://arbitrumfoundation.medium.com/",
            "https://discord.gg/Arbitrum"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![Nova architecture](/images/da-layer-technology/nova/architecture.png#center)\n\n    Nova is a data availability solution for Arbitrum rollups built on the AnyTrust protocol. It is composed of the following components:\n    - **Sequencer Inbox**: Main entry point for the Sequencer submitting transaction batches.\n    - **Data Availability Committee (DAC)**: A group of members responsible for storing and providing data on demand.\n    - **Data Availability Certificate (DACert)**: A commitment ensuring that data blobs are available without needing full data posting on the L1 chain. \n\n    \n    Committee members run servers that support APIs for storing and retrieving data blobs. \n    The Sequencer API allows the rollup Sequencer to submit data blobs for storage, while the REST API enables anyone to fetch data by hash. \n    When the Sequencer produces a data batch, it sends the batch along with an expiration time to Committee members, who store it and sign it. \n    Once enough signatures are collected, the Sequencer aggregates them into a valid DACert and posts it to the L1 chain inbox. \n    If the Sequencer fails to collect enough signatures, it falls back to posting the full data to the L1 chain. \n\n\n    A DACert includes a hash of the data block, an expiration time, and proof that the required threshold of Committee members have signed off on the data. \n    The proof consists of a hash of the Keyset used in signing, a bitmap indicating which members signed, and a BLS aggregated signature. \n    L2 nodes reading from the sequencer inbox verify the certificate’s validity by checking the number of signers, the aggregated signature, and that the expiration time is at least two weeks ahead of the L2 timestamp. \n    If the DACert is valid, it provides a proof that the corresponding data is available from honest committee members.\n\n    ",
        "risks": null
      },
      "usedIn": [{ "id": "nova", "name": "Arbitrum Nova", "slug": "nova" }],
      "bridges": [
        {
          "id": "nova-dac-bridge",
          "type": "DAC",
          "usedIn": [{ "id": "nova", "name": "Arbitrum Nova", "slug": "nova" }],
          "createdAt": "1723211933",
          "chain": 1,
          "requiredMembers": 5,
          "membersCount": 6,
          "transactionDataType": {
            "type": "TransactionDataCompressed",
            "value": "Transaction data (compressed)",
            "description": "TODO"
          },
          "knownMembers": [
            {
              "external": true,
              "name": "ConsenSys Software Inc.",
              "href": "https://docs.arbitrum.foundation/state-of-progressive-decentralization#data-availability-committee-members"
            },
            {
              "external": true,
              "name": "QuickNode, Inc.",
              "href": "https://docs.arbitrum.foundation/state-of-progressive-decentralization#data-availability-committee-members"
            },
            {
              "external": true,
              "name": "P2P.org",
              "href": "https://docs.arbitrum.foundation/state-of-progressive-decentralization#data-availability-committee-members"
            },
            {
              "external": true,
              "name": "Google Cloud",
              "href": "https://docs.arbitrum.foundation/state-of-progressive-decentralization#data-availability-committee-members"
            },
            {
              "external": false,
              "name": "Offchain Labs, Inc.",
              "href": "https://docs.arbitrum.foundation/state-of-progressive-decentralization#data-availability-committee-members"
            },
            {
              "external": true,
              "name": "Opensea Innovation Labs Private Limited",
              "href": "https://docs.arbitrum.foundation/state-of-progressive-decentralization#data-availability-committee-members"
            }
          ],
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![Nova bridge architecture](/images/da-bridge-technology/nova/architecture.png#center)\n\n\n    In Nova architecture, the DA commitments are posted to the L1 through the sequencer inbox, using the inbox as a DA bridge.\n    The DA commitment consists of Data Availability Certificate (DACert), including a hash of the data block, an expiration time, and a proof that the required threshold of Committee members have signed off on the data.\n    The sequencer distributes the data and collects signatures from Committee members offchain. Only the DACert is posted by the sequencer to the L1 chain inbox (the DA bridge), achieving L2 transaction ordering finality in a single onchain transaction.\n    ",
            "risks": null
          },
          "permissions": [
            {
              "name": "Sequencers",
              "accounts": [
                {
                  "address": "0x0C5911d57B24FCF1DC8B2608eFbAe57C7098E32D",
                  "type": "EOA"
                },
                {
                  "address": "0xC1b634853Cb333D3aD8663715b08f41A3Aec47cc",
                  "type": "EOA"
                }
              ],
              "description": "Central actors allowed to submit transaction batches to the Sequencer Inbox.",
              "chain": "ethereum"
            },
            {
              "name": "BatchPosterManagerMultisig",
              "description": "This is a Gnosis Safe with 4 / 6 threshold.  It can update whether an address is authorized to be a batch poster at the sequencer inbox. The UpgradeExecutor retains the ability to update the batch poster manager (along with any batch posters).",
              "accounts": [
                {
                  "address": "0xd0FDA6925f502a3a94986dfe7C92FE19EBbD679B",
                  "type": "MultiSig"
                }
              ],
              "chain": "ethereum",
              "references": null,
              "participants": [
                {
                  "address": "0x375906ADFD34D93236084F462BB2dB0D92129Fe1",
                  "type": "EOA"
                },
                {
                  "address": "0xfE2bf40f2A9183774BF8E871d634A4E50255158B",
                  "type": "EOA"
                },
                {
                  "address": "0x64379Dee676ab442B48925Ed603771f386510Ee7",
                  "type": "EOA"
                },
                {
                  "address": "0x290Aa3E7533c873B3326DabFe7579e86ed951428",
                  "type": "EOA"
                },
                {
                  "address": "0x4d9A23BD4DBBdC04A88B99d8d2ac450EB6b8f49C",
                  "type": "EOA"
                },
                {
                  "address": "0x79D3Bb67EA7aB77E015af3dA885E8ed9C48a9fCe",
                  "type": "EOA"
                }
              ]
            },
            {
              "name": "UpgradeExecutor",
              "accounts": [
                {
                  "address": "0x3ffFbAdAF827559da092217e474760E2b2c3CeDd",
                  "type": "Contract"
                }
              ],
              "description": "The UpgradeExecutor can change the Committee members by updating the valid keyset."
            }
          ],
          "contracts": {
            "addresses": [
              {
                "name": "SequencerInbox",
                "address": "0x211E1c4c7f1bF5351Ac850Ed10FD68CFfCF6c21b",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x71D78dC7cCC0e037e12de1E50f5470903ce37148"],
                  "implementations": [
                    "0x31DA64D19Cd31A19CD09F4070366Fe2144792cf7"
                  ]
                },
                "chain": "ethereum",
                "description": "Main entry point for the Sequencer submitting transaction batches."
              },
              {
                "name": "UpgradeExecutor",
                "address": "0x3ffFbAdAF827559da092217e474760E2b2c3CeDd",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x5613AF0474EB9c528A34701A5b1662E3C8FA0678"],
                  "implementations": [
                    "0x86f0cf42Ad673B3D666d103E009EC142D1298a17"
                  ]
                },
                "chain": "ethereum",
                "description": "This contract can upgrade the system's contracts. The upgrades can be done either by the Security Council or by the L1Timelock.",
                "upgradableBy": ["SecurityCouncil", "L1Timelock"],
                "upgradeDelay": "12d 8h or 0 if overridden by Security Council.",
                "upgradeConsiderations": "An upgrade initiated by the DAO can be vetoed by the Security Council."
              },
              {
                "name": "L1Timelock",
                "address": "0xE6841D92B0C345144506576eC13ECf5103aC7f49",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x5613AF0474EB9c528A34701A5b1662E3C8FA0678"],
                  "implementations": [
                    "0x61dC65001A8De4138DAD5167e43FF0FB0AB8D3B3"
                  ]
                },
                "chain": "ethereum",
                "description": "Timelock contract for Arbitrum Governance transactions. Scheduled transactions from Arbitrum One L2 (by the DAO or the Security Council) are delayed here and can be canceled by the Security Council or executed to upgrade and change system contracts on Ethereum, Arbitrum One and -Nova.",
                "upgradableBy": ["SecurityCouncil", "L1Timelock"],
                "upgradeDelay": "12d 8h or 0 if overridden by Security Council.",
                "upgradeConsiderations": "An upgrade initiated by the DAO can be vetoed by the Security Council."
              }
            ],
            "risks": []
          },
          "display": {
            "name": "Arbitrum Nova DAC",
            "slug": "dac",
            "description": "Arbitrum Nova DAC on Ethereum.",
            "warning": null,
            "redWarning": null,
            "links": {
              "websites": [
                "https://nova.arbitrum.io/",
                "https://arbitrum.io/",
                "https://arbitrum.foundation/"
              ],
              "apps": [
                "https://bridge.arbitrum.io/?destinationChain=arbitrum-nova&sourceChain=ethereum"
              ],
              "documentation": [
                "https://developer.arbitrum.io/",
                "https://developer.arbitrum.io/inside-arbitrum-nitro/#inside-anytrust"
              ],
              "explorers": [
                "https://nova.arbiscan.io/",
                "https://nova-explorer.arbitrum.io/"
              ],
              "repositories": [
                "https://github.com/ArbitrumFoundation/docs",
                "https://github.com/ArbitrumFoundation/governance",
                "https://github.com/OffchainLabs/nitro"
              ],
              "socialMedia": [
                "https://twitter.com/arbitrum",
                "https://arbitrumfoundation.medium.com/",
                "https://discord.gg/Arbitrum"
              ]
            }
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "5/6",
              "sentiment": "warning",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "reya-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": "Ethereum (blobs)",
      "hasChallengeMechanism": null,
      "display": {
        "name": "Reya DAC",
        "slug": "reya",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://reya.network/"],
          "apps": [
            "https://reya.network/lge",
            "https://bridge.gelato.network/bridge/reya-network"
          ],
          "documentation": ["https://docs.reya.network/"],
          "explorers": ["https://explorer.reya.network/"],
          "repositories": ["https://github.com/Reya-Labs"],
          "socialMedia": [
            "https://twitter.com/Reya_xyz",
            "https://discord.gg/reyaxyz",
            "https://medium.com/@reyalabs123"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![Anytrust architecture](/images/da-layer-technology/anytrust/architecture2.png#center)\n\n    The DAC uses a data availability solution built on the AnyTrust protocol. It is composed of the following components:\n    - **Sequencer Inbox**: Main entry point for the Sequencer submitting transaction batches.\n    - **Data Availability Committee (DAC)**: A group of members responsible for storing and providing data on demand.\n    - **Data Availability Certificate (DACert)**: A commitment ensuring that data blobs are available without needing full data posting on the L1 chain. \n\n    \n    Committee members run servers that support APIs for storing and retrieving data blobs. \n    The Sequencer API allows the rollup Sequencer to submit data blobs for storage, while the REST API enables anyone to fetch data by hash. \n    When the Sequencer produces a data batch, it sends the batch along with an expiration time to Committee members, who store it and sign it. \n    Once enough signatures are collected, the Sequencer aggregates them into a valid DACert and posts it to the L1 chain inbox. \n    If the Sequencer fails to collect enough signatures, it falls back to posting the full data to the L1 chain. \n\n\n    A DACert includes a hash of the data block, an expiration time, and proof that the required threshold of Committee members have signed off on the data. \n    The proof consists of a hash of the Keyset used in signing, a bitmap indicating which members signed, and a BLS aggregated signature. \n    L2 nodes reading from the sequencer inbox verify the certificate’s validity by checking the number of signers, the aggregated signature, and that the expiration time is at least two weeks ahead of the L2 timestamp. \n    If the DACert is valid, it provides a proof that the corresponding data is available from honest committee members.\n\n    ",
        "risks": null
      },
      "usedIn": [{ "id": "reya", "name": "Reya", "slug": "reya" }],
      "bridges": [
        {
          "id": "reya-dac-bridge",
          "type": "DAC",
          "usedIn": [{ "id": "reya", "name": "Reya", "slug": "reya" }],
          "createdAt": "1723211933",
          "contracts": {
            "addresses": [
              {
                "name": "SequencerInbox",
                "address": "0x6CA2A628fb690Bd431F4aA608655ce37c66aff9d",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x74627dd54FA6E94c87F12DBAdAEc275758f51dF9"],
                  "implementations": [
                    "0x873484Ba63353C8b71210ce123B465512d408B27"
                  ]
                },
                "chain": "ethereum",
                "description": "Main entry point for the Sequencer submitting transaction batches."
              }
            ],
            "risks": []
          },
          "permissions": [
            {
              "name": "Sequencers",
              "accounts": [
                {
                  "address": "0xf5636Df6f86f31668aeAe9bB8a1C4F0ED147926a",
                  "type": "EOA"
                }
              ],
              "description": "Central actors allowed to submit transaction batches to the Sequencer Inbox.",
              "chain": "ethereum"
            },
            {
              "name": "RollupOwner",
              "accounts": [
                {
                  "address": "0xBeA2Bc852a160B8547273660E22F4F08C2fa9Bbb",
                  "type": "MultiSig"
                }
              ],
              "description": "Multisig that can upgrade authorized batch posters via the UpgradeExecutor contract."
            }
          ],
          "chain": 1,
          "requiredMembers": 1,
          "membersCount": 2,
          "transactionDataType": {
            "type": "TransactionDataCompressed",
            "value": "Transaction data (compressed)",
            "description": "TODO"
          },
          "display": {
            "name": "Reya DAC",
            "slug": "dac",
            "description": "Reya DAC on Ethereum.",
            "warning": null,
            "redWarning": "Only one signer is required to attest to the availability of the data.",
            "links": {
              "websites": ["https://reya.network/"],
              "apps": [
                "https://reya.network/lge",
                "https://bridge.gelato.network/bridge/reya-network"
              ],
              "documentation": ["https://docs.reya.network/"],
              "explorers": ["https://explorer.reya.network/"],
              "repositories": ["https://github.com/Reya-Labs"],
              "socialMedia": [
                "https://twitter.com/Reya_xyz",
                "https://discord.gg/reyaxyz",
                "https://medium.com/@reyalabs123"
              ]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![Anytrust bridge architecture](/images/da-bridge-technology/anytrust/architectureL2.png#center)\n\n\n    The DA commitments are posted to the L1 through the sequencer inbox, using the inbox as a DA bridge.\n    The DA commitment consists of Data Availability Certificate (DACert), including a hash of the data block, an expiration time, and a proof that the required threshold of Committee members have signed off on the data.\n    The sequencer distributes the data and collects signatures from Committee members offchain. Only the DACert is posted by the sequencer to the L1 chain inbox (the DA bridge), achieving L2 transaction ordering finality in a single onchain transaction.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "1/2",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "xlayer-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": null,
      "hasChallengeMechanism": null,
      "display": {
        "name": "X Layer DAC",
        "slug": "xlayer",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://okx.com/xlayer"],
          "apps": [],
          "documentation": [
            "https://okx.com/xlayer/docs/users/welcome/about-x-layer"
          ],
          "explorers": ["https://okx.com/explorer/xlayer"],
          "repositories": [],
          "socialMedia": ["https://twitter.com/XLayerOfficial"]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![polygoncdk architecture](/images/da-layer-technology/polygoncdk/architecture2.png#center)\n\n    Polygon CDK validiums utilize a data availability solution that relies on a Data Availability Committee (DAC) to ensure data integrity and manage off-chain transaction data. \n    This architecture comprises the following components:\n    - **Operator**: A trusted entity that collects transactions, computes hash values for the transaction batch, and then requests and collects signatures from Committee members.\n    - **Data Availability Committee (DAC)**: A group of nodes responsible for validating batch data against the hash values provided by the operator (sequencer), ensuring the data accurately represents the transactions.\n    - **PolygonCommittee Contract**: Contract responsible for managing the data committee members list.\n    Each DAC node independently validates the batch data, ensuring it matches the received hash values. \n    Upon successful validation, DAC members store the hash values locally and generate signatures endorsing the batch's integrity. \n    The sequencer collects these signatures and submits the transactions batch hash together with the aggregated signature on Ethereum.\n    The PolygonCommittee contract is used during batch sequencing to verify that the signature posted by the sequencer was signed off by the DAC members stored in the contract.\n    ",
        "risks": null
      },
      "usedIn": [{ "id": "xlayer", "name": "X Layer", "slug": "xlayer" }],
      "bridges": [
        {
          "id": "xlayer-dac-bridge",
          "type": "DAC",
          "usedIn": [{ "id": "xlayer", "name": "X Layer", "slug": "xlayer" }],
          "createdAt": "1723211933",
          "contracts": {
            "addresses": [
              {
                "name": "XLayerValidium",
                "address": "0x2B0ee28D4D51bC9aDde5E58E295873F61F4a0507",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x5132A183E9F3CB7C848b0AAC5Ae0c4f0491B7aB2"],
                  "implementations": [
                    "0x10D296e8aDd0535be71639E5D1d1c30ae1C6bD4C"
                  ]
                },
                "chain": "ethereum",
                "description": "The main contract of the XLayerValidium. Contains sequenced transaction batch hashes and signature verification logic for the signed data hash commitment."
              },
              {
                "name": "XLayerValidiumDAC",
                "address": "0x05652Ec92366F3C2255991a265c499E01Ba58e6a",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x1e37EA18e9515db29b3E94A00eD31484A3130204"],
                  "implementations": [
                    "0xd620Ca1ad5c3888e4521c3374cE4088Cb78079b8"
                  ]
                },
                "chain": "ethereum",
                "description": "Validium committee contract that allows the admin to setup the members of the committee and stores the required amount of signatures threshold.",
                "upgradableBy": ["DACProxyAdminOwner"],
                "upgradeDelay": "No delay"
              }
            ],
            "risks": []
          },
          "permissions": [
            {
              "name": "Committee Members",
              "description": "List of addresses authorized to sign data commitments for the DA bridge.",
              "accounts": [
                {
                  "address": "0x19A81baC80f9cE3A45095f3df3a7cF69ef18fC08",
                  "type": "EOA"
                },
                {
                  "address": "0xE94Ac3cBc1C7EFFEACca68e3Bfe5D81E26A659B5",
                  "type": "EOA"
                }
              ]
            },
            {
              "name": "LocalAdmin",
              "accounts": [
                {
                  "address": "0x491619874b866c3cDB7C8553877da223525ead01",
                  "type": "EOA"
                }
              ],
              "description": "Admin of the XLayerValidium contract, can set core system parameters like timeouts, sequencer, activate forced transactions and update the DA mode."
            },
            {
              "name": "DACProxyAdminOwner",
              "accounts": [
                {
                  "address": "0xE4c5BFaddbf21a1F35AE66F180F78822078FBfDE",
                  "type": "EOA"
                }
              ],
              "description": "Owner of the XLayerValidiumDAC's ProxyAdmin. Can upgrade the contract."
            }
          ],
          "chain": 1,
          "requiredMembers": 2,
          "membersCount": 2,
          "transactionDataType": {
            "type": "TransactionData",
            "value": "Transaction data",
            "description": "TODO"
          },
          "display": {
            "name": "X Layer DAC",
            "slug": "dac",
            "description": "X Layer DAC on Ethereum.",
            "warning": null,
            "redWarning": null,
            "links": {
              "websites": ["https://okx.com/xlayer"],
              "apps": [],
              "documentation": [
                "https://okx.com/xlayer/docs/users/welcome/about-x-layer"
              ],
              "explorers": ["https://okx.com/explorer/xlayer"],
              "repositories": [],
              "socialMedia": ["https://twitter.com/XLayerOfficial"]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![polygoncdk bridge architecture](/images/da-bridge-technology/polygoncdk/architectureL2.png#center)\n    The DA commitments are posted to the L1 through the sequencer inbox, using the inbox as a DA bridge.\n    The DA commitment consists of a data availability message provided as transaction input, made up of a byte array containing the signatures and all the addresses of the committee in ascending order.\n    The sequencer distributes the data and collects signatures from Committee members offchain. Only the DA message is posted by the sequencer to the L1 chain inbox (the DA bridge).\n    A separate contract, the PolygonCommittee contract, is used to manage the committee members list and verify the signatures before accepting the DA commitment.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "2/2",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "sorare-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": null,
      "hasChallengeMechanism": null,
      "display": {
        "name": "Sorare DAC",
        "slug": "sorare",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://sorare.com/"],
          "apps": [],
          "documentation": ["https://docs.starkware.co/starkex/index.html"],
          "explorers": [],
          "repositories": [
            "https://github.com/starkware-libs/starkex-contracts"
          ],
          "socialMedia": [
            "https://discord.gg/TSjtHaM",
            "https://reddit.com/r/Sorare/",
            "https://twitter.com/Sorare",
            "https://instagram.com/sorare_official/"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![starkex architecture](/images/da-layer-technology/starkex/architecture4.png#center)\n\n    The Starkware application utilizes a data availability solution that relies on a Committee Service to ensure data persistence. This architecture comprises the following components:\n\n    - **Availability Gateway**: The primary interface provided by the operator for committee members to access new batch information and submit signed availability claims.\n    - **Data Availability Committee (DAC)**: A group of nodes responsible for storing state data associated with each Merkle root and attesting to data availability by signing claims.\n    - **Data Batches**: Collections of transactions processed in batches that update the state of accounts, resulting in a new Merkle root representing the updated state.\n    \n    Committee members run services that interact with the Availability Gateway to obtain information about new batches and submit their signed availability claims. Each batch includes a unique batch_id, a reference to a previous batch, and a list of account updates. \n    Committee members combine this information with data from the reference batch to compute the new state and verify the Merkle root.\n    \n    When the operator produces a new batch, it must be signed by a minimum number of committee members—as defined by the application's configuration—for it to be accepted onchain. \n    This includes all members designated as mandatory signers. If the operator attempts to submit a batch without the required signatures, it will be rejected, thereby ensuring that data remains available and consistent.\n    \n    Committee members are expected to maintain a database that stores the data associated with each batch, making use of storage solutions with a replication factor of at least 2.\n  \n    ",
        "risks": null
      },
      "usedIn": [{ "id": "sorare", "name": "Sorare", "slug": "sorare" }],
      "bridges": [
        {
          "id": "sorare-dac-bridge",
          "type": "DAC",
          "usedIn": [{ "id": "sorare", "name": "Sorare", "slug": "sorare" }],
          "createdAt": "1723211933",
          "contracts": {
            "addresses": [
              {
                "name": "Committee",
                "address": "0x879cD57975d596004863D30c59d579ef78BBbe32",
                "upgradeability": null,
                "chain": "ethereum",
                "description": "Data Availability Committee (DAC) contract verifying data availability claim from DAC Members (via multisig check)."
              }
            ],
            "risks": []
          },
          "permissions": [
            {
              "name": "Committee Members",
              "description": "List of addresses authorized to sign data commitments for the DA bridge.",
              "accounts": [
                {
                  "address": "0x6EBCb783E53C072e9b1C8786942aefc145C6Df75",
                  "type": "EOA"
                },
                {
                  "address": "0x9bC546c5741d31b3510D3B240bDB4c517030E318",
                  "type": "EOA"
                },
                {
                  "address": "0xA70A45E56c087A34991A712d437fcFfd79D3a8Ec",
                  "type": "EOA"
                },
                {
                  "address": "0xefaaf3A5D0D795C7c1f92cBeDE868C273790026e",
                  "type": "EOA"
                }
              ]
            }
          ],
          "chain": 1,
          "requiredMembers": 2,
          "membersCount": 4,
          "transactionDataType": {
            "type": "StateDiffs",
            "value": "State diffs",
            "description": "TODO"
          },
          "display": {
            "name": "Sorare DAC",
            "slug": "dac",
            "description": "Sorare DAC on Ethereum.",
            "warning": null,
            "redWarning": null,
            "links": {
              "websites": ["https://sorare.com/"],
              "apps": [],
              "documentation": ["https://docs.starkware.co/starkex/index.html"],
              "explorers": [],
              "repositories": [
                "https://github.com/starkware-libs/starkex-contracts"
              ],
              "socialMedia": [
                "https://discord.gg/TSjtHaM",
                "https://reddit.com/r/Sorare/",
                "https://twitter.com/Sorare",
                "https://instagram.com/sorare_official/"
              ]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![starkex bridge architecture](/images/da-bridge-technology/starkex/architectureL2.png#center)\n      The DA commitments are posted to the L1 chain, using the Committee Verifier contract as a DA bridge.\n      The DA commitment consists of a data hash of the transaction batch the Committee has signed off on and a concatenation of ec-signatures by signatories.\n      The Committee Verifier contract verifies the signatures and the data hash and if the required threshold of Committee members has signed off on the data, the hash is stored as a registeredFact in the StarkEx contract.\n      In a separate transaction, the operator calls the updateState() function on the StarkEx contract to update the state.\n      Before the state update is accepted, the StarkEx contract verifies the transaction public inputs by calling the isValid() function, which verifies the hash derived from state update inputs matches the hash stored by the Committee Verifier contract.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "2/4",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "zkfair-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": null,
      "hasChallengeMechanism": null,
      "display": {
        "name": "ZKFair DAC",
        "slug": "zkfair",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://zkfair.io/"],
          "apps": ["https://wallet.zkfair.io/"],
          "documentation": ["https://docs.zkfair.io/"],
          "explorers": ["https://scan.zkfair.io/"],
          "repositories": ["https://github.com/ZKFair"],
          "socialMedia": ["https://twitter.com/ZKFCommunity"]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![polygoncdk architecture](/images/da-layer-technology/polygoncdk/architecture5.png#center)\n\n    Polygon CDK validiums utilize a data availability solution that relies on a Data Availability Committee (DAC) to ensure data integrity and manage off-chain transaction data. \n    This architecture comprises the following components:\n    - **Operator**: A trusted entity that collects transactions, computes hash values for the transaction batch, and then requests and collects signatures from Committee members.\n    - **Data Availability Committee (DAC)**: A group of nodes responsible for validating batch data against the hash values provided by the operator (sequencer), ensuring the data accurately represents the transactions.\n    - **PolygonCommittee Contract**: Contract responsible for managing the data committee members list.\n    Each DAC node independently validates the batch data, ensuring it matches the received hash values. \n    Upon successful validation, DAC members store the hash values locally and generate signatures endorsing the batch's integrity. \n    The sequencer collects these signatures and submits the transactions batch hash together with the aggregated signature on Ethereum.\n    The PolygonCommittee contract is used during batch sequencing to verify that the signature posted by the sequencer was signed off by the DAC members stored in the contract.\n    ",
        "risks": null
      },
      "usedIn": [{ "id": "zkfair", "name": "ZKFair", "slug": "zkfair" }],
      "bridges": [
        {
          "id": "zkfair-dac-bridge",
          "type": "DAC",
          "usedIn": [{ "id": "zkfair", "name": "ZKFair", "slug": "zkfair" }],
          "createdAt": "1723211933",
          "contracts": {
            "addresses": [
              {
                "name": "ZKFairValidium",
                "address": "0x1CbC08bf0D48b18F9f97796c61352b192d1850A5",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0xb57b9101dEc7dC1635B576fFf71F2f522C970EF3"],
                  "implementations": [
                    "0x668965757127549f8755D2eEd10494B06420213b"
                  ]
                },
                "chain": "ethereum",
                "description": "The main contract of ZKFair. Contains sequenced transaction batch hashes and signature verification logic for the signed data hash commitment."
              },
              {
                "name": "ZKFairValidiumDAC",
                "address": "0x997CfB0838544f68E59f877EDc905001456F125b",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0xb57b9101dEc7dC1635B576fFf71F2f522C970EF3"],
                  "implementations": [
                    "0x63150fA72c1c9fF8Fe4438f8355927D3415b0FDc"
                  ]
                },
                "chain": "ethereum",
                "description": "Validium committee contract that allows the admin to setup the members of the committee and stores the required amount of signatures threshold.",
                "upgradableBy": ["ZKFairAdmin"],
                "upgradeDelay": "None"
              }
            ],
            "risks": []
          },
          "permissions": [
            {
              "name": "Committee Members",
              "description": "List of addresses authorized to sign data commitments for the DA bridge.",
              "accounts": [
                {
                  "address": "0x033A75B6B0fc26eDf60e99c4172eB5f87E733ca2",
                  "type": "EOA"
                },
                {
                  "address": "0x061D273bEf947BD0ef2B828526e710eEa0f297ae",
                  "type": "EOA"
                },
                {
                  "address": "0x9231622437bD57349cC9a15CDEc5383627DEbA17",
                  "type": "EOA"
                },
                {
                  "address": "0x9d8616545C9941138832EebC58Cb498E0ef21a13",
                  "type": "EOA"
                },
                {
                  "address": "0xFe1da7CAd939805d4A889822357c348177a5118d",
                  "type": "EOA"
                }
              ]
            },
            {
              "name": "ZKFairAdmin",
              "description": "This is a Gnosis Safe with 3 / 4 threshold.  Admin of the ZKFairValidiumDAC contract, can set core system parameters like timeouts, sequencer, activate forced transactions, update the DA mode and upgrade the ZKFairValidiumDAC contract",
              "accounts": [
                {
                  "address": "0xcd14BE1959928BB8c160D11817E2BE2129e2F25F",
                  "type": "MultiSig"
                }
              ],
              "chain": "ethereum",
              "references": null,
              "participants": [
                {
                  "address": "0x4Ea1f0f05E7484Ee85a97303DC88c2dF4288df3e",
                  "type": "EOA"
                },
                {
                  "address": "0x44fb52EB2bdDAf1c8b6D441e0b5DCa123A345292",
                  "type": "EOA"
                },
                {
                  "address": "0x689752C198f0cEbe9993ee3E13AF0e565C068c25",
                  "type": "EOA"
                },
                {
                  "address": "0xa57c2B747193fe3F9CC8bea89103B7d76B8A0c70",
                  "type": "EOA"
                }
              ]
            }
          ],
          "chain": 1,
          "requiredMembers": 3,
          "membersCount": 5,
          "transactionDataType": {
            "type": "StateDiffs",
            "value": "State diffs",
            "description": "TODO"
          },
          "display": {
            "name": "ZKFair DAC",
            "slug": "dac",
            "description": "ZKFair DAC on Ethereum.",
            "warning": null,
            "redWarning": null,
            "links": {
              "websites": ["https://zkfair.io/"],
              "apps": ["https://wallet.zkfair.io/"],
              "documentation": ["https://docs.zkfair.io/"],
              "explorers": ["https://scan.zkfair.io/"],
              "repositories": ["https://github.com/ZKFair"],
              "socialMedia": ["https://twitter.com/ZKFCommunity"]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![polygoncdk bridge architecture](/images/da-bridge-technology/polygoncdk/architectureL2.png#center)\n    The DA commitments are posted to the L1 through the sequencer inbox, using the inbox as a DA bridge.\n    The DA commitment consists of a data availability message provided as transaction input, made up of a byte array containing the signatures and all the addresses of the committee in ascending order.\n    The sequencer distributes the data and collects signatures from Committee members offchain. Only the DA message is posted by the sequencer to the L1 chain inbox (the DA bridge).\n    A separate contract, the PolygonCommittee contract, is used to manage the committee members list and verify the signatures before accepting the DA commitment.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "3/5",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "silicon-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": null,
      "hasChallengeMechanism": null,
      "display": {
        "name": "Silicon DAC",
        "slug": "silicon",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://silicon.network/"],
          "apps": ["https://bridge.silicon.network/"],
          "documentation": ["https://docs.silicon.network/"],
          "explorers": ["https://scope.silicon.network"],
          "repositories": [],
          "socialMedia": ["https://x.com/0xSilicon"]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![polygoncdk architecture](/images/da-layer-technology/polygoncdk/architecture3.png#center)\n\n    Polygon CDK validiums utilize a data availability solution that relies on a Data Availability Committee (DAC) to ensure data integrity and manage off-chain transaction data. \n    This architecture comprises the following components:\n    - **Operator**: A trusted entity that collects transactions, computes hash values for the transaction batch, and then requests and collects signatures from Committee members.\n    - **Data Availability Committee (DAC)**: A group of nodes responsible for validating batch data against the hash values provided by the operator (sequencer), ensuring the data accurately represents the transactions.\n    - **PolygonCommittee Contract**: Contract responsible for managing the data committee members list.\n    Each DAC node independently validates the batch data, ensuring it matches the received hash values. \n    Upon successful validation, DAC members store the hash values locally and generate signatures endorsing the batch's integrity. \n    The sequencer collects these signatures and submits the transactions batch hash together with the aggregated signature on Ethereum.\n    The PolygonCommittee contract is used during batch sequencing to verify that the signature posted by the sequencer was signed off by the DAC members stored in the contract.\n    ",
        "risks": null
      },
      "usedIn": [{ "id": "silicon", "name": "Silicon", "slug": "silicon" }],
      "bridges": [
        {
          "id": "silicon-dac-bridge",
          "type": "DAC",
          "usedIn": [{ "id": "silicon", "name": "Silicon", "slug": "silicon" }],
          "createdAt": "1723211933",
          "permissions": [
            {
              "name": "Committee Members",
              "description": "List of addresses authorized to sign data commitments for the DA bridge.",
              "accounts": [
                {
                  "address": "0x07389Ba04a3D39c04BAf605bF9d254B5EB0bC3e0",
                  "type": "EOA"
                },
                {
                  "address": "0x113958b2E9FFDECC74EEDb206A12b5f1168164fb",
                  "type": "EOA"
                },
                {
                  "address": "0x88eb99475d70cCdB891171344c7Ee90688Fa134c",
                  "type": "EOA"
                }
              ]
            },
            {
              "name": "LocalAdmin",
              "accounts": [
                {
                  "address": "0xef5D7af5dbBeE845860E75cE8f8e8fE7F6e8dBF7",
                  "type": "EOA"
                }
              ],
              "description": "Admin and ForceBatcher of the SiliconValidium contract, can set core system parameters like timeouts, sequencer, activate forced transactions, and set the DA committee members in the SiliconDAC contract."
            }
          ],
          "chain": 1,
          "requiredMembers": 2,
          "membersCount": 3,
          "transactionDataType": {
            "type": "TransactionData",
            "value": "Transaction data",
            "description": "TODO"
          },
          "contracts": {
            "addresses": [
              {
                "name": "SiliconValidium",
                "address": "0x419dcD0f72ebAFd3524b65a97ac96699C7fBebdB",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x5132A183E9F3CB7C848b0AAC5Ae0c4f0491B7aB2"],
                  "implementations": [
                    "0x10D296e8aDd0535be71639E5D1d1c30ae1C6bD4C"
                  ]
                },
                "chain": "ethereum",
                "description": "The main contract of Silicon. Contains sequenced transaction batch hashes and signature verification logic for the signed data hash commitment."
              },
              {
                "name": "SiliconDAC",
                "address": "0x24e09Ef4F69B6058E047EE5E709B345F3cA47F3A",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x3F74698A4ADb075c0501DF739745ACA55Ae543a1"],
                  "implementations": [
                    "0xa2F7e6Dfd6f43976ee1E2e8A122984ECa8e38608"
                  ]
                },
                "chain": "ethereum",
                "description": "Validium committee contract that allows the admin to setup the members of the committee and stores the required amount of signatures threshold.",
                "upgradableBy": ["LocalAdmin"],
                "upgradeDelay": "None"
              }
            ],
            "risks": []
          },
          "display": {
            "name": "Silicon DAC",
            "slug": "dac",
            "description": "Silicon DAC on Ethereum.",
            "warning": null,
            "redWarning": null,
            "links": {
              "websites": ["https://silicon.network/"],
              "apps": ["https://bridge.silicon.network/"],
              "documentation": ["https://docs.silicon.network/"],
              "explorers": ["https://scope.silicon.network"],
              "repositories": [],
              "socialMedia": ["https://x.com/0xSilicon"]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![polygoncdk bridge architecture](/images/da-bridge-technology/polygoncdk/architectureL2.png#center)\n    The DA commitments are posted to the L1 through the sequencer inbox, using the inbox as a DA bridge.\n    The DA commitment consists of a data availability message provided as transaction input, made up of a byte array containing the signatures and all the addresses of the committee in ascending order.\n    The sequencer distributes the data and collects signatures from Committee members offchain. Only the DA message is posted by the sequencer to the L1 chain inbox (the DA bridge).\n    A separate contract, the PolygonCommittee contract, is used to manage the committee members list and verify the signatures before accepting the DA commitment.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "2/3",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "rhinofi-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": null,
      "hasChallengeMechanism": null,
      "display": {
        "name": "rhino.fi DAC",
        "slug": "rhinofi",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://rhino.fi/"],
          "apps": ["https://app.rhino.fi/"],
          "documentation": [
            "https://docs.rhino.fi/",
            "https://support.rhino.fi/en/",
            "https://docs.starkware.co/starkex/index.html"
          ],
          "explorers": [],
          "repositories": [
            "https://github.com/starkware-libs/starkex-contracts",
            "https://github.com/rhinofi"
          ],
          "socialMedia": [
            "https://rhino.fi/blog",
            "https://twitter.com/rhinofi",
            "https://linkedin.com/company/rhinofi/",
            "https://youtube.com/c/rhinofi",
            "https://discord.com/invite/26sXx2KAhy"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![starkex architecture](/images/da-layer-technology/starkex/architecture7.png#center)\n\n    The Starkware application utilizes a data availability solution that relies on a Committee Service to ensure data persistence. This architecture comprises the following components:\n\n    - **Availability Gateway**: The primary interface provided by the operator for committee members to access new batch information and submit signed availability claims.\n    - **Data Availability Committee (DAC)**: A group of nodes responsible for storing state data associated with each Merkle root and attesting to data availability by signing claims.\n    - **Data Batches**: Collections of transactions processed in batches that update the state of accounts, resulting in a new Merkle root representing the updated state.\n    \n    Committee members run services that interact with the Availability Gateway to obtain information about new batches and submit their signed availability claims. Each batch includes a unique batch_id, a reference to a previous batch, and a list of account updates. \n    Committee members combine this information with data from the reference batch to compute the new state and verify the Merkle root.\n    \n    When the operator produces a new batch, it must be signed by a minimum number of committee members—as defined by the application's configuration—for it to be accepted onchain. \n    This includes all members designated as mandatory signers. If the operator attempts to submit a batch without the required signatures, it will be rejected, thereby ensuring that data remains available and consistent.\n    \n    Committee members are expected to maintain a database that stores the data associated with each batch, making use of storage solutions with a replication factor of at least 2.\n  \n    ",
        "risks": null
      },
      "usedIn": [{ "id": "deversifi", "name": "rhino.fi", "slug": "rhinofi" }],
      "bridges": [
        {
          "id": "rhinofi-dac-bridge",
          "type": "DAC",
          "usedIn": [
            { "id": "deversifi", "name": "rhino.fi", "slug": "rhinofi" }
          ],
          "createdAt": "1723211933",
          "contracts": {
            "addresses": [
              {
                "name": "Committee",
                "address": "0x28780349A33eEE56bb92241bAAB8095449e24306",
                "upgradeability": null,
                "chain": "ethereum",
                "description": "Data Availability Committee (DAC) contract verifying data availability claim from DAC Members (via multisig check)."
              }
            ],
            "risks": []
          },
          "permissions": [
            {
              "name": "Committee Members",
              "description": "List of addresses authorized to sign data commitments for the DA bridge.",
              "accounts": [
                {
                  "address": "0x6A8EA587133c1aA4b3bA0417b6d8AE38E61fd1E4",
                  "type": "EOA"
                },
                {
                  "address": "0x3Bf2562178eA0CeF6B3F66D971494d65561EFD36",
                  "type": "EOA"
                },
                {
                  "address": "0xf872Cf881873029B8955b582c29b66347f3f1326",
                  "type": "EOA"
                },
                {
                  "address": "0x70EEAA8b7CbF7124e349e94EaDE6188DDd2d6178",
                  "type": "EOA"
                },
                {
                  "address": "0x51AbdE72a4542500a7b1Cb32B18b13fbe1F9ff2E",
                  "type": "EOA"
                },
                {
                  "address": "0x2b6593FcFbfdeD663D7a6448d45b12C16DF6B648",
                  "type": "EOA"
                },
                {
                  "address": "0xFBD7599fe0C3735b94c369aDF0F0045D8D4f6cB9",
                  "type": "EOA"
                }
              ]
            }
          ],
          "chain": 1,
          "requiredMembers": 4,
          "membersCount": 7,
          "transactionDataType": {
            "type": "StateDiffs",
            "value": "State diffs",
            "description": "TODO"
          },
          "display": {
            "name": "rhino.fi DAC",
            "slug": "dac",
            "description": "rhino.fi DAC on Ethereum.",
            "warning": null,
            "redWarning": null,
            "links": {
              "websites": ["https://rhino.fi/"],
              "apps": ["https://app.rhino.fi/"],
              "documentation": [
                "https://docs.rhino.fi/",
                "https://support.rhino.fi/en/",
                "https://docs.starkware.co/starkex/index.html"
              ],
              "explorers": [],
              "repositories": [
                "https://github.com/starkware-libs/starkex-contracts",
                "https://github.com/rhinofi"
              ],
              "socialMedia": [
                "https://rhino.fi/blog",
                "https://twitter.com/rhinofi",
                "https://linkedin.com/company/rhinofi/",
                "https://youtube.com/c/rhinofi",
                "https://discord.com/invite/26sXx2KAhy"
              ]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![starkex bridge architecture](/images/da-bridge-technology/starkex/architectureL2.png#center)\n      The DA commitments are posted to the L1 chain, using the Committee Verifier contract as a DA bridge.\n      The DA commitment consists of a data hash of the transaction batch the Committee has signed off on and a concatenation of ec-signatures by signatories.\n      The Committee Verifier contract verifies the signatures and the data hash and if the required threshold of Committee members has signed off on the data, the hash is stored as a registeredFact in the StarkEx contract.\n      In a separate transaction, the operator calls the updateState() function on the StarkEx contract to update the state.\n      Before the state update is accepted, the StarkEx contract verifies the transaction public inputs by calling the isValid() function, which verifies the hash derived from state update inputs matches the hash stored by the Committee Verifier contract.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "4/7",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "sxnetwork-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": "Ethereum (blobs)",
      "hasChallengeMechanism": null,
      "display": {
        "name": "SX Network DAC",
        "slug": "sxnetwork",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://sx.technology/"],
          "apps": [
            "https://sx.bet/wallet/bridge",
            "https://bridge.gelato.network/bridge/sx-rollup"
          ],
          "documentation": ["https://docs.sx.technology/"],
          "explorers": ["https://explorerl2.sx.technology/"],
          "repositories": [],
          "socialMedia": [
            "https://x.com/SX_Network",
            "https://discord.com/invite/sxnetwork"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![Anytrust architecture](/images/da-layer-technology/anytrust/architecture2.png#center)\n\n    The DAC uses a data availability solution built on the AnyTrust protocol. It is composed of the following components:\n    - **Sequencer Inbox**: Main entry point for the Sequencer submitting transaction batches.\n    - **Data Availability Committee (DAC)**: A group of members responsible for storing and providing data on demand.\n    - **Data Availability Certificate (DACert)**: A commitment ensuring that data blobs are available without needing full data posting on the L1 chain. \n\n    \n    Committee members run servers that support APIs for storing and retrieving data blobs. \n    The Sequencer API allows the rollup Sequencer to submit data blobs for storage, while the REST API enables anyone to fetch data by hash. \n    When the Sequencer produces a data batch, it sends the batch along with an expiration time to Committee members, who store it and sign it. \n    Once enough signatures are collected, the Sequencer aggregates them into a valid DACert and posts it to the L1 chain inbox. \n    If the Sequencer fails to collect enough signatures, it falls back to posting the full data to the L1 chain. \n\n\n    A DACert includes a hash of the data block, an expiration time, and proof that the required threshold of Committee members have signed off on the data. \n    The proof consists of a hash of the Keyset used in signing, a bitmap indicating which members signed, and a BLS aggregated signature. \n    L2 nodes reading from the sequencer inbox verify the certificate’s validity by checking the number of signers, the aggregated signature, and that the expiration time is at least two weeks ahead of the L2 timestamp. \n    If the DACert is valid, it provides a proof that the corresponding data is available from honest committee members.\n\n    ",
        "risks": null
      },
      "usedIn": [
        { "id": "sxnetwork", "name": "SX Network", "slug": "sxnetwork" }
      ],
      "bridges": [
        {
          "id": "sxnetwork-dac-bridge",
          "type": "DAC",
          "usedIn": [
            { "id": "sxnetwork", "name": "SX Network", "slug": "sxnetwork" }
          ],
          "createdAt": "1723211933",
          "contracts": {
            "addresses": [
              {
                "name": "SequencerInbox",
                "address": "0xD80a805c86C14c879420eC6acb366D04D318fC0C",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0xe8606A55d105EF857F187C32Ae0E9a168aF8F497"],
                  "implementations": [
                    "0x383f16fB2809a56fC639c1eE2c93Ad2aa7Ee130A"
                  ]
                },
                "chain": "ethereum",
                "description": "Main entry point for the Sequencer submitting transaction batches."
              }
            ],
            "risks": []
          },
          "permissions": [
            {
              "name": "Sequencers",
              "accounts": [
                {
                  "address": "0x90906eA9eb38B6afC104bB761F493b2a78c85024",
                  "type": "EOA"
                }
              ],
              "description": "Central actors allowed to submit transaction batches to the Sequencer Inbox.",
              "chain": "ethereum"
            },
            {
              "name": "RollupOwner",
              "accounts": [
                {
                  "address": "0xa9d1C9D877F235C21d803e4a0b81F8ca6C4c83AC",
                  "type": "EOA"
                }
              ],
              "description": "Multisig that can upgrade authorized batch posters via the UpgradeExecutor contract."
            }
          ],
          "chain": 1,
          "requiredMembers": 1,
          "membersCount": 2,
          "transactionDataType": {
            "type": "TransactionDataCompressed",
            "value": "Transaction data (compressed)",
            "description": "TODO"
          },
          "display": {
            "name": "SX Network DAC",
            "slug": "dac",
            "description": "SX Network DAC on Ethereum.",
            "warning": null,
            "redWarning": "Only one signer is required to attest to the availability of the data.",
            "links": {
              "websites": ["https://sx.technology/"],
              "apps": [
                "https://sx.bet/wallet/bridge",
                "https://bridge.gelato.network/bridge/sx-rollup"
              ],
              "documentation": ["https://docs.sx.technology/"],
              "explorers": ["https://explorerl2.sx.technology/"],
              "repositories": [],
              "socialMedia": [
                "https://x.com/SX_Network",
                "https://discord.com/invite/sxnetwork"
              ]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![Anytrust bridge architecture](/images/da-bridge-technology/anytrust/architectureL2.png#center)\n\n\n    The DA commitments are posted to the L1 through the sequencer inbox, using the inbox as a DA bridge.\n    The DA commitment consists of Data Availability Certificate (DACert), including a hash of the data block, an expiration time, and a proof that the required threshold of Committee members have signed off on the data.\n    The sequencer distributes the data and collects signatures from Committee members offchain. Only the DACert is posted by the sequencer to the L1 chain inbox (the DA bridge), achieving L2 transaction ordering finality in a single onchain transaction.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "1/2",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "winr-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": "Ethereum (blobs)",
      "hasChallengeMechanism": null,
      "display": {
        "name": "WINR DAC",
        "slug": "winr",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://winr.games/"],
          "apps": ["https://just.bet/"],
          "documentation": ["https://docs.winr.games/"],
          "explorers": ["https://explorer.winr.games/"],
          "repositories": [],
          "socialMedia": ["https://x.com/WINRProtocol"]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![Anytrust architecture](/images/da-layer-technology/anytrust/architecture1.png#center)\n\n    The DAC uses a data availability solution built on the AnyTrust protocol. It is composed of the following components:\n    - **Sequencer Inbox**: Main entry point for the Sequencer submitting transaction batches.\n    - **Data Availability Committee (DAC)**: A group of members responsible for storing and providing data on demand.\n    - **Data Availability Certificate (DACert)**: A commitment ensuring that data blobs are available without needing full data posting on the L1 chain. \n\n    \n    Committee members run servers that support APIs for storing and retrieving data blobs. \n    The Sequencer API allows the rollup Sequencer to submit data blobs for storage, while the REST API enables anyone to fetch data by hash. \n    When the Sequencer produces a data batch, it sends the batch along with an expiration time to Committee members, who store it and sign it. \n    Once enough signatures are collected, the Sequencer aggregates them into a valid DACert and posts it to the L1 chain inbox. \n    If the Sequencer fails to collect enough signatures, it falls back to posting the full data to the L1 chain. \n\n\n    A DACert includes a hash of the data block, an expiration time, and proof that the required threshold of Committee members have signed off on the data. \n    The proof consists of a hash of the Keyset used in signing, a bitmap indicating which members signed, and a BLS aggregated signature. \n    L2 nodes reading from the sequencer inbox verify the certificate’s validity by checking the number of signers, the aggregated signature, and that the expiration time is at least two weeks ahead of the L2 timestamp. \n    If the DACert is valid, it provides a proof that the corresponding data is available from honest committee members.\n\n    ",
        "risks": null
      },
      "usedIn": [{ "id": "winr", "name": "WINR", "slug": "winr" }],
      "bridges": [
        {
          "id": "winr-dac-bridge",
          "type": "DAC",
          "usedIn": [{ "id": "winr", "name": "WINR", "slug": "winr" }],
          "createdAt": "1723211933",
          "contracts": {
            "addresses": [
              {
                "name": "SequencerInbox",
                "address": "0x8AeDdE55Cb361e73a0B0c0cF2A5bB35E97a20456",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x802c7B6585d20cb69524EF23fCbF919F671F808a"],
                  "implementations": [
                    "0x7a299aD29499736994Aa3a9aFa3f476445FAEB2c"
                  ]
                },
                "chain": "arbitrum",
                "description": "Main entry point for the Sequencer submitting transaction batches."
              }
            ],
            "risks": []
          },
          "permissions": [
            {
              "name": "Sequencers",
              "accounts": [
                {
                  "address": "0x1A48A9e82dDb9cd157a67493Cc5E246D0cDd8307",
                  "type": "EOA"
                }
              ],
              "description": "Central actors allowed to submit transaction batches to the Sequencer Inbox.",
              "chain": "arbitrum"
            },
            {
              "name": "RollupOwner",
              "accounts": [
                {
                  "address": "0x79C2abE3eBA9dc119318FdAaA48118e1CDB53F56",
                  "type": "MultiSig"
                }
              ],
              "description": "Multisig that can upgrade authorized batch posters via the UpgradeExecutor contract."
            }
          ],
          "chain": 42161,
          "requiredMembers": 1,
          "membersCount": 1,
          "transactionDataType": {
            "type": "TransactionDataCompressed",
            "value": "Transaction data (compressed)",
            "description": "TODO"
          },
          "display": {
            "name": "WINR DAC",
            "slug": "dac",
            "description": "WINR DAC on Ethereum.",
            "warning": null,
            "redWarning": "Only one signer is required to attest to the availability of the data.",
            "links": {
              "websites": ["https://winr.games/"],
              "apps": ["https://just.bet/"],
              "documentation": ["https://docs.winr.games/"],
              "explorers": ["https://explorer.winr.games/"],
              "repositories": [],
              "socialMedia": ["https://x.com/WINRProtocol"]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![Anytrust bridge architecture](/images/da-bridge-technology/anytrust/architectureL3.png#center)\n\n\n    The DA commitments are posted to the L2 through the sequencer inbox, using the inbox as a DA bridge.\n    The DA commitment consists of Data Availability Certificate (DACert), including a hash of the data block, an expiration time, and a proof that the required threshold of Committee members have signed off on the data.\n    The sequencer distributes the data and collects signatures from Committee members offchain. Only the DACert is posted by the sequencer to the L2 chain inbox (the DA bridge), achieving L3 transaction ordering finality in a single onchain transaction.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "1/1",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "astarzkevm-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": null,
      "hasChallengeMechanism": null,
      "display": {
        "name": "Astar zkEVM DAC",
        "slug": "astarzkevm",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://astar.network/blog/astar-evolution-phase-1-56"],
          "apps": [],
          "documentation": ["https://docs.astar.network/docs/build/zkEVM/"],
          "explorers": ["https://astar-zkevm.explorer.startale.com/"],
          "repositories": ["https://github.com/AstarNetwork"],
          "socialMedia": [
            "https://twitter.com/AstarNetwork",
            "https://discord.com/invite/astarnetwork",
            "https://youtube.com/@AstarNetwork",
            "https://t.me/PlasmOfficial"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![polygoncdk architecture](/images/da-layer-technology/polygoncdk/architecture5.png#center)\n\n    Polygon CDK validiums utilize a data availability solution that relies on a Data Availability Committee (DAC) to ensure data integrity and manage off-chain transaction data. \n    This architecture comprises the following components:\n    - **Operator**: A trusted entity that collects transactions, computes hash values for the transaction batch, and then requests and collects signatures from Committee members.\n    - **Data Availability Committee (DAC)**: A group of nodes responsible for validating batch data against the hash values provided by the operator (sequencer), ensuring the data accurately represents the transactions.\n    - **PolygonCommittee Contract**: Contract responsible for managing the data committee members list.\n    Each DAC node independently validates the batch data, ensuring it matches the received hash values. \n    Upon successful validation, DAC members store the hash values locally and generate signatures endorsing the batch's integrity. \n    The sequencer collects these signatures and submits the transactions batch hash together with the aggregated signature on Ethereum.\n    The PolygonCommittee contract is used during batch sequencing to verify that the signature posted by the sequencer was signed off by the DAC members stored in the contract.\n    ",
        "risks": null
      },
      "usedIn": [
        { "id": "astarzkevm", "name": "Astar zkEVM", "slug": "astarzkevm" }
      ],
      "bridges": [
        {
          "id": "astarzkevm-dac-bridge",
          "type": "DAC",
          "usedIn": [
            { "id": "astarzkevm", "name": "Astar zkEVM", "slug": "astarzkevm" }
          ],
          "createdAt": "1723211933",
          "permissions": [
            {
              "name": "Committee Members",
              "description": "List of addresses authorized to sign data commitments for the DA bridge.",
              "accounts": [
                {
                  "address": "0x19DdD9d655B993D6B2e2437bfBA0378B777d7470",
                  "type": "EOA"
                },
                {
                  "address": "0x361Ed4c21Ad3f9B28eeE1e1894854cE7E39b2dB1",
                  "type": "EOA"
                },
                {
                  "address": "0x68B62E4C9E69cd637c61f19Fb64976D466De1d58",
                  "type": "EOA"
                },
                {
                  "address": "0xB4d094b4216F1BEb8bAeD995092A05182fD4bEf0",
                  "type": "EOA"
                },
                {
                  "address": "0xC4ad70e848f36925FcbDfb252f5e258D06647320",
                  "type": "EOA"
                }
              ]
            },
            {
              "name": "LocalAdmin",
              "description": "This is a Gnosis Safe with 3 / 6 threshold.  Admin of the AstarValidiumDAC contract, can set core system parameters like timeouts, sequencer, activate forced transactions, update the DA mode and upgrade the AstarValidiumDAC contract",
              "accounts": [
                {
                  "address": "0xf98ee8c46baEa2B11e4f0450AD9D01861265F76E",
                  "type": "MultiSig"
                }
              ],
              "chain": "ethereum",
              "references": null,
              "participants": [
                {
                  "address": "0xe4D4fBC6e27B3AE9D881BD9400071FB6c62E4dfa",
                  "type": "EOA"
                },
                {
                  "address": "0xEc24369A1269171e3cb0A323DD920F99Cb528Fb0",
                  "type": "EOA"
                },
                {
                  "address": "0x127Bae6Fc751dC92111a359500ae91EB437f3dCb",
                  "type": "EOA"
                },
                {
                  "address": "0x83cC8195856b0463dEd5f052021009b7985FDa2C",
                  "type": "EOA"
                },
                {
                  "address": "0x4324c3960c7B2567D0C13ba17493bb364c407937",
                  "type": "EOA"
                },
                {
                  "address": "0x6c4876Ecb5de33f76700f44d547C593065806dAC",
                  "type": "MultiSig"
                }
              ]
            }
          ],
          "chain": 1,
          "requiredMembers": 3,
          "membersCount": 5,
          "transactionDataType": {
            "type": "TransactionData",
            "value": "Transaction data",
            "description": "TODO"
          },
          "contracts": {
            "addresses": [
              {
                "name": "AstarValidium",
                "address": "0x1E163594e13030244DCAf4cDfC2cd0ba3206DA80",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x5132A183E9F3CB7C848b0AAC5Ae0c4f0491B7aB2"],
                  "implementations": [
                    "0x10D296e8aDd0535be71639E5D1d1c30ae1C6bD4C"
                  ]
                },
                "chain": "ethereum",
                "description": "The main contract of the Astar zkEVM. Contains sequenced transaction batch hashes and signature verification logic for the signed data hash commitment."
              },
              {
                "name": "AstarValidiumDAC",
                "address": "0x9CCD205052c732Ac1Df2cf7bf8aACC0E371eE0B0",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x1963D7b78e75A5eDfF9e5376E7A07A935Fb3d50d"],
                  "implementations": [
                    "0xF4e87685e323818E0aE35dCdFc3B65106002E456"
                  ]
                },
                "chain": "ethereum",
                "description": "Validium committee contract that allows the admin to setup the members of the committee and stores the required amount of signatures threshold.",
                "upgradableBy": ["LocalAdmin"],
                "upgradeDelay": "None"
              }
            ],
            "risks": []
          },
          "display": {
            "name": "Astar zkEVM DAC",
            "slug": "dac",
            "description": "Astar zkEVM DAC on Ethereum.",
            "warning": null,
            "redWarning": null,
            "links": {
              "websites": [
                "https://astar.network/blog/astar-evolution-phase-1-56"
              ],
              "apps": [],
              "documentation": ["https://docs.astar.network/docs/build/zkEVM/"],
              "explorers": ["https://astar-zkevm.explorer.startale.com/"],
              "repositories": ["https://github.com/AstarNetwork"],
              "socialMedia": [
                "https://twitter.com/AstarNetwork",
                "https://discord.com/invite/astarnetwork",
                "https://youtube.com/@AstarNetwork",
                "https://t.me/PlasmOfficial"
              ]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![polygoncdk bridge architecture](/images/da-bridge-technology/polygoncdk/architectureL2.png#center)\n    The DA commitments are posted to the L1 through the sequencer inbox, using the inbox as a DA bridge.\n    The DA commitment consists of a data availability message provided as transaction input, made up of a byte array containing the signatures and all the addresses of the committee in ascending order.\n    The sequencer distributes the data and collects signatures from Committee members offchain. Only the DA message is posted by the sequencer to the L1 chain inbox (the DA bridge).\n    A separate contract, the PolygonCommittee contract, is used to manage the committee members list and verify the signatures before accepting the DA commitment.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "3/5",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "tanx-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": null,
      "hasChallengeMechanism": null,
      "display": {
        "name": "tanX DAC",
        "slug": "tanx",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://tanx.fi/"],
          "apps": ["https://trade.tanx.fi/"],
          "documentation": ["https://docs.tanx.fi/"],
          "explorers": [],
          "repositories": [],
          "socialMedia": [
            "https://twitter.com/tanXfinance",
            "https://discord.gg/wMAnf3gVTh",
            "https://youtube.com/channel/UCUG2L75yvKJBK9QFUaXTdyA",
            "https://linkedin.com/company/tanx-fi"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![starkex architecture](/images/da-layer-technology/starkex/architecture4.png#center)\n\n    The Starkware application utilizes a data availability solution that relies on a Committee Service to ensure data persistence. This architecture comprises the following components:\n\n    - **Availability Gateway**: The primary interface provided by the operator for committee members to access new batch information and submit signed availability claims.\n    - **Data Availability Committee (DAC)**: A group of nodes responsible for storing state data associated with each Merkle root and attesting to data availability by signing claims.\n    - **Data Batches**: Collections of transactions processed in batches that update the state of accounts, resulting in a new Merkle root representing the updated state.\n    \n    Committee members run services that interact with the Availability Gateway to obtain information about new batches and submit their signed availability claims. Each batch includes a unique batch_id, a reference to a previous batch, and a list of account updates. \n    Committee members combine this information with data from the reference batch to compute the new state and verify the Merkle root.\n    \n    When the operator produces a new batch, it must be signed by a minimum number of committee members—as defined by the application's configuration—for it to be accepted onchain. \n    This includes all members designated as mandatory signers. If the operator attempts to submit a batch without the required signatures, it will be rejected, thereby ensuring that data remains available and consistent.\n    \n    Committee members are expected to maintain a database that stores the data associated with each batch, making use of storage solutions with a replication factor of at least 2.\n  \n    ",
        "risks": null
      },
      "usedIn": [{ "id": "brine", "name": "tanX", "slug": "tanx" }],
      "bridges": [
        {
          "id": "tanx-dac-bridge",
          "type": "DAC",
          "usedIn": [{ "id": "brine", "name": "tanX", "slug": "tanx" }],
          "createdAt": "1723211933",
          "contracts": {
            "addresses": [
              {
                "name": "Committee",
                "address": "0x4F8B2dd49D958b6ac3e5f4705Bf1a9aDA5Bc4446",
                "upgradeability": null,
                "chain": "ethereum",
                "description": "Data Availability Committee (DAC) contract verifying data availability claim from DAC Members (via multisig check)."
              }
            ],
            "risks": []
          },
          "permissions": [
            {
              "name": "Committee Members",
              "description": "List of addresses authorized to sign data commitments for the DA bridge.",
              "accounts": [
                {
                  "address": "0x502FffBcdcaA61f19deFBb9b60e799F74FB48Bc1",
                  "type": "EOA"
                },
                {
                  "address": "0xC37a598468A59D5d6DCeb889847B5824aD61697e",
                  "type": "EOA"
                },
                {
                  "address": "0xfceC0b967e4390Eb7Cd4f2318c247eD193fE78E9",
                  "type": "EOA"
                },
                {
                  "address": "0xFE4913D959064ee0b026ba0cE3Faccc1c5834a00",
                  "type": "EOA"
                }
              ]
            }
          ],
          "chain": 1,
          "requiredMembers": 2,
          "membersCount": 4,
          "transactionDataType": {
            "type": "StateDiffs",
            "value": "State diffs",
            "description": "TODO"
          },
          "display": {
            "name": "tanX DAC",
            "slug": "dac",
            "description": "tanX DAC on Ethereum.",
            "warning": null,
            "redWarning": null,
            "links": {
              "websites": ["https://tanx.fi/"],
              "apps": ["https://trade.tanx.fi/"],
              "documentation": ["https://docs.tanx.fi/"],
              "explorers": [],
              "repositories": [],
              "socialMedia": [
                "https://twitter.com/tanXfinance",
                "https://discord.gg/wMAnf3gVTh",
                "https://youtube.com/channel/UCUG2L75yvKJBK9QFUaXTdyA",
                "https://linkedin.com/company/tanx-fi"
              ]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![starkex bridge architecture](/images/da-bridge-technology/starkex/architectureL2.png#center)\n      The DA commitments are posted to the L1 chain, using the Committee Verifier contract as a DA bridge.\n      The DA commitment consists of a data hash of the transaction batch the Committee has signed off on and a concatenation of ec-signatures by signatories.\n      The Committee Verifier contract verifies the signatures and the data hash and if the required threshold of Committee members has signed off on the data, the hash is stored as a registeredFact in the StarkEx contract.\n      In a separate transaction, the operator calls the updateState() function on the StarkEx contract to update the state.\n      Before the state update is accepted, the StarkEx contract verifies the transaction public inputs by calling the isValid() function, which verifies the hash derived from state update inputs matches the hash stored by the Committee Verifier contract.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "2/4",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "hychain-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": "Ethereum (blobs)",
      "hasChallengeMechanism": null,
      "display": {
        "name": "HYCHAIN DAC",
        "slug": "hychain",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://hychain.com"],
          "apps": ["https://bridge.hychain.com"],
          "documentation": ["https://docs.hychain.com"],
          "explorers": ["https://explorer.hychain.com"],
          "repositories": ["https://github.com/kintoxyz"],
          "socialMedia": [
            "https://x.com/HYCHAIN_GAMES",
            "https://discord.gg/hytopiagg",
            "https://hychain.substack.com/"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![Anytrust architecture](/images/da-layer-technology/anytrust/architecture1.png#center)\n\n    The DAC uses a data availability solution built on the AnyTrust protocol. It is composed of the following components:\n    - **Sequencer Inbox**: Main entry point for the Sequencer submitting transaction batches.\n    - **Data Availability Committee (DAC)**: A group of members responsible for storing and providing data on demand.\n    - **Data Availability Certificate (DACert)**: A commitment ensuring that data blobs are available without needing full data posting on the L1 chain. \n\n    \n    Committee members run servers that support APIs for storing and retrieving data blobs. \n    The Sequencer API allows the rollup Sequencer to submit data blobs for storage, while the REST API enables anyone to fetch data by hash. \n    When the Sequencer produces a data batch, it sends the batch along with an expiration time to Committee members, who store it and sign it. \n    Once enough signatures are collected, the Sequencer aggregates them into a valid DACert and posts it to the L1 chain inbox. \n    If the Sequencer fails to collect enough signatures, it falls back to posting the full data to the L1 chain. \n\n\n    A DACert includes a hash of the data block, an expiration time, and proof that the required threshold of Committee members have signed off on the data. \n    The proof consists of a hash of the Keyset used in signing, a bitmap indicating which members signed, and a BLS aggregated signature. \n    L2 nodes reading from the sequencer inbox verify the certificate’s validity by checking the number of signers, the aggregated signature, and that the expiration time is at least two weeks ahead of the L2 timestamp. \n    If the DACert is valid, it provides a proof that the corresponding data is available from honest committee members.\n\n    ",
        "risks": null
      },
      "usedIn": [{ "id": "hychain", "name": "HYCHAIN", "slug": "hychain" }],
      "bridges": [
        {
          "id": "hychain-dac-bridge",
          "type": "DAC",
          "usedIn": [{ "id": "hychain", "name": "HYCHAIN", "slug": "hychain" }],
          "createdAt": "1723211933",
          "contracts": {
            "addresses": [
              {
                "name": "SequencerInbox",
                "address": "0xaF5800ADF22301968613c37DA9C3C2a486eA915A",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x4C5984E3841790335E6DC2e7ed92802FbF8a300F"],
                  "implementations": [
                    "0x873484Ba63353C8b71210ce123B465512d408B27"
                  ]
                },
                "chain": "ethereum",
                "description": "Main entry point for the Sequencer submitting transaction batches."
              }
            ],
            "risks": []
          },
          "permissions": [
            {
              "name": "Sequencers",
              "accounts": [
                {
                  "address": "0xC1d59449a546bA80d332De629724df8e9A9e9584",
                  "type": "EOA"
                }
              ],
              "description": "Central actors allowed to submit transaction batches to the Sequencer Inbox.",
              "chain": "ethereum"
            },
            {
              "name": "RollupOwner",
              "accounts": [
                {
                  "address": "0x798Fa726f0B4DF564681446D051b344E3FE4a6ca",
                  "type": "MultiSig"
                }
              ],
              "description": "Multisig that can upgrade authorized batch posters via the UpgradeExecutor contract."
            }
          ],
          "chain": 1,
          "requiredMembers": 1,
          "membersCount": 1,
          "transactionDataType": {
            "type": "TransactionDataCompressed",
            "value": "Transaction data (compressed)",
            "description": "TODO"
          },
          "display": {
            "name": "HYCHAIN DAC",
            "slug": "dac",
            "description": "HYCHAIN DAC on Ethereum.",
            "warning": null,
            "redWarning": "Only one signer is required to attest to the availability of the data.",
            "links": {
              "websites": ["https://hychain.com"],
              "apps": ["https://bridge.hychain.com"],
              "documentation": ["https://docs.hychain.com"],
              "explorers": ["https://explorer.hychain.com"],
              "repositories": ["https://github.com/kintoxyz"],
              "socialMedia": [
                "https://x.com/HYCHAIN_GAMES",
                "https://discord.gg/hytopiagg",
                "https://hychain.substack.com/"
              ]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![Anytrust bridge architecture](/images/da-bridge-technology/anytrust/architectureL2.png#center)\n\n\n    The DA commitments are posted to the L1 through the sequencer inbox, using the inbox as a DA bridge.\n    The DA commitment consists of Data Availability Certificate (DACert), including a hash of the data block, an expiration time, and a proof that the required threshold of Committee members have signed off on the data.\n    The sequencer distributes the data and collects signatures from Committee members offchain. Only the DACert is posted by the sequencer to the L1 chain inbox (the DA bridge), achieving L2 transaction ordering finality in a single onchain transaction.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "1/1",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "xchain-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": "Ethereum (blobs)",
      "hasChallengeMechanism": null,
      "display": {
        "name": "XCHAIN DAC",
        "slug": "xchain",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://idex.io/"],
          "apps": ["https://exchange.idex.io/"],
          "documentation": ["https://docs.idex.io/"],
          "explorers": ["https://xchain-explorer.idex.io/"],
          "repositories": [],
          "socialMedia": [
            "https://x.com/idexio",
            "https://discord.com/invite/idex",
            "https://t.me/IDEXChat"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![Anytrust architecture](/images/da-layer-technology/anytrust/architecture1.png#center)\n\n    The DAC uses a data availability solution built on the AnyTrust protocol. It is composed of the following components:\n    - **Sequencer Inbox**: Main entry point for the Sequencer submitting transaction batches.\n    - **Data Availability Committee (DAC)**: A group of members responsible for storing and providing data on demand.\n    - **Data Availability Certificate (DACert)**: A commitment ensuring that data blobs are available without needing full data posting on the L1 chain. \n\n    \n    Committee members run servers that support APIs for storing and retrieving data blobs. \n    The Sequencer API allows the rollup Sequencer to submit data blobs for storage, while the REST API enables anyone to fetch data by hash. \n    When the Sequencer produces a data batch, it sends the batch along with an expiration time to Committee members, who store it and sign it. \n    Once enough signatures are collected, the Sequencer aggregates them into a valid DACert and posts it to the L1 chain inbox. \n    If the Sequencer fails to collect enough signatures, it falls back to posting the full data to the L1 chain. \n\n\n    A DACert includes a hash of the data block, an expiration time, and proof that the required threshold of Committee members have signed off on the data. \n    The proof consists of a hash of the Keyset used in signing, a bitmap indicating which members signed, and a BLS aggregated signature. \n    L2 nodes reading from the sequencer inbox verify the certificate’s validity by checking the number of signers, the aggregated signature, and that the expiration time is at least two weeks ahead of the L2 timestamp. \n    If the DACert is valid, it provides a proof that the corresponding data is available from honest committee members.\n\n    ",
        "risks": null
      },
      "usedIn": [{ "id": "xchain", "name": "XCHAIN", "slug": "xchain" }],
      "bridges": [
        {
          "id": "xchain-dac-bridge",
          "type": "DAC",
          "usedIn": [{ "id": "xchain", "name": "XCHAIN", "slug": "xchain" }],
          "createdAt": "1723211933",
          "contracts": {
            "addresses": [
              {
                "name": "SequencerInbox",
                "address": "0x47861E0419BE83d0175818a09221B6DF2EFD7793",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x22010F5C4c106dfBaffec780196d2F691860Ff62"],
                  "implementations": [
                    "0x383f16fB2809a56fC639c1eE2c93Ad2aa7Ee130A"
                  ]
                },
                "chain": "ethereum",
                "description": "Main entry point for the Sequencer submitting transaction batches."
              }
            ],
            "risks": []
          },
          "permissions": [
            {
              "name": "Sequencers",
              "accounts": [
                {
                  "address": "0x74978411BbBCbC466e79fb855DAe981997100deB",
                  "type": "EOA"
                }
              ],
              "description": "Central actors allowed to submit transaction batches to the Sequencer Inbox.",
              "chain": "ethereum"
            },
            {
              "name": "RollupOwner",
              "accounts": [
                {
                  "address": "0x4a4962275DF8C60a80d3a25faEc5AA7De116A746",
                  "type": "MultiSig"
                }
              ],
              "description": "Multisig that can upgrade authorized batch posters via the UpgradeExecutor contract."
            }
          ],
          "chain": 1,
          "requiredMembers": 1,
          "membersCount": 1,
          "transactionDataType": {
            "type": "TransactionDataCompressed",
            "value": "Transaction data (compressed)",
            "description": "TODO"
          },
          "display": {
            "name": "XCHAIN DAC",
            "slug": "dac",
            "description": "XCHAIN DAC on Ethereum.",
            "warning": null,
            "redWarning": "Only one signer is required to attest to the availability of the data.",
            "links": {
              "websites": ["https://idex.io/"],
              "apps": ["https://exchange.idex.io/"],
              "documentation": ["https://docs.idex.io/"],
              "explorers": ["https://xchain-explorer.idex.io/"],
              "repositories": [],
              "socialMedia": [
                "https://x.com/idexio",
                "https://discord.com/invite/idex",
                "https://t.me/IDEXChat"
              ]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![Anytrust bridge architecture](/images/da-bridge-technology/anytrust/architectureL2.png#center)\n\n\n    The DA commitments are posted to the L1 through the sequencer inbox, using the inbox as a DA bridge.\n    The DA commitment consists of Data Availability Certificate (DACert), including a hash of the data block, an expiration time, and a proof that the required threshold of Committee members have signed off on the data.\n    The sequencer distributes the data and collects signatures from Committee members offchain. Only the DACert is posted by the sequencer to the L1 chain inbox (the DA bridge), achieving L2 transaction ordering finality in a single onchain transaction.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "1/1",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "alienx-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": "Ethereum (blobs)",
      "hasChallengeMechanism": null,
      "display": {
        "name": "AlienX DAC",
        "slug": "alienx",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://alienxchain.io/"],
          "apps": ["https://bridge.alienxchain.io/", "https://alienswap.xyz/"],
          "documentation": ["https://docs.alienxchain.io"],
          "explorers": ["https://explorer.alienxchain.io"],
          "repositories": [],
          "socialMedia": [
            "https://x.com/ALIENXchain",
            "https://discord.gg/alienxchain",
            "https://medium.com/@ALIENXchain",
            "https://t.me/alienx_ainode"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![Anytrust architecture](/images/da-layer-technology/anytrust/architecture1.png#center)\n\n    The DAC uses a data availability solution built on the AnyTrust protocol. It is composed of the following components:\n    - **Sequencer Inbox**: Main entry point for the Sequencer submitting transaction batches.\n    - **Data Availability Committee (DAC)**: A group of members responsible for storing and providing data on demand.\n    - **Data Availability Certificate (DACert)**: A commitment ensuring that data blobs are available without needing full data posting on the L1 chain. \n\n    \n    Committee members run servers that support APIs for storing and retrieving data blobs. \n    The Sequencer API allows the rollup Sequencer to submit data blobs for storage, while the REST API enables anyone to fetch data by hash. \n    When the Sequencer produces a data batch, it sends the batch along with an expiration time to Committee members, who store it and sign it. \n    Once enough signatures are collected, the Sequencer aggregates them into a valid DACert and posts it to the L1 chain inbox. \n    If the Sequencer fails to collect enough signatures, it falls back to posting the full data to the L1 chain. \n\n\n    A DACert includes a hash of the data block, an expiration time, and proof that the required threshold of Committee members have signed off on the data. \n    The proof consists of a hash of the Keyset used in signing, a bitmap indicating which members signed, and a BLS aggregated signature. \n    L2 nodes reading from the sequencer inbox verify the certificate’s validity by checking the number of signers, the aggregated signature, and that the expiration time is at least two weeks ahead of the L2 timestamp. \n    If the DACert is valid, it provides a proof that the corresponding data is available from honest committee members.\n\n    ",
        "risks": null
      },
      "usedIn": [{ "id": "alienx", "name": "AlienX", "slug": "alienx" }],
      "bridges": [
        {
          "id": "alienx-dac-bridge",
          "type": "DAC",
          "usedIn": [{ "id": "alienx", "name": "AlienX", "slug": "alienx" }],
          "createdAt": "1723211933",
          "contracts": {
            "addresses": [
              {
                "name": "SequencerInbox",
                "address": "0xb7d188eb30e7984f93Bec34Ee8b45A148bd594C6",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x123C1E324BC742295B4278B41C4E33831C77655C"],
                  "implementations": [
                    "0x958985cf2c54f99ba4a599221A8090C1F9Cee9A5"
                  ]
                },
                "chain": "ethereum",
                "description": "Main entry point for the Sequencer submitting transaction batches."
              }
            ],
            "risks": []
          },
          "permissions": [
            {
              "name": "Sequencers",
              "accounts": [
                {
                  "address": "0xff309E0c74874a3efeAAff630A818fd9c6DE4f25",
                  "type": "EOA"
                }
              ],
              "description": "Central actors allowed to submit transaction batches to the Sequencer Inbox.",
              "chain": "ethereum"
            },
            {
              "name": "RollupOwner",
              "accounts": [
                {
                  "address": "0x32f6CAE58A89aA7c91D736Bb1100E377C570bb27",
                  "type": "MultiSig"
                }
              ],
              "description": "Multisig that can upgrade authorized batch posters via the UpgradeExecutor contract."
            }
          ],
          "chain": 1,
          "requiredMembers": 1,
          "membersCount": 1,
          "transactionDataType": {
            "type": "TransactionDataCompressed",
            "value": "Transaction data (compressed)",
            "description": "TODO"
          },
          "display": {
            "name": "AlienX DAC",
            "slug": "dac",
            "description": "AlienX DAC on Ethereum.",
            "warning": null,
            "redWarning": "Only one signer is required to attest to the availability of the data.",
            "links": {
              "websites": ["https://alienxchain.io/"],
              "apps": [
                "https://bridge.alienxchain.io/",
                "https://alienswap.xyz/"
              ],
              "documentation": ["https://docs.alienxchain.io"],
              "explorers": ["https://explorer.alienxchain.io"],
              "repositories": [],
              "socialMedia": [
                "https://x.com/ALIENXchain",
                "https://discord.gg/alienxchain",
                "https://medium.com/@ALIENXchain",
                "https://t.me/alienx_ainode"
              ]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![Anytrust bridge architecture](/images/da-bridge-technology/anytrust/architectureL2.png#center)\n\n\n    The DA commitments are posted to the L1 through the sequencer inbox, using the inbox as a DA bridge.\n    The DA commitment consists of Data Availability Certificate (DACert), including a hash of the data block, an expiration time, and a proof that the required threshold of Committee members have signed off on the data.\n    The sequencer distributes the data and collects signatures from Committee members offchain. Only the DACert is posted by the sequencer to the L1 chain inbox (the DA bridge), achieving L2 transaction ordering finality in a single onchain transaction.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "1/1",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "sanko-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": "Ethereum (blobs)",
      "hasChallengeMechanism": null,
      "display": {
        "name": "Sanko DAC",
        "slug": "sanko",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://sanko.xyz/"],
          "apps": ["https://sanko.xyz/bridge", "https://swap.sanko.xyz"],
          "documentation": ["https://sanko-1.gitbook.io/sanko-mainnet-docs/"],
          "explorers": [
            "https://sanko-mainnet.calderaexplorer.xyz/",
            "https://tools.sanko.xyz/",
            "https://explorer.sanko.xyz/"
          ],
          "repositories": [],
          "socialMedia": [
            "https://x.com/SankoGameCorp",
            "https://discord.gg/Cnz62Vfa2C",
            "https://t.me/sankogamecorp"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![Anytrust architecture](/images/da-layer-technology/anytrust/architecture1.png#center)\n\n    The DAC uses a data availability solution built on the AnyTrust protocol. It is composed of the following components:\n    - **Sequencer Inbox**: Main entry point for the Sequencer submitting transaction batches.\n    - **Data Availability Committee (DAC)**: A group of members responsible for storing and providing data on demand.\n    - **Data Availability Certificate (DACert)**: A commitment ensuring that data blobs are available without needing full data posting on the L1 chain. \n\n    \n    Committee members run servers that support APIs for storing and retrieving data blobs. \n    The Sequencer API allows the rollup Sequencer to submit data blobs for storage, while the REST API enables anyone to fetch data by hash. \n    When the Sequencer produces a data batch, it sends the batch along with an expiration time to Committee members, who store it and sign it. \n    Once enough signatures are collected, the Sequencer aggregates them into a valid DACert and posts it to the L1 chain inbox. \n    If the Sequencer fails to collect enough signatures, it falls back to posting the full data to the L1 chain. \n\n\n    A DACert includes a hash of the data block, an expiration time, and proof that the required threshold of Committee members have signed off on the data. \n    The proof consists of a hash of the Keyset used in signing, a bitmap indicating which members signed, and a BLS aggregated signature. \n    L2 nodes reading from the sequencer inbox verify the certificate’s validity by checking the number of signers, the aggregated signature, and that the expiration time is at least two weeks ahead of the L2 timestamp. \n    If the DACert is valid, it provides a proof that the corresponding data is available from honest committee members.\n\n    ",
        "risks": null
      },
      "usedIn": [{ "id": "sanko", "name": "Sanko", "slug": "sanko" }],
      "bridges": [
        {
          "id": "sanko-dac-bridge",
          "type": "DAC",
          "usedIn": [{ "id": "sanko", "name": "Sanko", "slug": "sanko" }],
          "createdAt": "1723211933",
          "contracts": {
            "addresses": [
              {
                "name": "SequencerInbox",
                "address": "0x24B68936C13A414cd91437aE7AA730321B9ff159",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0xd18b1C6376633000c85541F7c15c591Ffe5f9556"],
                  "implementations": [
                    "0x083c2b4D0C745224E8E484Dfd41eDC9b19f21Feb"
                  ]
                },
                "chain": "arbitrum",
                "description": "Main entry point for the Sequencer submitting transaction batches."
              }
            ],
            "risks": []
          },
          "permissions": [],
          "chain": 42161,
          "requiredMembers": 1,
          "membersCount": 1,
          "transactionDataType": {
            "type": "TransactionDataCompressed",
            "value": "Transaction data (compressed)",
            "description": "TODO"
          },
          "display": {
            "name": "Sanko DAC",
            "slug": "dac",
            "description": "Sanko DAC on Ethereum.",
            "warning": null,
            "redWarning": "Only one signer is required to attest to the availability of the data.",
            "links": {
              "websites": ["https://sanko.xyz/"],
              "apps": ["https://sanko.xyz/bridge", "https://swap.sanko.xyz"],
              "documentation": [
                "https://sanko-1.gitbook.io/sanko-mainnet-docs/"
              ],
              "explorers": [
                "https://sanko-mainnet.calderaexplorer.xyz/",
                "https://tools.sanko.xyz/",
                "https://explorer.sanko.xyz/"
              ],
              "repositories": [],
              "socialMedia": [
                "https://x.com/SankoGameCorp",
                "https://discord.gg/Cnz62Vfa2C",
                "https://t.me/sankogamecorp"
              ]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![Anytrust bridge architecture](/images/da-bridge-technology/anytrust/architectureL3.png#center)\n\n\n    The DA commitments are posted to the L2 through the sequencer inbox, using the inbox as a DA bridge.\n    The DA commitment consists of Data Availability Certificate (DACert), including a hash of the data block, an expiration time, and a proof that the required threshold of Committee members have signed off on the data.\n    The sequencer distributes the data and collects signatures from Committee members offchain. Only the DACert is posted by the sequencer to the L2 chain inbox (the DA bridge), achieving L3 transaction ordering finality in a single onchain transaction.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "1/1",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "myria-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": null,
      "hasChallengeMechanism": null,
      "display": {
        "name": "Myria DAC",
        "slug": "myria",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://myria.com/"],
          "apps": ["https://hub.immutable.com/"],
          "documentation": ["https://docs.starkware.co/starkex/index.html"],
          "explorers": [],
          "repositories": [
            "https://github.com/starkware-libs/starkex-contracts"
          ],
          "socialMedia": [
            "https://medium.com/@myriagames",
            "https://twitter.com/myria",
            "https://discord.gg/myria",
            "https://t.me/myriaofficialgroup",
            "https://instagram.com/myriagames"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![starkex architecture](/images/da-layer-technology/starkex/architecture5.png#center)\n\n    The Starkware application utilizes a data availability solution that relies on a Committee Service to ensure data persistence. This architecture comprises the following components:\n\n    - **Availability Gateway**: The primary interface provided by the operator for committee members to access new batch information and submit signed availability claims.\n    - **Data Availability Committee (DAC)**: A group of nodes responsible for storing state data associated with each Merkle root and attesting to data availability by signing claims.\n    - **Data Batches**: Collections of transactions processed in batches that update the state of accounts, resulting in a new Merkle root representing the updated state.\n    \n    Committee members run services that interact with the Availability Gateway to obtain information about new batches and submit their signed availability claims. Each batch includes a unique batch_id, a reference to a previous batch, and a list of account updates. \n    Committee members combine this information with data from the reference batch to compute the new state and verify the Merkle root.\n    \n    When the operator produces a new batch, it must be signed by a minimum number of committee members—as defined by the application's configuration—for it to be accepted onchain. \n    This includes all members designated as mandatory signers. If the operator attempts to submit a batch without the required signatures, it will be rejected, thereby ensuring that data remains available and consistent.\n    \n    Committee members are expected to maintain a database that stores the data associated with each batch, making use of storage solutions with a replication factor of at least 2.\n  \n    ",
        "risks": null
      },
      "usedIn": [{ "id": "myria", "name": "Myria", "slug": "myria" }],
      "bridges": [
        {
          "id": "myria-dac-bridge",
          "type": "DAC",
          "usedIn": [{ "id": "myria", "name": "Myria", "slug": "myria" }],
          "createdAt": "1723211933",
          "contracts": {
            "addresses": [
              {
                "name": "Committee",
                "address": "0x1e601435E181423e7A8430813d7500012a6169cB",
                "upgradeability": null,
                "chain": "ethereum",
                "description": "Data Availability Committee (DAC) contract verifying data availability claim from DAC Members (via multisig check)."
              }
            ],
            "risks": []
          },
          "permissions": [
            {
              "name": "Committee Members",
              "description": "List of addresses authorized to sign data commitments for the DA bridge.",
              "accounts": [
                {
                  "address": "0x30cF77FC391B4Feba1AB31B01fEd442Bc759c0a8",
                  "type": "EOA"
                },
                {
                  "address": "0x52E6ECB50D8C89fE9CBad2ef44Ce962A430D8714",
                  "type": "EOA"
                },
                {
                  "address": "0xC7544ad893710Bd0bf780bf78dE5547706da75c5",
                  "type": "EOA"
                },
                {
                  "address": "0xf365CDB8C33849d3684AcFf5475E7B6F075F9F0F",
                  "type": "EOA"
                },
                {
                  "address": "0xfBA93b5f744c853648d62C1357532582f77ed394",
                  "type": "EOA"
                }
              ]
            }
          ],
          "chain": 1,
          "requiredMembers": 2,
          "membersCount": 5,
          "transactionDataType": {
            "type": "StateDiffs",
            "value": "State diffs",
            "description": "TODO"
          },
          "display": {
            "name": "Myria DAC",
            "slug": "dac",
            "description": "Myria DAC on Ethereum.",
            "warning": null,
            "redWarning": null,
            "links": {
              "websites": ["https://myria.com/"],
              "apps": ["https://hub.immutable.com/"],
              "documentation": ["https://docs.starkware.co/starkex/index.html"],
              "explorers": [],
              "repositories": [
                "https://github.com/starkware-libs/starkex-contracts"
              ],
              "socialMedia": [
                "https://medium.com/@myriagames",
                "https://twitter.com/myria",
                "https://discord.gg/myria",
                "https://t.me/myriaofficialgroup",
                "https://instagram.com/myriagames"
              ]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![starkex bridge architecture](/images/da-bridge-technology/starkex/architectureL2.png#center)\n      The DA commitments are posted to the L1 chain, using the Committee Verifier contract as a DA bridge.\n      The DA commitment consists of a data hash of the transaction batch the Committee has signed off on and a concatenation of ec-signatures by signatories.\n      The Committee Verifier contract verifies the signatures and the data hash and if the required threshold of Committee members has signed off on the data, the hash is stored as a registeredFact in the StarkEx contract.\n      In a separate transaction, the operator calls the updateState() function on the StarkEx contract to update the state.\n      Before the state update is accepted, the StarkEx contract verifies the transaction public inputs by calling the isValid() function, which verifies the hash derived from state update inputs matches the hash stored by the Committee Verifier contract.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "2/5",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "aleph-zero-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": "Ethereum (blobs)",
      "hasChallengeMechanism": null,
      "display": {
        "name": "Aleph Zero EVM DAC",
        "slug": "aleph-zero",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://alephzero.org/"],
          "apps": ["https://bridge.gelato.network/bridge/aleph-zero-evm"],
          "documentation": ["https://docs.alephzero.org/"],
          "explorers": ["https://evm-explorer.alephzero.org/"],
          "repositories": ["https://github.com/Cardinal-Cryptography"],
          "socialMedia": ["https://x.com/Aleph__Zero"]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![Anytrust architecture](/images/da-layer-technology/anytrust/architecture2.png#center)\n\n    The DAC uses a data availability solution built on the AnyTrust protocol. It is composed of the following components:\n    - **Sequencer Inbox**: Main entry point for the Sequencer submitting transaction batches.\n    - **Data Availability Committee (DAC)**: A group of members responsible for storing and providing data on demand.\n    - **Data Availability Certificate (DACert)**: A commitment ensuring that data blobs are available without needing full data posting on the L1 chain. \n\n    \n    Committee members run servers that support APIs for storing and retrieving data blobs. \n    The Sequencer API allows the rollup Sequencer to submit data blobs for storage, while the REST API enables anyone to fetch data by hash. \n    When the Sequencer produces a data batch, it sends the batch along with an expiration time to Committee members, who store it and sign it. \n    Once enough signatures are collected, the Sequencer aggregates them into a valid DACert and posts it to the L1 chain inbox. \n    If the Sequencer fails to collect enough signatures, it falls back to posting the full data to the L1 chain. \n\n\n    A DACert includes a hash of the data block, an expiration time, and proof that the required threshold of Committee members have signed off on the data. \n    The proof consists of a hash of the Keyset used in signing, a bitmap indicating which members signed, and a BLS aggregated signature. \n    L2 nodes reading from the sequencer inbox verify the certificate’s validity by checking the number of signers, the aggregated signature, and that the expiration time is at least two weeks ahead of the L2 timestamp. \n    If the DACert is valid, it provides a proof that the corresponding data is available from honest committee members.\n\n    ",
        "risks": null
      },
      "usedIn": [
        { "id": "alephzero", "name": "Aleph Zero EVM", "slug": "aleph-zero" }
      ],
      "bridges": [
        {
          "id": "aleph-zero-dac-bridge",
          "type": "DAC",
          "usedIn": [
            {
              "id": "alephzero",
              "name": "Aleph Zero EVM",
              "slug": "aleph-zero"
            }
          ],
          "createdAt": "1723211933",
          "contracts": {
            "addresses": [
              {
                "name": "SequencerInbox",
                "address": "0xF75206c49c1694594E3e69252E519434f1579876",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x80622fe04c5e1c3fbb3A9c62996dB27B53E9F77b"],
                  "implementations": [
                    "0x383f16fB2809a56fC639c1eE2c93Ad2aa7Ee130A"
                  ]
                },
                "chain": "ethereum",
                "description": "Main entry point for the Sequencer submitting transaction batches."
              }
            ],
            "risks": []
          },
          "permissions": [
            {
              "name": "Sequencers",
              "accounts": [
                {
                  "address": "0xbc35c3fBd56318Bf360086f50576233Dc93AFF20",
                  "type": "EOA"
                }
              ],
              "description": "Central actors allowed to submit transaction batches to the Sequencer Inbox.",
              "chain": "ethereum"
            },
            {
              "name": "RollupOwner",
              "accounts": [
                {
                  "address": "0x257812604076712675ae9788F5Bd738173CA3CE0",
                  "type": "EOA"
                }
              ],
              "description": "Multisig that can upgrade authorized batch posters via the UpgradeExecutor contract."
            }
          ],
          "chain": 1,
          "requiredMembers": 1,
          "membersCount": 2,
          "transactionDataType": {
            "type": "TransactionDataCompressed",
            "value": "Transaction data (compressed)",
            "description": "TODO"
          },
          "display": {
            "name": "Aleph Zero EVM DAC",
            "slug": "dac",
            "description": "Aleph Zero EVM DAC on Ethereum.",
            "warning": null,
            "redWarning": "Only one signer is required to attest to the availability of the data.",
            "links": {
              "websites": ["https://alephzero.org/"],
              "apps": ["https://bridge.gelato.network/bridge/aleph-zero-evm"],
              "documentation": ["https://docs.alephzero.org/"],
              "explorers": ["https://evm-explorer.alephzero.org/"],
              "repositories": ["https://github.com/Cardinal-Cryptography"],
              "socialMedia": ["https://x.com/Aleph__Zero"]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![Anytrust bridge architecture](/images/da-bridge-technology/anytrust/architectureL2.png#center)\n\n\n    The DA commitments are posted to the L1 through the sequencer inbox, using the inbox as a DA bridge.\n    The DA commitment consists of Data Availability Certificate (DACert), including a hash of the data block, an expiration time, and a proof that the required threshold of Committee members have signed off on the data.\n    The sequencer distributes the data and collects signatures from Committee members offchain. Only the DACert is posted by the sequencer to the L1 chain inbox (the DA bridge), achieving L2 transaction ordering finality in a single onchain transaction.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "1/2",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "edgeless-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": "Ethereum (blobs)",
      "hasChallengeMechanism": null,
      "display": {
        "name": "Edgeless DAC",
        "slug": "edgeless",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://edgeless.network/"],
          "apps": ["https://bridge.edgeless.network/"],
          "documentation": ["https://docs.edgeless.network/"],
          "explorers": ["https://explorer.edgeless.network/"],
          "repositories": ["https://github.com/edgelessNetwork"],
          "socialMedia": [
            "https://twitter.com/EdgelessNetwork",
            "https://discord.gg/edgeless",
            "https://paragraph.xyz/@edgeless",
            "https://t.me/+f8yhoOg-4cNhYWEx"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![Anytrust architecture](/images/da-layer-technology/anytrust/architecture1.png#center)\n\n    The DAC uses a data availability solution built on the AnyTrust protocol. It is composed of the following components:\n    - **Sequencer Inbox**: Main entry point for the Sequencer submitting transaction batches.\n    - **Data Availability Committee (DAC)**: A group of members responsible for storing and providing data on demand.\n    - **Data Availability Certificate (DACert)**: A commitment ensuring that data blobs are available without needing full data posting on the L1 chain. \n\n    \n    Committee members run servers that support APIs for storing and retrieving data blobs. \n    The Sequencer API allows the rollup Sequencer to submit data blobs for storage, while the REST API enables anyone to fetch data by hash. \n    When the Sequencer produces a data batch, it sends the batch along with an expiration time to Committee members, who store it and sign it. \n    Once enough signatures are collected, the Sequencer aggregates them into a valid DACert and posts it to the L1 chain inbox. \n    If the Sequencer fails to collect enough signatures, it falls back to posting the full data to the L1 chain. \n\n\n    A DACert includes a hash of the data block, an expiration time, and proof that the required threshold of Committee members have signed off on the data. \n    The proof consists of a hash of the Keyset used in signing, a bitmap indicating which members signed, and a BLS aggregated signature. \n    L2 nodes reading from the sequencer inbox verify the certificate’s validity by checking the number of signers, the aggregated signature, and that the expiration time is at least two weeks ahead of the L2 timestamp. \n    If the DACert is valid, it provides a proof that the corresponding data is available from honest committee members.\n\n    ",
        "risks": null
      },
      "usedIn": [{ "id": "edgeless", "name": "Edgeless", "slug": "edgeless" }],
      "bridges": [
        {
          "id": "edgeless-dac-bridge",
          "type": "DAC",
          "usedIn": [
            { "id": "edgeless", "name": "Edgeless", "slug": "edgeless" }
          ],
          "createdAt": "1723211933",
          "contracts": {
            "addresses": [
              {
                "name": "SequencerInbox",
                "address": "0xFfbf2b49524e09B1F1fBcA707B830e79c68c2086",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x48E84C45fE99859B1D72FA56Ce5D3c76FF2F7006"],
                  "implementations": [
                    "0x873484Ba63353C8b71210ce123B465512d408B27"
                  ]
                },
                "chain": "ethereum",
                "description": "Main entry point for the Sequencer submitting transaction batches."
              }
            ],
            "risks": []
          },
          "permissions": [
            {
              "name": "Sequencers",
              "accounts": [
                {
                  "address": "0x4e4aC6F04106964b5B69FDA5EcC207295bCae81f",
                  "type": "EOA"
                }
              ],
              "description": "Central actors allowed to submit transaction batches to the Sequencer Inbox.",
              "chain": "ethereum"
            },
            {
              "name": "RollupOwner",
              "accounts": [
                {
                  "address": "0x4dE424B0BDe70504Ad7b3c644EaAd052F4D993b4",
                  "type": "MultiSig"
                }
              ],
              "description": "Multisig that can upgrade authorized batch posters via the UpgradeExecutor contract."
            }
          ],
          "chain": 1,
          "requiredMembers": 1,
          "membersCount": 1,
          "transactionDataType": {
            "type": "TransactionDataCompressed",
            "value": "Transaction data (compressed)",
            "description": "TODO"
          },
          "display": {
            "name": "Edgeless DAC",
            "slug": "dac",
            "description": "Edgeless DAC on Ethereum.",
            "warning": null,
            "redWarning": "Only one signer is required to attest to the availability of the data.",
            "links": {
              "websites": ["https://edgeless.network/"],
              "apps": ["https://bridge.edgeless.network/"],
              "documentation": ["https://docs.edgeless.network/"],
              "explorers": ["https://explorer.edgeless.network/"],
              "repositories": ["https://github.com/edgelessNetwork"],
              "socialMedia": [
                "https://twitter.com/EdgelessNetwork",
                "https://discord.gg/edgeless",
                "https://paragraph.xyz/@edgeless",
                "https://t.me/+f8yhoOg-4cNhYWEx"
              ]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![Anytrust bridge architecture](/images/da-bridge-technology/anytrust/architectureL2.png#center)\n\n\n    The DA commitments are posted to the L1 through the sequencer inbox, using the inbox as a DA bridge.\n    The DA commitment consists of Data Availability Certificate (DACert), including a hash of the data block, an expiration time, and a proof that the required threshold of Committee members have signed off on the data.\n    The sequencer distributes the data and collects signatures from Committee members offchain. Only the DACert is posted by the sequencer to the L1 chain inbox (the DA bridge), achieving L2 transaction ordering finality in a single onchain transaction.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "1/1",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "everclear-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": "Ethereum (blobs)",
      "hasChallengeMechanism": null,
      "display": {
        "name": "Everclear Hub DAC",
        "slug": "everclear",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://everclear.org"],
          "apps": ["https://bridge.gelato.network/bridge/everclear-mainnet"],
          "documentation": ["https://docs.everclear.org"],
          "explorers": ["https://scan.everclear.org/"],
          "repositories": ["https://github.com/connext"],
          "socialMedia": [
            "https://x.com/everclearorg",
            "https://discord.gg/everclear",
            "https://blog.everclear.org/"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![Anytrust architecture](/images/da-layer-technology/anytrust/architecture2.png#center)\n\n    The DAC uses a data availability solution built on the AnyTrust protocol. It is composed of the following components:\n    - **Sequencer Inbox**: Main entry point for the Sequencer submitting transaction batches.\n    - **Data Availability Committee (DAC)**: A group of members responsible for storing and providing data on demand.\n    - **Data Availability Certificate (DACert)**: A commitment ensuring that data blobs are available without needing full data posting on the L1 chain. \n\n    \n    Committee members run servers that support APIs for storing and retrieving data blobs. \n    The Sequencer API allows the rollup Sequencer to submit data blobs for storage, while the REST API enables anyone to fetch data by hash. \n    When the Sequencer produces a data batch, it sends the batch along with an expiration time to Committee members, who store it and sign it. \n    Once enough signatures are collected, the Sequencer aggregates them into a valid DACert and posts it to the L1 chain inbox. \n    If the Sequencer fails to collect enough signatures, it falls back to posting the full data to the L1 chain. \n\n\n    A DACert includes a hash of the data block, an expiration time, and proof that the required threshold of Committee members have signed off on the data. \n    The proof consists of a hash of the Keyset used in signing, a bitmap indicating which members signed, and a BLS aggregated signature. \n    L2 nodes reading from the sequencer inbox verify the certificate’s validity by checking the number of signers, the aggregated signature, and that the expiration time is at least two weeks ahead of the L2 timestamp. \n    If the DACert is valid, it provides a proof that the corresponding data is available from honest committee members.\n\n    ",
        "risks": null
      },
      "usedIn": [
        { "id": "everclear", "name": "Everclear Hub", "slug": "everclear" }
      ],
      "bridges": [
        {
          "id": "everclear-dac-bridge",
          "type": "DAC",
          "usedIn": [
            { "id": "everclear", "name": "Everclear Hub", "slug": "everclear" }
          ],
          "createdAt": "1723211933",
          "contracts": {
            "addresses": [
              {
                "name": "SequencerInbox",
                "address": "0xF75206c49c1694594E3e69252E519434f1579876",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x80622fe04c5e1c3fbb3A9c62996dB27B53E9F77b"],
                  "implementations": [
                    "0x383f16fB2809a56fC639c1eE2c93Ad2aa7Ee130A"
                  ]
                },
                "chain": "ethereum",
                "description": "Main entry point for the Sequencer submitting transaction batches."
              }
            ],
            "risks": []
          },
          "permissions": [
            {
              "name": "Sequencers",
              "accounts": [
                {
                  "address": "0xbc35c3fBd56318Bf360086f50576233Dc93AFF20",
                  "type": "EOA"
                }
              ],
              "description": "Central actors allowed to submit transaction batches to the Sequencer Inbox.",
              "chain": "ethereum"
            },
            {
              "name": "RollupOwner",
              "accounts": [
                {
                  "address": "0x257812604076712675ae9788F5Bd738173CA3CE0",
                  "type": "EOA"
                }
              ],
              "description": "Multisig that can upgrade authorized batch posters via the UpgradeExecutor contract."
            }
          ],
          "chain": 1,
          "requiredMembers": 1,
          "membersCount": 2,
          "transactionDataType": {
            "type": "TransactionDataCompressed",
            "value": "Transaction data (compressed)",
            "description": "TODO"
          },
          "display": {
            "name": "Everclear Hub DAC",
            "slug": "dac",
            "description": "Everclear Hub DAC on Ethereum.",
            "warning": null,
            "redWarning": "Only one signer is required to attest to the availability of the data.",
            "links": {
              "websites": ["https://everclear.org"],
              "apps": [
                "https://bridge.gelato.network/bridge/everclear-mainnet"
              ],
              "documentation": ["https://docs.everclear.org"],
              "explorers": ["https://scan.everclear.org/"],
              "repositories": ["https://github.com/connext"],
              "socialMedia": [
                "https://x.com/everclearorg",
                "https://discord.gg/everclear",
                "https://blog.everclear.org/"
              ]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![Anytrust bridge architecture](/images/da-bridge-technology/anytrust/architectureL2.png#center)\n\n\n    The DA commitments are posted to the L1 through the sequencer inbox, using the inbox as a DA bridge.\n    The DA commitment consists of Data Availability Certificate (DACert), including a hash of the data block, an expiration time, and a proof that the required threshold of Committee members have signed off on the data.\n    The sequencer distributes the data and collects signatures from Committee members offchain. Only the DACert is posted by the sequencer to the L1 chain inbox (the DA bridge), achieving L2 transaction ordering finality in a single onchain transaction.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "1/2",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "wirex-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": null,
      "hasChallengeMechanism": null,
      "display": {
        "name": "Pay Chain DAC",
        "slug": "wirex",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://wirexpaychain.com/"],
          "apps": ["https://pay-chain-bridge.wirexpaychain.com/"],
          "documentation": [
            "https://docs.wirexpaychain.com/tech/wirex-pay-chain"
          ],
          "explorers": ["https://pay-chain-blockscout.wirexpaychain.com/"],
          "repositories": [],
          "socialMedia": [
            "https://x.com/wirexpaychain",
            "https://discord.gg/f8UGp4dH6g",
            "https://wirexpaychain.com/blog"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![polygoncdk architecture](/images/da-layer-technology/polygoncdk/architecture2.png#center)\n\n    Polygon CDK validiums utilize a data availability solution that relies on a Data Availability Committee (DAC) to ensure data integrity and manage off-chain transaction data. \n    This architecture comprises the following components:\n    - **Operator**: A trusted entity that collects transactions, computes hash values for the transaction batch, and then requests and collects signatures from Committee members.\n    - **Data Availability Committee (DAC)**: A group of nodes responsible for validating batch data against the hash values provided by the operator (sequencer), ensuring the data accurately represents the transactions.\n    - **PolygonCommittee Contract**: Contract responsible for managing the data committee members list.\n    Each DAC node independently validates the batch data, ensuring it matches the received hash values. \n    Upon successful validation, DAC members store the hash values locally and generate signatures endorsing the batch's integrity. \n    The sequencer collects these signatures and submits the transactions batch hash together with the aggregated signature on Ethereum.\n    The PolygonCommittee contract is used during batch sequencing to verify that the signature posted by the sequencer was signed off by the DAC members stored in the contract.\n    ",
        "risks": null
      },
      "usedIn": [{ "id": "wirex", "name": "Pay Chain", "slug": "wirex" }],
      "bridges": [
        {
          "id": "wirex-dac-bridge",
          "type": "DAC",
          "usedIn": [{ "id": "wirex", "name": "Pay Chain", "slug": "wirex" }],
          "createdAt": "1723211933",
          "permissions": [
            {
              "name": "Committee Members",
              "description": "List of addresses authorized to sign data commitments for the DA bridge.",
              "accounts": [
                {
                  "address": "0xBf5B50887F0B2b3160A3a097EBA4edEd8A9dDed1",
                  "type": "EOA"
                },
                {
                  "address": "0xCEb82CC6e0C2541a19E4b6E2DBF237fF2d8E96f8",
                  "type": "EOA"
                }
              ]
            },
            {
              "name": "LocalAdmin",
              "accounts": [
                {
                  "address": "0xecEA75e2854FD52b0aE5C51C88f5eA8e2eC4bf9A",
                  "type": "EOA"
                }
              ],
              "description": "Admin and ForceBatcher of the WirexPayChainValidium contract, can set core system parameters like timeouts, sequencer, activate forced transactions, and set the DA committee members in the WirexPayChainDAC contract."
            }
          ],
          "chain": 1,
          "requiredMembers": 1,
          "membersCount": 2,
          "transactionDataType": {
            "type": "TransactionData",
            "value": "Transaction data",
            "description": "TODO"
          },
          "contracts": {
            "addresses": [
              {
                "name": "WirexPayChainValidium",
                "address": "0x78253E2E6120164bd826668A4C96Db20f78A94c9",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x5132A183E9F3CB7C848b0AAC5Ae0c4f0491B7aB2"],
                  "implementations": [
                    "0x10D296e8aDd0535be71639E5D1d1c30ae1C6bD4C"
                  ]
                },
                "chain": "ethereum",
                "description": "The main contract of the WirexPayChain zkEVM. Contains sequenced transaction batch hashes and signature verification logic for the signed data hash commitment."
              },
              {
                "name": "WirexPayChainDAC",
                "address": "0x755e9A5B4BAEFc78Bb82BA7E6d2386CCB2F238a5",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x2B966b9824c11f274aa39f2f72cF25C4b47c3A78"],
                  "implementations": [
                    "0xAce9269EaC3419937093154dea0AD44C36Df6963"
                  ]
                },
                "chain": "ethereum",
                "description": "Validium committee contract that allows the admin to setup the members of the committee and stores the required amount of signatures threshold.",
                "upgradableBy": ["LocalAdmin"],
                "upgradeDelay": "None"
              }
            ],
            "risks": []
          },
          "display": {
            "name": "Pay Chain DAC",
            "slug": "dac",
            "description": "Pay Chain DAC on Ethereum.",
            "warning": null,
            "redWarning": "Only one signer is required to attest to the availability of the data.",
            "links": {
              "websites": ["https://wirexpaychain.com/"],
              "apps": ["https://pay-chain-bridge.wirexpaychain.com/"],
              "documentation": [
                "https://docs.wirexpaychain.com/tech/wirex-pay-chain"
              ],
              "explorers": ["https://pay-chain-blockscout.wirexpaychain.com/"],
              "repositories": [],
              "socialMedia": [
                "https://x.com/wirexpaychain",
                "https://discord.gg/f8UGp4dH6g",
                "https://wirexpaychain.com/blog"
              ]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![polygoncdk bridge architecture](/images/da-bridge-technology/polygoncdk/architectureL2.png#center)\n    The DA commitments are posted to the L1 through the sequencer inbox, using the inbox as a DA bridge.\n    The DA commitment consists of a data availability message provided as transaction input, made up of a byte array containing the signatures and all the addresses of the committee in ascending order.\n    The sequencer distributes the data and collects signatures from Committee members offchain. Only the DA message is posted by the sequencer to the L1 chain inbox (the DA bridge).\n    A separate contract, the PolygonCommittee contract, is used to manage the committee members list and verify the signatures before accepting the DA commitment.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "1/2",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "gpt-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": null,
      "hasChallengeMechanism": null,
      "display": {
        "name": "GPT Protocol DAC",
        "slug": "gpt",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://gptprotocol.org/"],
          "apps": [
            "https://bridge.gptprotocol.io/",
            "https://assistant.gptprotocol.io/",
            "https://staking.gptprotocol.org/"
          ],
          "documentation": [],
          "explorers": ["https://explorer.gptprotocol.io/"],
          "repositories": ["https://github.com/gptprotocol"],
          "socialMedia": [
            "https://x.com/gpt_protocol",
            "https://t.me/gpt_protocol",
            "https://discord.com/invite/gptprotocol",
            "https://instagram.com/gptprotocol/"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![polygoncdk architecture](/images/da-layer-technology/polygoncdk/architecture2.png#center)\n\n    Polygon CDK validiums utilize a data availability solution that relies on a Data Availability Committee (DAC) to ensure data integrity and manage off-chain transaction data. \n    This architecture comprises the following components:\n    - **Operator**: A trusted entity that collects transactions, computes hash values for the transaction batch, and then requests and collects signatures from Committee members.\n    - **Data Availability Committee (DAC)**: A group of nodes responsible for validating batch data against the hash values provided by the operator (sequencer), ensuring the data accurately represents the transactions.\n    - **PolygonCommittee Contract**: Contract responsible for managing the data committee members list.\n    Each DAC node independently validates the batch data, ensuring it matches the received hash values. \n    Upon successful validation, DAC members store the hash values locally and generate signatures endorsing the batch's integrity. \n    The sequencer collects these signatures and submits the transactions batch hash together with the aggregated signature on Ethereum.\n    The PolygonCommittee contract is used during batch sequencing to verify that the signature posted by the sequencer was signed off by the DAC members stored in the contract.\n    ",
        "risks": null
      },
      "usedIn": [{ "id": "gpt", "name": "GPT Protocol", "slug": "gpt" }],
      "bridges": [
        {
          "id": "gpt-dac-bridge",
          "type": "DAC",
          "usedIn": [{ "id": "gpt", "name": "GPT Protocol", "slug": "gpt" }],
          "createdAt": "1723211933",
          "permissions": [
            {
              "name": "Committee Members",
              "description": "List of addresses authorized to sign data commitments for the DA bridge.",
              "accounts": [
                {
                  "address": "0x208C0bCD77F921209932081c27C543098838BF9e",
                  "type": "EOA"
                },
                {
                  "address": "0x7417EDBE8906093Ef3a5eF67D9d422aBe3398527",
                  "type": "EOA"
                }
              ]
            },
            {
              "name": "LocalAdmin",
              "accounts": [
                {
                  "address": "0x5B8C9f36c8F84E49EC89Ae2881D920Ceb36D7F40",
                  "type": "EOA"
                }
              ],
              "description": "Admin and ForceBatcher of the GptProtocolValidium contract, can set core system parameters like timeouts, sequencer, activate forced transactions, and set the DA committee members in the GptProtocolDAC contract."
            }
          ],
          "chain": 1,
          "requiredMembers": 1,
          "membersCount": 2,
          "transactionDataType": {
            "type": "TransactionData",
            "value": "Transaction data",
            "description": "TODO"
          },
          "contracts": {
            "addresses": [
              {
                "name": "GptProtocolValidium",
                "address": "0xC4E903D3Af4c3d2e437492d602adcC9d9b536858",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x5132A183E9F3CB7C848b0AAC5Ae0c4f0491B7aB2"],
                  "implementations": [
                    "0x10D296e8aDd0535be71639E5D1d1c30ae1C6bD4C"
                  ]
                },
                "chain": "ethereum",
                "description": "The main contract of the WirexPayChain zkEVM. Contains sequenced transaction batch hashes and signature verification logic for the signed data hash commitment."
              },
              {
                "name": "GptProtocolDAC",
                "address": "0x75E26A2996DEAbA20386B6f3c1C957eFadb3f6E8",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0xada59D145126A746976F0F56477aafFEB3acc8e3"],
                  "implementations": [
                    "0xA36aFB6b79A3d164a3d12C141c916BECc6e012D8"
                  ]
                },
                "chain": "ethereum",
                "description": "Validium committee contract that allows the admin to setup the members of the committee and stores the required amount of signatures threshold.",
                "upgradableBy": ["LocalAdmin"],
                "upgradeDelay": "None"
              }
            ],
            "risks": []
          },
          "display": {
            "name": "GPT Protocol DAC",
            "slug": "dac",
            "description": "GPT Protocol DAC on Ethereum.",
            "warning": null,
            "redWarning": "Only one signer is required to attest to the availability of the data.",
            "links": {
              "websites": ["https://gptprotocol.org/"],
              "apps": [
                "https://bridge.gptprotocol.io/",
                "https://assistant.gptprotocol.io/",
                "https://staking.gptprotocol.org/"
              ],
              "documentation": [],
              "explorers": ["https://explorer.gptprotocol.io/"],
              "repositories": ["https://github.com/gptprotocol"],
              "socialMedia": [
                "https://x.com/gpt_protocol",
                "https://t.me/gpt_protocol",
                "https://discord.com/invite/gptprotocol",
                "https://instagram.com/gptprotocol/"
              ]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![polygoncdk bridge architecture](/images/da-bridge-technology/polygoncdk/architectureL2.png#center)\n    The DA commitments are posted to the L1 through the sequencer inbox, using the inbox as a DA bridge.\n    The DA commitment consists of a data availability message provided as transaction input, made up of a byte array containing the signatures and all the addresses of the committee in ascending order.\n    The sequencer distributes the data and collects signatures from Committee members offchain. Only the DA message is posted by the sequencer to the L1 chain inbox (the DA bridge).\n    A separate contract, the PolygonCommittee contract, is used to manage the committee members list and verify the signatures before accepting the DA commitment.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "1/2",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "witness-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": null,
      "hasChallengeMechanism": null,
      "display": {
        "name": "Witness Chain DAC",
        "slug": "witness",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://witnesschain.com/"],
          "apps": ["https://witnesschain-bridge.eu-north-2.gateway.fm"],
          "documentation": ["https://docs.witnesschain.com/"],
          "explorers": [
            "https://witnesschain-blockscout.eu-north-2.gateway.fm/"
          ],
          "repositories": ["https://github.com/witnesschain-com"],
          "socialMedia": [
            "https://twitter.com/witnesschain",
            "https://discord.gg/HwnzU5CYDp",
            "https://docs.witnesschain.com/resources/technical-papers"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![polygoncdk architecture](/images/da-layer-technology/polygoncdk/architecture2.png#center)\n\n    Polygon CDK validiums utilize a data availability solution that relies on a Data Availability Committee (DAC) to ensure data integrity and manage off-chain transaction data. \n    This architecture comprises the following components:\n    - **Operator**: A trusted entity that collects transactions, computes hash values for the transaction batch, and then requests and collects signatures from Committee members.\n    - **Data Availability Committee (DAC)**: A group of nodes responsible for validating batch data against the hash values provided by the operator (sequencer), ensuring the data accurately represents the transactions.\n    - **PolygonCommittee Contract**: Contract responsible for managing the data committee members list.\n    Each DAC node independently validates the batch data, ensuring it matches the received hash values. \n    Upon successful validation, DAC members store the hash values locally and generate signatures endorsing the batch's integrity. \n    The sequencer collects these signatures and submits the transactions batch hash together with the aggregated signature on Ethereum.\n    The PolygonCommittee contract is used during batch sequencing to verify that the signature posted by the sequencer was signed off by the DAC members stored in the contract.\n    ",
        "risks": null
      },
      "usedIn": [
        { "id": "witness", "name": "Witness Chain", "slug": "witness" }
      ],
      "bridges": [
        {
          "id": "witness-dac-bridge",
          "type": "DAC",
          "usedIn": [
            { "id": "witness", "name": "Witness Chain", "slug": "witness" }
          ],
          "createdAt": "1723211933",
          "contracts": {
            "addresses": [
              {
                "name": "WitnessValidium",
                "address": "0x42Ac57F24EC4C3AAC843f6DBAcd9282DAaeE9238",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x5132A183E9F3CB7C848b0AAC5Ae0c4f0491B7aB2"],
                  "implementations": [
                    "0x10D296e8aDd0535be71639E5D1d1c30ae1C6bD4C"
                  ]
                },
                "chain": "ethereum",
                "description": "The main contract of the WitnessValidium. Contains sequenced transaction batch hashes and signature verification logic for the signed data hash commitment."
              },
              {
                "name": "WitnessValidiumDAC",
                "address": "0xB0FD8Ba20B1C178b14Dd2a02f4e72c03fdA626f8",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x8cC10554B5C7D322E6a7F33CBb584c7C5fdBA039"],
                  "implementations": [
                    "0xD26B535AD58715C4c2ffFAC32908b13674533DAe"
                  ]
                },
                "chain": "ethereum",
                "description": "Validium committee contract that allows the admin to setup the members of the committee and stores the required amount of signatures threshold.",
                "upgradableBy": ["DACProxyAdminOwner"],
                "upgradeDelay": "No delay"
              }
            ],
            "risks": []
          },
          "permissions": [
            {
              "name": "Committee Members",
              "description": "List of addresses authorized to sign data commitments for the DA bridge.",
              "accounts": [
                {
                  "address": "0xcc543F5a2052eDf584216093A0547c4Acd84B80b",
                  "type": "EOA"
                },
                {
                  "address": "0xef5F06e5C0493601829DacFA23f2fe30303b0166",
                  "type": "EOA"
                }
              ]
            },
            {
              "name": "LocalAdmin",
              "accounts": [
                {
                  "address": "0xd0676f1Ee81d7C6fe9B0F2EEf9FF74C3E984f94b",
                  "type": "EOA"
                }
              ],
              "description": "Admin of the WitnessValidium contract, can set core system parameters like timeouts, sequencer, activate forced transactions and update the DA mode."
            },
            {
              "name": "DACProxyAdminOwner",
              "accounts": [
                {
                  "address": "0xb8605297399baEb6628C9E8F5D3E52A056492cfe",
                  "type": "EOA"
                }
              ],
              "description": "Owner of the WitnessValidiumDAC's ProxyAdmin. Can upgrade the contract."
            }
          ],
          "chain": 1,
          "requiredMembers": 1,
          "membersCount": 2,
          "transactionDataType": {
            "type": "TransactionData",
            "value": "Transaction data",
            "description": "TODO"
          },
          "display": {
            "name": "Witness Chain DAC",
            "slug": "dac",
            "description": "Witness Chain DAC on Ethereum.",
            "warning": null,
            "redWarning": "Only one signer is required to attest to the availability of the data.",
            "links": {
              "websites": ["https://witnesschain.com/"],
              "apps": ["https://witnesschain-bridge.eu-north-2.gateway.fm"],
              "documentation": ["https://docs.witnesschain.com/"],
              "explorers": [
                "https://witnesschain-blockscout.eu-north-2.gateway.fm/"
              ],
              "repositories": ["https://github.com/witnesschain-com"],
              "socialMedia": [
                "https://twitter.com/witnesschain",
                "https://discord.gg/HwnzU5CYDp",
                "https://docs.witnesschain.com/resources/technical-papers"
              ]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![polygoncdk bridge architecture](/images/da-bridge-technology/polygoncdk/architectureL2.png#center)\n    The DA commitments are posted to the L1 through the sequencer inbox, using the inbox as a DA bridge.\n    The DA commitment consists of a data availability message provided as transaction input, made up of a byte array containing the signatures and all the addresses of the committee in ascending order.\n    The sequencer distributes the data and collects signatures from Committee members offchain. Only the DA message is posted by the sequencer to the L1 chain inbox (the DA bridge).\n    A separate contract, the PolygonCommittee contract, is used to manage the committee members list and verify the signatures before accepting the DA commitment.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "1/2",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "degen-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": "Ethereum (blobs)",
      "hasChallengeMechanism": null,
      "display": {
        "name": "Degen Chain DAC",
        "slug": "degen",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://syndicate.io/blog/degen-chain"],
          "apps": ["https://bridge.degen.tips/", "https://degen.tips/"],
          "documentation": [
            "https://docs.syndicate.io/get-started/introduction"
          ],
          "explorers": ["https://explorer.degen.tips/"],
          "repositories": [],
          "socialMedia": [
            "https://twitter.com/degentokenbase",
            "https://warpcast.com/~/channel/degen"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![Anytrust architecture](/images/da-layer-technology/anytrust/architecture1.png#center)\n\n    The DAC uses a data availability solution built on the AnyTrust protocol. It is composed of the following components:\n    - **Sequencer Inbox**: Main entry point for the Sequencer submitting transaction batches.\n    - **Data Availability Committee (DAC)**: A group of members responsible for storing and providing data on demand.\n    - **Data Availability Certificate (DACert)**: A commitment ensuring that data blobs are available without needing full data posting on the L1 chain. \n\n    \n    Committee members run servers that support APIs for storing and retrieving data blobs. \n    The Sequencer API allows the rollup Sequencer to submit data blobs for storage, while the REST API enables anyone to fetch data by hash. \n    When the Sequencer produces a data batch, it sends the batch along with an expiration time to Committee members, who store it and sign it. \n    Once enough signatures are collected, the Sequencer aggregates them into a valid DACert and posts it to the L1 chain inbox. \n    If the Sequencer fails to collect enough signatures, it falls back to posting the full data to the L1 chain. \n\n\n    A DACert includes a hash of the data block, an expiration time, and proof that the required threshold of Committee members have signed off on the data. \n    The proof consists of a hash of the Keyset used in signing, a bitmap indicating which members signed, and a BLS aggregated signature. \n    L2 nodes reading from the sequencer inbox verify the certificate’s validity by checking the number of signers, the aggregated signature, and that the expiration time is at least two weeks ahead of the L2 timestamp. \n    If the DACert is valid, it provides a proof that the corresponding data is available from honest committee members.\n\n    ",
        "risks": null
      },
      "usedIn": [{ "id": "degen", "name": "Degen Chain", "slug": "degen" }],
      "bridges": [
        {
          "id": "degen-dac-bridge",
          "type": "DAC",
          "usedIn": [{ "id": "degen", "name": "Degen Chain", "slug": "degen" }],
          "createdAt": "1723211933",
          "contracts": {
            "addresses": [
              {
                "name": "SequencerInbox",
                "address": "0x6216dD1EE27C5aCEC7427052d3eCDc98E2bc2221",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0xFB48D385Fa3da33762B350e1d705b9E46054E677"],
                  "implementations": [
                    "0x98DB769A9E15D66EA04665da0dF616596c296BA8"
                  ]
                },
                "chain": "base",
                "description": "Main entry point for the Sequencer submitting transaction batches."
              }
            ],
            "risks": []
          },
          "permissions": [
            {
              "name": "Sequencers",
              "accounts": [
                {
                  "address": "0xa3582189403F67a9CDB1CE0Ac066c954FFd3f205",
                  "type": "EOA"
                }
              ],
              "description": "Central actors allowed to submit transaction batches to the Sequencer Inbox.",
              "chain": "base"
            },
            {
              "name": "RollupOwnerMultisig",
              "description": "This is a Gnosis Safe with 3 / 5 threshold.  It can update whether an address is authorized to be a batch poster at the sequencer inbox. The UpgradeExecutor retains the ability to update the batch poster manager (along with any batch posters).",
              "accounts": [
                {
                  "address": "0x7dCe2FEE5e30EFf298cD3d9B92649f00EBDfc104",
                  "type": "MultiSig"
                }
              ],
              "chain": "base",
              "references": null,
              "participants": [
                {
                  "address": "0x4D8007a0E9f293e62E2b0F43C6Cf4C4B9e135BAe",
                  "type": "EOA"
                },
                {
                  "address": "0x3840f487A17A41100DD1Bf0946c34f132a57Fd5f",
                  "type": "EOA"
                },
                {
                  "address": "0xa0C600a6e85bf225958FFAcC70B5FDDF9A059038",
                  "type": "EOA"
                },
                {
                  "address": "0xefCf0c8faFB425997870f845e26fC6cA6EE6dD5C",
                  "type": "EOA"
                },
                {
                  "address": "0xa4000bDD2bB92ce6750b31F1eeda47Bd1cB8e6e4",
                  "type": "EOA"
                }
              ]
            }
          ],
          "chain": 8453,
          "requiredMembers": 1,
          "membersCount": 1,
          "transactionDataType": {
            "type": "TransactionDataCompressed",
            "value": "Transaction data (compressed)",
            "description": "TODO"
          },
          "display": {
            "name": "Degen Chain DAC",
            "slug": "dac",
            "description": "Degen Chain DAC on Ethereum.",
            "warning": null,
            "redWarning": "Only one signer is required to attest to the availability of the data.",
            "links": {
              "websites": ["https://syndicate.io/blog/degen-chain"],
              "apps": ["https://bridge.degen.tips/", "https://degen.tips/"],
              "documentation": [
                "https://docs.syndicate.io/get-started/introduction"
              ],
              "explorers": ["https://explorer.degen.tips/"],
              "repositories": [],
              "socialMedia": [
                "https://twitter.com/degentokenbase",
                "https://warpcast.com/~/channel/degen"
              ]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![Anytrust bridge architecture](/images/da-bridge-technology/anytrust/architectureL3.png#center)\n\n\n    The DA commitments are posted to the L2 through the sequencer inbox, using the inbox as a DA bridge.\n    The DA commitment consists of Data Availability Certificate (DACert), including a hash of the data block, an expiration time, and a proof that the required threshold of Committee members have signed off on the data.\n    The sequencer distributes the data and collects signatures from Committee members offchain. Only the DACert is posted by the sequencer to the L2 chain inbox (the DA bridge), achieving L3 transaction ordering finality in a single onchain transaction.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "1/1",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "l3x-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": "Ethereum (blobs)",
      "hasChallengeMechanism": null,
      "display": {
        "name": "L3X DAC",
        "slug": "l3x",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://l3x.com/"],
          "apps": [
            "https://bridge.arbitrum.io/?destinationChain=l3x-network&sourceChain=arbitrum-one"
          ],
          "documentation": ["https://docs.l3x.com/"],
          "explorers": ["https://explorer.l3x.com/"],
          "repositories": [],
          "socialMedia": [
            "https://t.me/l3x_protocol",
            "https://x.com/l3x_protocol"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![Anytrust architecture](/images/da-layer-technology/anytrust/architecture1.png#center)\n\n    The DAC uses a data availability solution built on the AnyTrust protocol. It is composed of the following components:\n    - **Sequencer Inbox**: Main entry point for the Sequencer submitting transaction batches.\n    - **Data Availability Committee (DAC)**: A group of members responsible for storing and providing data on demand.\n    - **Data Availability Certificate (DACert)**: A commitment ensuring that data blobs are available without needing full data posting on the L1 chain. \n\n    \n    Committee members run servers that support APIs for storing and retrieving data blobs. \n    The Sequencer API allows the rollup Sequencer to submit data blobs for storage, while the REST API enables anyone to fetch data by hash. \n    When the Sequencer produces a data batch, it sends the batch along with an expiration time to Committee members, who store it and sign it. \n    Once enough signatures are collected, the Sequencer aggregates them into a valid DACert and posts it to the L1 chain inbox. \n    If the Sequencer fails to collect enough signatures, it falls back to posting the full data to the L1 chain. \n\n\n    A DACert includes a hash of the data block, an expiration time, and proof that the required threshold of Committee members have signed off on the data. \n    The proof consists of a hash of the Keyset used in signing, a bitmap indicating which members signed, and a BLS aggregated signature. \n    L2 nodes reading from the sequencer inbox verify the certificate’s validity by checking the number of signers, the aggregated signature, and that the expiration time is at least two weeks ahead of the L2 timestamp. \n    If the DACert is valid, it provides a proof that the corresponding data is available from honest committee members.\n\n    ",
        "risks": null
      },
      "usedIn": [{ "id": "l3x", "name": "L3X", "slug": "l3x" }],
      "bridges": [
        {
          "id": "l3x-dac-bridge",
          "type": "DAC",
          "usedIn": [{ "id": "l3x", "name": "L3X", "slug": "l3x" }],
          "createdAt": "1723211933",
          "contracts": {
            "addresses": [
              {
                "name": "SequencerInbox",
                "address": "0xB9450b512Fd3454e9C1a2593C5DF9E71344b5653",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x29994207C5AeDc83F27c5dc16E468f328832d42d"],
                  "implementations": [
                    "0x18ed2d5bF7c5943bFd20a2995b9879E30c9E8dDa"
                  ]
                },
                "chain": "arbitrum",
                "description": "Main entry point for the Sequencer submitting transaction batches."
              }
            ],
            "risks": []
          },
          "permissions": [
            {
              "name": "Sequencers",
              "accounts": [
                {
                  "address": "0xd987004738Ae33732ecf68613b1b7aFd1df7C11c",
                  "type": "EOA"
                }
              ],
              "description": "Central actors allowed to submit transaction batches to the Sequencer Inbox.",
              "chain": "arbitrum"
            },
            {
              "name": "RollupOwner",
              "accounts": [
                {
                  "address": "0x5e31608B400F45846043E93747D72A1a02c5a2f5",
                  "type": "EOA"
                }
              ],
              "description": "Multisig that can upgrade authorized batch posters via the UpgradeExecutor contract."
            }
          ],
          "chain": 42161,
          "requiredMembers": 1,
          "membersCount": 1,
          "transactionDataType": {
            "type": "TransactionDataCompressed",
            "value": "Transaction data (compressed)",
            "description": "TODO"
          },
          "display": {
            "name": "L3X DAC",
            "slug": "dac",
            "description": "L3X DAC on Ethereum.",
            "warning": null,
            "redWarning": "Only one signer is required to attest to the availability of the data.",
            "links": {
              "websites": ["https://l3x.com/"],
              "apps": [
                "https://bridge.arbitrum.io/?destinationChain=l3x-network&sourceChain=arbitrum-one"
              ],
              "documentation": ["https://docs.l3x.com/"],
              "explorers": ["https://explorer.l3x.com/"],
              "repositories": [],
              "socialMedia": [
                "https://t.me/l3x_protocol",
                "https://x.com/l3x_protocol"
              ]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![Anytrust bridge architecture](/images/da-bridge-technology/anytrust/architectureL3.png#center)\n\n\n    The DA commitments are posted to the L2 through the sequencer inbox, using the inbox as a DA bridge.\n    The DA commitment consists of Data Availability Certificate (DACert), including a hash of the data block, an expiration time, and a proof that the required threshold of Committee members have signed off on the data.\n    The sequencer distributes the data and collects signatures from Committee members offchain. Only the DACert is posted by the sequencer to the L2 chain inbox (the DA bridge), achieving L3 transaction ordering finality in a single onchain transaction.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "1/1",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "molten-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": "Ethereum (blobs)",
      "hasChallengeMechanism": null,
      "display": {
        "name": "Molten Network DAC",
        "slug": "molten",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://moltennetwork.com/"],
          "apps": [
            "https://molten.calderabridge.xyz/",
            "https://leverage.unidex.exchange/"
          ],
          "documentation": ["https://docs.unidex.exchange/appchain/markdown"],
          "explorers": ["https://molten.calderaexplorer.xyz"],
          "repositories": [],
          "socialMedia": [
            "https://x.com/moltenl3",
            "https://discord.gg/moltennetwork",
            "https://mirror.xyz/unidexexchange.eth",
            "https://t.me/unidexfinance"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![Anytrust architecture](/images/da-layer-technology/anytrust/architecture1.png#center)\n\n    The DAC uses a data availability solution built on the AnyTrust protocol. It is composed of the following components:\n    - **Sequencer Inbox**: Main entry point for the Sequencer submitting transaction batches.\n    - **Data Availability Committee (DAC)**: A group of members responsible for storing and providing data on demand.\n    - **Data Availability Certificate (DACert)**: A commitment ensuring that data blobs are available without needing full data posting on the L1 chain. \n\n    \n    Committee members run servers that support APIs for storing and retrieving data blobs. \n    The Sequencer API allows the rollup Sequencer to submit data blobs for storage, while the REST API enables anyone to fetch data by hash. \n    When the Sequencer produces a data batch, it sends the batch along with an expiration time to Committee members, who store it and sign it. \n    Once enough signatures are collected, the Sequencer aggregates them into a valid DACert and posts it to the L1 chain inbox. \n    If the Sequencer fails to collect enough signatures, it falls back to posting the full data to the L1 chain. \n\n\n    A DACert includes a hash of the data block, an expiration time, and proof that the required threshold of Committee members have signed off on the data. \n    The proof consists of a hash of the Keyset used in signing, a bitmap indicating which members signed, and a BLS aggregated signature. \n    L2 nodes reading from the sequencer inbox verify the certificate’s validity by checking the number of signers, the aggregated signature, and that the expiration time is at least two weeks ahead of the L2 timestamp. \n    If the DACert is valid, it provides a proof that the corresponding data is available from honest committee members.\n\n    ",
        "risks": null
      },
      "usedIn": [
        { "id": "molten", "name": "Molten Network", "slug": "molten" }
      ],
      "bridges": [
        {
          "id": "molten-dac-bridge",
          "type": "DAC",
          "usedIn": [
            { "id": "molten", "name": "Molten Network", "slug": "molten" }
          ],
          "createdAt": "1723211933",
          "contracts": {
            "addresses": [
              {
                "name": "SequencerInbox",
                "address": "0x0fFe9ACC296ddd4De5F616Aa482C99fA4b41A3E2",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x8Ab2f49A085490c1592325eE32B6e6a4DA35D238"],
                  "implementations": [
                    "0x1d182075d07744D71E37f77f1654165f6DAFad08"
                  ]
                },
                "chain": "arbitrum",
                "description": "Main entry point for the Sequencer submitting transaction batches."
              }
            ],
            "risks": []
          },
          "permissions": [
            {
              "name": "Sequencers",
              "accounts": [
                {
                  "address": "0x451f05C41BC5CC10d7D63ed88bA0A522FE183074",
                  "type": "EOA"
                }
              ],
              "description": "Central actors allowed to submit transaction batches to the Sequencer Inbox.",
              "chain": "arbitrum"
            },
            {
              "name": "RollupOwner",
              "accounts": [
                {
                  "address": "0x6FD149B3d41fd860B9Da1A6fE54e902eF41F68BF",
                  "type": "MultiSig"
                }
              ],
              "description": "Multisig that can upgrade authorized batch posters via the UpgradeExecutor contract."
            }
          ],
          "chain": 42161,
          "requiredMembers": 1,
          "membersCount": 1,
          "transactionDataType": {
            "type": "TransactionDataCompressed",
            "value": "Transaction data (compressed)",
            "description": "TODO"
          },
          "display": {
            "name": "Molten Network DAC",
            "slug": "dac",
            "description": "Molten Network DAC on Ethereum.",
            "warning": null,
            "redWarning": "Only one signer is required to attest to the availability of the data.",
            "links": {
              "websites": ["https://moltennetwork.com/"],
              "apps": [
                "https://molten.calderabridge.xyz/",
                "https://leverage.unidex.exchange/"
              ],
              "documentation": [
                "https://docs.unidex.exchange/appchain/markdown"
              ],
              "explorers": ["https://molten.calderaexplorer.xyz"],
              "repositories": [],
              "socialMedia": [
                "https://x.com/moltenl3",
                "https://discord.gg/moltennetwork",
                "https://mirror.xyz/unidexexchange.eth",
                "https://t.me/unidexfinance"
              ]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![Anytrust bridge architecture](/images/da-bridge-technology/anytrust/architectureL3.png#center)\n\n\n    The DA commitments are posted to the L2 through the sequencer inbox, using the inbox as a DA bridge.\n    The DA commitment consists of Data Availability Certificate (DACert), including a hash of the data block, an expiration time, and a proof that the required threshold of Committee members have signed off on the data.\n    The sequencer distributes the data and collects signatures from Committee members offchain. Only the DACert is posted by the sequencer to the L2 chain inbox (the DA bridge), achieving L3 transaction ordering finality in a single onchain transaction.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "1/1",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "playblock-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": "Ethereum (blobs)",
      "hasChallengeMechanism": null,
      "display": {
        "name": "PlayBlock DAC",
        "slug": "playblock",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://playnance.com/"],
          "apps": [],
          "documentation": [],
          "explorers": ["https://explorer.playblock.io/"],
          "repositories": ["https://github.com/playnance-games/PlayBlock"],
          "socialMedia": ["https://twitter.com/Playnancetech"]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![Anytrust architecture](/images/da-layer-technology/anytrust/architecture2.png#center)\n\n    The DAC uses a data availability solution built on the AnyTrust protocol. It is composed of the following components:\n    - **Sequencer Inbox**: Main entry point for the Sequencer submitting transaction batches.\n    - **Data Availability Committee (DAC)**: A group of members responsible for storing and providing data on demand.\n    - **Data Availability Certificate (DACert)**: A commitment ensuring that data blobs are available without needing full data posting on the L1 chain. \n\n    \n    Committee members run servers that support APIs for storing and retrieving data blobs. \n    The Sequencer API allows the rollup Sequencer to submit data blobs for storage, while the REST API enables anyone to fetch data by hash. \n    When the Sequencer produces a data batch, it sends the batch along with an expiration time to Committee members, who store it and sign it. \n    Once enough signatures are collected, the Sequencer aggregates them into a valid DACert and posts it to the L1 chain inbox. \n    If the Sequencer fails to collect enough signatures, it falls back to posting the full data to the L1 chain. \n\n\n    A DACert includes a hash of the data block, an expiration time, and proof that the required threshold of Committee members have signed off on the data. \n    The proof consists of a hash of the Keyset used in signing, a bitmap indicating which members signed, and a BLS aggregated signature. \n    L2 nodes reading from the sequencer inbox verify the certificate’s validity by checking the number of signers, the aggregated signature, and that the expiration time is at least two weeks ahead of the L2 timestamp. \n    If the DACert is valid, it provides a proof that the corresponding data is available from honest committee members.\n\n    ",
        "risks": null
      },
      "usedIn": [
        { "id": "playblock", "name": "PlayBlock", "slug": "playblock" }
      ],
      "bridges": [
        {
          "id": "playblock-dac-bridge",
          "type": "DAC",
          "usedIn": [
            { "id": "playblock", "name": "PlayBlock", "slug": "playblock" }
          ],
          "createdAt": "1723211933",
          "contracts": {
            "addresses": [
              {
                "name": "SequencerInbox",
                "address": "0xe347C1223381b9Dcd6c0F61cf81c90175A7Bae77",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x27C7Bfd2cC11429e9b80c443b42FDBe4754F6c91"],
                  "implementations": [
                    "0x1c6ACCd9d66f3B993928E7439c9A2d67b94a445F"
                  ]
                },
                "chain": "nova",
                "description": "Main entry point for the Sequencer submitting transaction batches."
              }
            ],
            "risks": []
          },
          "permissions": [
            {
              "name": "Sequencers",
              "accounts": [
                {
                  "address": "0xe603d3FcB75b0Af72F0e616d002091109d7ECc5b",
                  "type": "EOA"
                }
              ],
              "description": "Central actors allowed to submit transaction batches to the Sequencer Inbox.",
              "chain": "nova"
            },
            {
              "name": "RollupOwner",
              "accounts": [
                {
                  "address": "0x10Fe3cb853F7ef551E1598d91436e95d41Aea45a",
                  "type": "EOA"
                }
              ],
              "description": "Multisig that can upgrade authorized batch posters via the UpgradeExecutor contract."
            }
          ],
          "chain": 42170,
          "requiredMembers": 1,
          "membersCount": 2,
          "transactionDataType": {
            "type": "TransactionDataCompressed",
            "value": "Transaction data (compressed)",
            "description": "TODO"
          },
          "display": {
            "name": "PlayBlock DAC",
            "slug": "dac",
            "description": "PlayBlock DAC on Ethereum.",
            "warning": null,
            "redWarning": "Only one signer is required to attest to the availability of the data.",
            "links": {
              "websites": ["https://playnance.com/"],
              "apps": [],
              "documentation": [],
              "explorers": ["https://explorer.playblock.io/"],
              "repositories": ["https://github.com/playnance-games/PlayBlock"],
              "socialMedia": ["https://twitter.com/Playnancetech"]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![Anytrust bridge architecture](/images/da-bridge-technology/anytrust/architectureL3.png#center)\n\n\n    The DA commitments are posted to the L2 through the sequencer inbox, using the inbox as a DA bridge.\n    The DA commitment consists of Data Availability Certificate (DACert), including a hash of the data block, an expiration time, and a proof that the required threshold of Committee members have signed off on the data.\n    The sequencer distributes the data and collects signatures from Committee members offchain. Only the DACert is posted by the sequencer to the L2 chain inbox (the DA bridge), achieving L3 transaction ordering finality in a single onchain transaction.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "1/2",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "popapex-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": "Ethereum (blobs)",
      "hasChallengeMechanism": null,
      "display": {
        "name": "Proof of Play Apex DAC",
        "slug": "popapex",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://proofofplay.com/"],
          "apps": [
            "https://bridge.arbitrum.io/?destinationChain=pop-apex&sourceChain=arbitrum-one",
            "https://piratenation.game/"
          ],
          "documentation": [],
          "explorers": ["https://explorer.apex.proofofplay.com"],
          "repositories": ["https://github.com/proofofplay"],
          "socialMedia": [
            "https://twitter.com/ProofOfPlay/",
            "https://discord.com/invite/piratenation",
            "https://piratenation.medium.com/"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![Anytrust architecture](/images/da-layer-technology/anytrust/architecture1.png#center)\n\n    The DAC uses a data availability solution built on the AnyTrust protocol. It is composed of the following components:\n    - **Sequencer Inbox**: Main entry point for the Sequencer submitting transaction batches.\n    - **Data Availability Committee (DAC)**: A group of members responsible for storing and providing data on demand.\n    - **Data Availability Certificate (DACert)**: A commitment ensuring that data blobs are available without needing full data posting on the L1 chain. \n\n    \n    Committee members run servers that support APIs for storing and retrieving data blobs. \n    The Sequencer API allows the rollup Sequencer to submit data blobs for storage, while the REST API enables anyone to fetch data by hash. \n    When the Sequencer produces a data batch, it sends the batch along with an expiration time to Committee members, who store it and sign it. \n    Once enough signatures are collected, the Sequencer aggregates them into a valid DACert and posts it to the L1 chain inbox. \n    If the Sequencer fails to collect enough signatures, it falls back to posting the full data to the L1 chain. \n\n\n    A DACert includes a hash of the data block, an expiration time, and proof that the required threshold of Committee members have signed off on the data. \n    The proof consists of a hash of the Keyset used in signing, a bitmap indicating which members signed, and a BLS aggregated signature. \n    L2 nodes reading from the sequencer inbox verify the certificate’s validity by checking the number of signers, the aggregated signature, and that the expiration time is at least two weeks ahead of the L2 timestamp. \n    If the DACert is valid, it provides a proof that the corresponding data is available from honest committee members.\n\n    ",
        "risks": null
      },
      "usedIn": [
        { "id": "popapex", "name": "Proof of Play Apex", "slug": "popapex" }
      ],
      "bridges": [
        {
          "id": "popapex-dac-bridge",
          "type": "DAC",
          "usedIn": [
            { "id": "popapex", "name": "Proof of Play Apex", "slug": "popapex" }
          ],
          "createdAt": "1723211933",
          "contracts": {
            "addresses": [
              {
                "name": "SequencerInbox",
                "address": "0xa58F38102579dAE7C584850780dDA55744f67DF1",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0xCC6f49cff395c4d160C61112522700dcB007c41d"],
                  "implementations": [
                    "0x1c6ACCd9d66f3B993928E7439c9A2d67b94a445F"
                  ]
                },
                "chain": "arbitrum",
                "description": "Main entry point for the Sequencer submitting transaction batches."
              }
            ],
            "risks": []
          },
          "permissions": [
            {
              "name": "Sequencers",
              "accounts": [
                {
                  "address": "0x139aC582825DD6A9b9D6A6a64f1bE149C84e0d03",
                  "type": "EOA"
                }
              ],
              "description": "Central actors allowed to submit transaction batches to the Sequencer Inbox.",
              "chain": "arbitrum"
            },
            {
              "name": "RollupOwner",
              "accounts": [
                {
                  "address": "0x79C2abE3eBA9dc119318FdAaA48118e1CDB53F56",
                  "type": "MultiSig"
                }
              ],
              "description": "Multisig that can upgrade authorized batch posters via the UpgradeExecutor contract."
            }
          ],
          "chain": 42161,
          "requiredMembers": 1,
          "membersCount": 1,
          "transactionDataType": {
            "type": "TransactionDataCompressed",
            "value": "Transaction data (compressed)",
            "description": "TODO"
          },
          "display": {
            "name": "Proof of Play Apex DAC",
            "slug": "dac",
            "description": "Proof of Play Apex DAC on Ethereum.",
            "warning": null,
            "redWarning": "Only one signer is required to attest to the availability of the data.",
            "links": {
              "websites": ["https://proofofplay.com/"],
              "apps": [
                "https://bridge.arbitrum.io/?destinationChain=pop-apex&sourceChain=arbitrum-one",
                "https://piratenation.game/"
              ],
              "documentation": [],
              "explorers": ["https://explorer.apex.proofofplay.com"],
              "repositories": ["https://github.com/proofofplay"],
              "socialMedia": [
                "https://twitter.com/ProofOfPlay/",
                "https://discord.com/invite/piratenation",
                "https://piratenation.medium.com/"
              ]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![Anytrust bridge architecture](/images/da-bridge-technology/anytrust/architectureL3.png#center)\n\n\n    The DA commitments are posted to the L2 through the sequencer inbox, using the inbox as a DA bridge.\n    The DA commitment consists of Data Availability Certificate (DACert), including a hash of the data block, an expiration time, and a proof that the required threshold of Committee members have signed off on the data.\n    The sequencer distributes the data and collects signatures from Committee members offchain. Only the DACert is posted by the sequencer to the L2 chain inbox (the DA bridge), achieving L3 transaction ordering finality in a single onchain transaction.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "1/1",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "popboss-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": "Ethereum (blobs)",
      "hasChallengeMechanism": null,
      "display": {
        "name": "Proof of Play Boss DAC",
        "slug": "popboss",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://proofofplay.com/"],
          "apps": [
            "https://bridge.arbitrum.io/?destinationChain=pop-boss&sourceChain=arbitrum-one",
            "https://piratenation.game/"
          ],
          "documentation": [],
          "explorers": ["https://explorer.boss.proofofplay.com"],
          "repositories": ["https://github.com/proofofplay"],
          "socialMedia": [
            "https://x.com/ProofOfPlay/",
            "https://discord.com/invite/piratenation",
            "https://piratenation.medium.com/"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![Anytrust architecture](/images/da-layer-technology/anytrust/architecture1.png#center)\n\n    The DAC uses a data availability solution built on the AnyTrust protocol. It is composed of the following components:\n    - **Sequencer Inbox**: Main entry point for the Sequencer submitting transaction batches.\n    - **Data Availability Committee (DAC)**: A group of members responsible for storing and providing data on demand.\n    - **Data Availability Certificate (DACert)**: A commitment ensuring that data blobs are available without needing full data posting on the L1 chain. \n\n    \n    Committee members run servers that support APIs for storing and retrieving data blobs. \n    The Sequencer API allows the rollup Sequencer to submit data blobs for storage, while the REST API enables anyone to fetch data by hash. \n    When the Sequencer produces a data batch, it sends the batch along with an expiration time to Committee members, who store it and sign it. \n    Once enough signatures are collected, the Sequencer aggregates them into a valid DACert and posts it to the L1 chain inbox. \n    If the Sequencer fails to collect enough signatures, it falls back to posting the full data to the L1 chain. \n\n\n    A DACert includes a hash of the data block, an expiration time, and proof that the required threshold of Committee members have signed off on the data. \n    The proof consists of a hash of the Keyset used in signing, a bitmap indicating which members signed, and a BLS aggregated signature. \n    L2 nodes reading from the sequencer inbox verify the certificate’s validity by checking the number of signers, the aggregated signature, and that the expiration time is at least two weeks ahead of the L2 timestamp. \n    If the DACert is valid, it provides a proof that the corresponding data is available from honest committee members.\n\n    ",
        "risks": null
      },
      "usedIn": [
        { "id": "popboss", "name": "Proof of Play Boss", "slug": "popboss" }
      ],
      "bridges": [
        {
          "id": "popboss-dac-bridge",
          "type": "DAC",
          "usedIn": [
            { "id": "popboss", "name": "Proof of Play Boss", "slug": "popboss" }
          ],
          "createdAt": "1723211933",
          "contracts": {
            "addresses": [
              {
                "name": "SequencerInbox",
                "address": "0x6eE94AD8057Fd7Ba4d47bb6278a261c8a9FD4E3f",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x490C4c92Ea9FF02EE8277222C66afD80Bfb1b7c1"],
                  "implementations": [
                    "0x18ed2d5bF7c5943bFd20a2995b9879E30c9E8dDa"
                  ]
                },
                "chain": "arbitrum",
                "description": "Main entry point for the Sequencer submitting transaction batches."
              }
            ],
            "risks": []
          },
          "permissions": [
            {
              "name": "Sequencers",
              "accounts": [
                {
                  "address": "0x75EFAE926BcB72433C70fbfA76588F16338397De",
                  "type": "EOA"
                }
              ],
              "description": "Central actors allowed to submit transaction batches to the Sequencer Inbox.",
              "chain": "arbitrum"
            },
            {
              "name": "RollupOwner",
              "accounts": [
                {
                  "address": "0x79C2abE3eBA9dc119318FdAaA48118e1CDB53F56",
                  "type": "MultiSig"
                }
              ],
              "description": "Multisig that can upgrade authorized batch posters via the UpgradeExecutor contract."
            }
          ],
          "chain": 42161,
          "requiredMembers": 1,
          "membersCount": 1,
          "transactionDataType": {
            "type": "TransactionDataCompressed",
            "value": "Transaction data (compressed)",
            "description": "TODO"
          },
          "display": {
            "name": "Proof of Play Boss DAC",
            "slug": "dac",
            "description": "Proof of Play Boss DAC on Ethereum.",
            "warning": null,
            "redWarning": "Only one signer is required to attest to the availability of the data.",
            "links": {
              "websites": ["https://proofofplay.com/"],
              "apps": [
                "https://bridge.arbitrum.io/?destinationChain=pop-boss&sourceChain=arbitrum-one",
                "https://piratenation.game/"
              ],
              "documentation": [],
              "explorers": ["https://explorer.boss.proofofplay.com"],
              "repositories": ["https://github.com/proofofplay"],
              "socialMedia": [
                "https://x.com/ProofOfPlay/",
                "https://discord.com/invite/piratenation",
                "https://piratenation.medium.com/"
              ]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![Anytrust bridge architecture](/images/da-bridge-technology/anytrust/architectureL3.png#center)\n\n\n    The DA commitments are posted to the L2 through the sequencer inbox, using the inbox as a DA bridge.\n    The DA commitment consists of Data Availability Certificate (DACert), including a hash of the data block, an expiration time, and a proof that the required threshold of Committee members have signed off on the data.\n    The sequencer distributes the data and collects signatures from Committee members offchain. Only the DACert is posted by the sequencer to the L2 chain inbox (the DA bridge), achieving L3 transaction ordering finality in a single onchain transaction.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "1/1",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "rari-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": "Ethereum (blobs)",
      "hasChallengeMechanism": null,
      "display": {
        "name": "RARI Chain DAC",
        "slug": "rari",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://rarichain.org/"],
          "apps": [
            "https://bridge.arbitrum.io/?destinationChain=rari-mainnet&sourceChain=arbitrum-one"
          ],
          "documentation": ["https://rari.docs.caldera.dev/"],
          "explorers": ["https://mainnet.explorer.rarichain.org/"],
          "repositories": ["https://github.com/OffchainLabs/nitro"],
          "socialMedia": ["https://twitter.com/RariChain"]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![Anytrust architecture](/images/da-layer-technology/anytrust/architecture1.png#center)\n\n    The DAC uses a data availability solution built on the AnyTrust protocol. It is composed of the following components:\n    - **Sequencer Inbox**: Main entry point for the Sequencer submitting transaction batches.\n    - **Data Availability Committee (DAC)**: A group of members responsible for storing and providing data on demand.\n    - **Data Availability Certificate (DACert)**: A commitment ensuring that data blobs are available without needing full data posting on the L1 chain. \n\n    \n    Committee members run servers that support APIs for storing and retrieving data blobs. \n    The Sequencer API allows the rollup Sequencer to submit data blobs for storage, while the REST API enables anyone to fetch data by hash. \n    When the Sequencer produces a data batch, it sends the batch along with an expiration time to Committee members, who store it and sign it. \n    Once enough signatures are collected, the Sequencer aggregates them into a valid DACert and posts it to the L1 chain inbox. \n    If the Sequencer fails to collect enough signatures, it falls back to posting the full data to the L1 chain. \n\n\n    A DACert includes a hash of the data block, an expiration time, and proof that the required threshold of Committee members have signed off on the data. \n    The proof consists of a hash of the Keyset used in signing, a bitmap indicating which members signed, and a BLS aggregated signature. \n    L2 nodes reading from the sequencer inbox verify the certificate’s validity by checking the number of signers, the aggregated signature, and that the expiration time is at least two weeks ahead of the L2 timestamp. \n    If the DACert is valid, it provides a proof that the corresponding data is available from honest committee members.\n\n    ",
        "risks": null
      },
      "usedIn": [{ "id": "rari", "name": "RARI Chain", "slug": "rari" }],
      "bridges": [
        {
          "id": "rari-dac-bridge",
          "type": "DAC",
          "usedIn": [{ "id": "rari", "name": "RARI Chain", "slug": "rari" }],
          "createdAt": "1723211933",
          "contracts": {
            "addresses": [
              {
                "name": "SequencerInbox",
                "address": "0xA436f1867adD490BF1530c636f2FB090758bB6B3",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x003e70B041abb993006C03E56c8515622a02928C"],
                  "implementations": [
                    "0x1d182075d07744D71E37f77f1654165f6DAFad08"
                  ]
                },
                "chain": "arbitrum",
                "description": "Main entry point for the Sequencer submitting transaction batches."
              }
            ],
            "risks": []
          },
          "permissions": [
            {
              "name": "Sequencers",
              "accounts": [
                {
                  "address": "0x974533F82B7BADF54Fb91C15f07F3f095e35321C",
                  "type": "EOA"
                }
              ],
              "description": "Central actors allowed to submit transaction batches to the Sequencer Inbox.",
              "chain": "arbitrum"
            },
            {
              "name": "RollupOwner",
              "accounts": [
                {
                  "address": "0x6FD149B3d41fd860B9Da1A6fE54e902eF41F68BF",
                  "type": "MultiSig"
                }
              ],
              "description": "Multisig that can upgrade authorized batch posters via the UpgradeExecutor contract."
            }
          ],
          "chain": 42161,
          "requiredMembers": 1,
          "membersCount": 1,
          "transactionDataType": {
            "type": "TransactionDataCompressed",
            "value": "Transaction data (compressed)",
            "description": "TODO"
          },
          "display": {
            "name": "RARI Chain DAC",
            "slug": "dac",
            "description": "RARI Chain DAC on Ethereum.",
            "warning": null,
            "redWarning": "Only one signer is required to attest to the availability of the data.",
            "links": {
              "websites": ["https://rarichain.org/"],
              "apps": [
                "https://bridge.arbitrum.io/?destinationChain=rari-mainnet&sourceChain=arbitrum-one"
              ],
              "documentation": ["https://rari.docs.caldera.dev/"],
              "explorers": ["https://mainnet.explorer.rarichain.org/"],
              "repositories": ["https://github.com/OffchainLabs/nitro"],
              "socialMedia": ["https://twitter.com/RariChain"]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![Anytrust bridge architecture](/images/da-bridge-technology/anytrust/architectureL3.png#center)\n\n\n    The DA commitments are posted to the L2 through the sequencer inbox, using the inbox as a DA bridge.\n    The DA commitment consists of Data Availability Certificate (DACert), including a hash of the data block, an expiration time, and a proof that the required threshold of Committee members have signed off on the data.\n    The sequencer distributes the data and collects signatures from Committee members offchain. Only the DACert is posted by the sequencer to the L2 chain inbox (the DA bridge), achieving L3 transaction ordering finality in a single onchain transaction.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "1/1",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "xai-dac-layer",
      "kind": "DAC",
      "type": "DaLayer",
      "systemCategory": "custom",
      "fallback": "Ethereum (blobs)",
      "hasChallengeMechanism": null,
      "display": {
        "name": "Xai DAC",
        "slug": "xai",
        "description": "Set of parties responsible for signing and attesting to the availability of data.",
        "links": {
          "websites": ["https://xai.games/"],
          "apps": [],
          "documentation": ["https://xai-foundation.gitbook.io/xai-network/"],
          "explorers": ["https://explorer.xai-chain.net/"],
          "repositories": ["https://github.com/OffchainLabs/nitro"],
          "socialMedia": [
            "https://twitter.com/xai_games",
            "https://t.me/XaiSentryNodes",
            "https://discord.gg/xaigames"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    ![Anytrust architecture](/images/da-layer-technology/anytrust/architecture7.png#center)\n\n    The DAC uses a data availability solution built on the AnyTrust protocol. It is composed of the following components:\n    - **Sequencer Inbox**: Main entry point for the Sequencer submitting transaction batches.\n    - **Data Availability Committee (DAC)**: A group of members responsible for storing and providing data on demand.\n    - **Data Availability Certificate (DACert)**: A commitment ensuring that data blobs are available without needing full data posting on the L1 chain. \n\n    \n    Committee members run servers that support APIs for storing and retrieving data blobs. \n    The Sequencer API allows the rollup Sequencer to submit data blobs for storage, while the REST API enables anyone to fetch data by hash. \n    When the Sequencer produces a data batch, it sends the batch along with an expiration time to Committee members, who store it and sign it. \n    Once enough signatures are collected, the Sequencer aggregates them into a valid DACert and posts it to the L1 chain inbox. \n    If the Sequencer fails to collect enough signatures, it falls back to posting the full data to the L1 chain. \n\n\n    A DACert includes a hash of the data block, an expiration time, and proof that the required threshold of Committee members have signed off on the data. \n    The proof consists of a hash of the Keyset used in signing, a bitmap indicating which members signed, and a BLS aggregated signature. \n    L2 nodes reading from the sequencer inbox verify the certificate’s validity by checking the number of signers, the aggregated signature, and that the expiration time is at least two weeks ahead of the L2 timestamp. \n    If the DACert is valid, it provides a proof that the corresponding data is available from honest committee members.\n\n    ",
        "risks": null
      },
      "usedIn": [{ "id": "xai", "name": "Xai", "slug": "xai" }],
      "bridges": [
        {
          "id": "xai-dac-bridge",
          "type": "DAC",
          "usedIn": [{ "id": "xai", "name": "Xai", "slug": "xai" }],
          "createdAt": "1723211933",
          "contracts": {
            "addresses": [
              {
                "name": "SequencerInbox",
                "address": "0x995a9d3ca121D48d21087eDE20bc8acb2398c8B1",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x041F85dD87c46B941dc9b15c6628B19ee5358485"],
                  "implementations": [
                    "0x7a299aD29499736994Aa3a9aFa3f476445FAEB2c"
                  ]
                },
                "chain": "arbitrum",
                "description": "Main entry point for the Sequencer submitting transaction batches."
              }
            ],
            "risks": []
          },
          "permissions": [
            {
              "name": "Sequencers",
              "accounts": [
                {
                  "address": "0x7F68dba68E72a250004812fe04F1123Fca89aBa9",
                  "type": "EOA"
                }
              ],
              "description": "Central actors allowed to submit transaction batches to the Sequencer Inbox.",
              "chain": "arbitrum"
            },
            {
              "name": "RollupOwner",
              "accounts": [
                {
                  "address": "0x4972A8EF186Ee42A14Cdd3c47f52ec06a6dc495E",
                  "type": "MultiSig"
                }
              ],
              "description": "Multisig that can upgrade authorized batch posters via the UpgradeExecutor contract."
            }
          ],
          "chain": 42161,
          "requiredMembers": 5,
          "membersCount": 7,
          "transactionDataType": {
            "type": "TransactionDataCompressed",
            "value": "Transaction data (compressed)",
            "description": "TODO"
          },
          "knownMembers": [
            {
              "external": false,
              "name": "Xai",
              "href": "https://xai-foundation.gitbook.io/xai-network/about-xai/xai-protocol/anytrust-revolutionizing-blockchain-infrastructure/data-availability-servers-das"
            },
            {
              "external": true,
              "name": "Ex Populus",
              "href": "https://xai-foundation.gitbook.io/xai-network/about-xai/xai-protocol/anytrust-revolutionizing-blockchain-infrastructure/data-availability-servers-das"
            },
            {
              "external": true,
              "name": "Rug Radio",
              "href": "https://xai-foundation.gitbook.io/xai-network/about-xai/xai-protocol/anytrust-revolutionizing-blockchain-infrastructure/data-availability-servers-das"
            },
            {
              "external": true,
              "name": "LayerZero",
              "href": "https://xai-foundation.gitbook.io/xai-network/about-xai/xai-protocol/anytrust-revolutionizing-blockchain-infrastructure/data-availability-servers-das"
            },
            {
              "external": true,
              "name": "Team Secret",
              "href": "https://xai-foundation.gitbook.io/xai-network/about-xai/xai-protocol/anytrust-revolutionizing-blockchain-infrastructure/data-availability-servers-das"
            },
            {
              "external": true,
              "name": "Offchain Labs",
              "href": "https://xai-foundation.gitbook.io/xai-network/about-xai/xai-protocol/anytrust-revolutionizing-blockchain-infrastructure/data-availability-servers-das"
            }
          ],
          "display": {
            "name": "Xai DAC",
            "slug": "dac",
            "description": "Xai DAC on Ethereum.",
            "warning": null,
            "redWarning": null,
            "links": {
              "websites": ["https://xai.games/"],
              "apps": [],
              "documentation": [
                "https://xai-foundation.gitbook.io/xai-network/"
              ],
              "explorers": ["https://explorer.xai-chain.net/"],
              "repositories": ["https://github.com/OffchainLabs/nitro"],
              "socialMedia": [
                "https://twitter.com/xai_games",
                "https://t.me/XaiSentryNodes",
                "https://discord.gg/xaigames"
              ]
            }
          },
          "technology": {
            "description": "\n    ## DA Bridge Architecture\n    ![Anytrust bridge architecture](/images/da-bridge-technology/anytrust/architectureL3.png#center)\n\n\n    The DA commitments are posted to the L2 through the sequencer inbox, using the inbox as a DA bridge.\n    The DA commitment consists of Data Availability Certificate (DACert), including a hash of the data block, an expiration time, and a proof that the required threshold of Committee members have signed off on the data.\n    The sequencer distributes the data and collects signatures from Committee members offchain. Only the DACert is posted by the sequencer to the L2 chain inbox (the DA bridge), achieving L3 transaction ordering finality in a single onchain transaction.\n    ",
            "risks": null
          },
          "risks": {
            "committeeSecurity": {
              "type": "Auto",
              "value": "5/7",
              "sentiment": "bad",
              "description": "TODO"
            },
            "upgradeability": {
              "type": "Immutable",
              "value": "∞",
              "sentiment": "good",
              "description": "The bridge smart contract is immutable and cannot be updated."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "otherConsiderations": null
        }
      ],
      "risks": {
        "economicSecurity": {
          "type": "OffChainVerifiable",
          "value": "Public committee",
          "sentiment": "warning",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack. The committee members are publicly known, and their reputation is at stake should they behave maliciously."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "otherConsiderations": null
    },
    {
      "id": "avail",
      "type": "DaLayer",
      "kind": "PublicBlockchain",
      "systemCategory": "public",
      "display": {
        "name": "Avail",
        "slug": "avail",
        "description": "Avail is a data availability network.",
        "links": {
          "websites": ["https://www.availproject.org/"],
          "documentation": ["https://docs.availproject.org/"],
          "repositories": ["https://github.com/availproject/"],
          "apps": ["https://bridge.availproject.org/"],
          "explorers": [
            "https://explorer.avail.so/#/explorer",
            "https://avail.subscan.io/"
          ],
          "socialMedia": [
            "https://x.com/AvailProject",
            "https://t.me/AvailCommunity",
            "https://discord.com/invite/y6fHnxZQX8",
            "https://www.linkedin.com/company/availproject/"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n\n    ![Avail architecture](/images/da-layer-technology/avail/architecture.png#center)\n\n\n    ## Consensus\n    Avail implements a Nominated Proof-of-Stake (NPoS) Sybil resistance mechanism, combined with the BABE/GRANDPA consensus protocol. \n    BABE handles block production by assigning block production slots according to validators' stake and using a Verifiable Random Function (VRF). \n    At the start of each epoch, nodes run the Block-Production-Lottery algorithm to assign block production slots and share the results with other nodes. \n    Slots are randomly assigned, meaning multiple validators might be selected for the same slot (with a 'race' determining who gets to propose the block) and some slots may remain empty. \n    To ensure liveness, secondary block producers are pre-determined and can step in if necessary, preventing any slot from being skipped. \n    Finality is achieved through GRANDPA, a GHOST-based finality gadget that provides finality through consecutive rounds of validators voting.\n    \n    ## Blobs\n    Data submitted to the Avail blockchain through submitData transactions is organized into a data matrix, with each block data divided into equal-sized cells. \n    This matrix is erasure coded using Reed-Solomon (RS) codes and committed using Kate-Zaverucha-Goldberg (KZG) polynomial commitments. \n    Each block header on Avail includes two types of attestations: KZG polynomial commitments of the submitted data and the root of a Merkle tree, where the leaves represent the data blobs. \n\n    ## Data Availability Sampling (DAS)\n    Avail ensures data availability through a data availability sampling (DAS) mechanism, which involves both Light clients and App clients.\n    Light clients sample the data matrix by requesting data cells, and for each cell they then check the KZG polynomial openings against the commitments in the block header.\n    Light clients first attempt to fetch cells using a Kademlia-based Distributed Hash Table (DHT) within a light clients peer-to-peer (P2P) network.\n    If the randomly selected cells are not available via DHT, the light client resorts to RPC calls to the Avail node(s) to obtain the data. Cells retrieved this way are then shared back into the DHT network, enhancing the overall availability of block data.\n    After gathering the data, the light client verifies the cells and calculates a confidence level, which is stored locally for reference.\n\n    App clients focus on data specific to a given application ID. They reconstruct entire rows of the data matrix by requesting and assembling any missing cells from the network.\n\n    ## Erasure Coding Proof\n\n    Avail uses Kate-Zaverucha-Goldberg (KZG) polynomial commitments as validity proofs of erasure-coded data. Light clients verify the commitments by checking the KZG polynomial openings against the commitments in the block header.\n \n    ## L2s Data Availability\n\n    L2s can post application-specific data blobs to the Avail blockchain through submitData transactions. \n    Each transaction contains an application ID that identifies the L2 and adheres to a size limit based on the Avail blockchain’s block size. \n    App-specific data can be reconstructed by app clients, which request and assemble missing cells from the network to complete the data reconstruction process.\n\n    ",
        "risks": [
          {
            "category": "Funds can be lost if",
            "text": "a dishonest majority of Avail validators finalize an unavailable block, and there aren't light nodes on the network verifying data availability, or they fail at social signaling unavailable data."
          },
          {
            "category": "Funds can be lost if",
            "text": "a dishonest majority of Avail validators finalize an unavailable block, and the number of light nodes on the network is not enough to ensure block reconstruction."
          }
        ]
      },
      "bridges": [
        {
          "id": "no-bridge",
          "type": "NoBridge",
          "createdAt": "1725372159",
          "display": {
            "name": "No bridge",
            "slug": "no-bridge",
            "description": "The risk profile in this page refers to scaling solutions that do not integrate with a data availability bridge.",
            "links": {
              "websites": [],
              "documentation": [],
              "repositories": [],
              "apps": [],
              "explorers": [],
              "socialMedia": []
            }
          },
          "risks": {
            "committeeSecurity": {
              "type": "NoBridge",
              "value": "N/A",
              "sentiment": "bad",
              "description": "Without a DA bridge, there is no committee attesting to the availability of data. The scaling solution using this DA layer relies only on the honesty of the sequencer."
            },
            "upgradeability": {
              "type": "NoBridge",
              "value": "N/A",
              "sentiment": "bad",
              "description": "There is no DA bridge from the DA layer to Ethereum. Projects using this layer without a bridge rely entirely on the sequencer's honesty (i.e., not publishing unavailable or invalid data). Without the bridge, users cannot react in time to malicious actions by the sequencer."
            },
            "relayerFailure": {
              "type": "NoBridge",
              "value": "N/A",
              "sentiment": "bad",
              "description": "The relayer does not contribute to the DA bridge liveness since data availability attestations are not integrated in the scaling solution's proof system."
            }
          },
          "technology": {
            "description": "No DA bridge is selected. Without a DA bridge, Ethereum has no proof of data availability for this project.\n",
            "risks": null
          },
          "usedIn": [],
          "otherConsiderations": null
        },
        {
          "id": "vector",
          "createdAt": "1725372159",
          "type": "OnChainBridge",
          "chain": "Ethereum",
          "display": {
            "name": "Vector",
            "slug": "vector",
            "description": "Vector is a data availability bridge using Zero-Knowledge proofs to verify Avail data availability attestations on Ethereum.",
            "links": {
              "websites": [],
              "documentation": ["https://docs.succinct.xyz/"],
              "repositories": ["https://github.com/succinctlabs/sp1-vector"],
              "apps": [],
              "explorers": [],
              "socialMedia": []
            }
          },
          "validation": { "type": "zk-proof", "relayer": "SuccinctGateway" },
          "contracts": {
            "addresses": [
              {
                "name": "Vector",
                "address": "0x02993cdC11213985b9B13224f3aF289F03bf298d",
                "description": "The Vector bridge contract that accepts and stores Avail data availability commitments on Ethereum."
              },
              {
                "name": "VectorSP1Verifier",
                "address": "0x1764C29FBd94865198588f10FC75D4f6636d158d",
                "description": "Verifier contract for the header range [latestBlock, targetBlock] proof."
              },
              {
                "name": "SuccinctGatewaySP1",
                "address": "0x3B6041173B80E77f038f3F2C0f9744f04837185e",
                "upgradeability": null,
                "chain": "ethereum",
                "description": "This contract is the router for the bridge proofs verification. It stores the mapping between the identifier of the bridge circuit and the address of the on-chain verifier contract.\n        "
              }
            ],
            "risks": [
              {
                "category": "Funds can be lost if",
                "text": "the bridge contract or its dependencies receive a malicious code upgrade. There is no delay on code upgrades."
              },
              {
                "category": "Funds can be frozen if",
                "text": "the bridge contract is frozen by the Guardian (AvailMultisig)."
              }
            ]
          },
          "technology": {
            "description": " \n    ## Architecture\n      \n    ![Avail vector architecture](/images/da-bridge-technology/avail/vector/architecture.png#center)\n    \n     The Vector bridge is a data availability bridge that facilitates data availability commitments to be bridged between Avail and Ethereum.\n     The SP1 Vector bridge is composed of three main components: the **Vector** contract, the **Succinct Gateway** contracts, and the **Verifier** contracts.  <br /> \n     By default, Vector operates asynchronously, handling requests in a fulfillment-based manner. First, zero-knowledge proofs of Avail block ranges are requested for proving. Requests can be submitted either off-chain through the Succinct API, or onchain through the requestCall() method of the Succinct Gateway smart contract.\n     Alternatively, it is possible to run an SP1 Vector operator with local proving, allowing for self-generating the proofs.\n     Once a proving request is received, the off-chain prover generates the proof and submits it to the Vector contract. The Vector contract verifies the proof with the corresponding verifier contract and, if successful, stores the data commitment in storage. <br /> \n\n    By default, Vector on Ethereum is updated by the Succinct operator at a cadence of approximately 1.5 hours.\n    ",
            "risks": [
              {
                "category": "Funds can be lost if",
                "text": "the DA bridge accepts an incorrect or malicious data commitment provided by a dishonest majority of Avail validators."
              },
              {
                "category": "Funds can be frozen if",
                "text": "the permissioned relayers are unable to submit DA commitments to the Vector contract."
              }
            ]
          },
          "permissions": [
            {
              "name": "AvailMultisig",
              "description": "This is a Gnosis Safe with 4 / 7 threshold.  This multisig is the admin and guardian of the Vector contract. It holds the power to change the contract state and upgrade the bridge.",
              "accounts": [
                {
                  "address": "0x7F2f87B0Efc66Fea0b7c30C61654E53C37993666",
                  "type": "MultiSig"
                }
              ],
              "chain": "ethereum",
              "references": null,
              "participants": [
                {
                  "address": "0xE458b870F2F59a49915591282f1Bb688901767AD",
                  "type": "EOA"
                },
                {
                  "address": "0x340e77D5e114A9D4891d3a1EbC7419CC85Ca8E4A",
                  "type": "EOA"
                },
                {
                  "address": "0xAD379D3275a18bd4BB741C3b291a3778D51c3304",
                  "type": "EOA"
                },
                {
                  "address": "0x72Ff26D9517324eEFA89A48B75c5df41132c4f54",
                  "type": "EOA"
                },
                {
                  "address": "0x1fbABAbDcFE0b40a9B5D2aDB054fB74F8fE985f5",
                  "type": "EOA"
                },
                {
                  "address": "0xBe1D614F13662Aff0a2Ec1e76f9c82D332Ae78A2",
                  "type": "EOA"
                },
                {
                  "address": "0xb9274De2305B377b437a9297D6c84eBD69f7aaCE",
                  "type": "EOA"
                }
              ]
            },
            {
              "name": "SuccinctGatewaySP1Multisig",
              "description": "This is a Gnosis Safe with 2 / 3 threshold.  This multisig is the admin of the SuccinctGatewaySP1 contract. As the manager of router for proof verification, it holds the power to affect the liveness and safety of the bridge.",
              "accounts": [
                {
                  "address": "0xCafEf00d348Adbd57c37d1B77e0619C6244C6878",
                  "type": "MultiSig"
                }
              ],
              "chain": "ethereum",
              "references": null,
              "participants": [
                {
                  "address": "0xBaB2c2aF5b91695e65955DA60d63aD1b2aE81126",
                  "type": "EOA"
                },
                {
                  "address": "0x72Ff26D9517324eEFA89A48B75c5df41132c4f54",
                  "type": "EOA"
                },
                {
                  "address": "0x9395e83720bf2D8ac6435f9c520b48E289Cb8885",
                  "type": "EOA"
                }
              ]
            },
            {
              "name": "Relayers",
              "description": "List of prover (relayer) addresses that are allowed to call commitHeaderRange() to commit block ranges to the Vector contract.",
              "accounts": [
                {
                  "address": "0x44eB418A966ff47f5AF6f48AEa6Afde0bf193a8d",
                  "type": "EOA"
                }
              ]
            },
            {
              "name": "Guardians",
              "description": "The Vector guardians hold the power to freeze the bridge contract, update the SuccinctGateway contract and update the list of authorized relayers.",
              "accounts": [
                {
                  "address": "0x7F2f87B0Efc66Fea0b7c30C61654E53C37993666",
                  "type": "MultiSig"
                }
              ]
            }
          ],
          "usedIn": [],
          "risks": {
            "committeeSecurity": {
              "type": "RobustAndDiverseCommittee",
              "value": "Validators set",
              "sentiment": "good",
              "description": "The committee requires an honest minority (1/3 or less) of members (or the network stake) to prevent the DA bridge from accepting an unavailable data commitment. \n    Participation in the committee is permissionless, based only on stake requirements and an honest majority of validators processing the new operator's request to join the active set."
            },
            "upgradeability": {
              "type": "LowOrNoDelay",
              "value": "None",
              "sentiment": "bad",
              "description": "There is no delay in the upgradeability of the bridge. Users have no time to exit the system before the bridge implementation update is completed."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          }
        }
      ],
      "usedIn": [],
      "consensusAlgorithm": {
        "name": "BABE/GRANDPA",
        "description": "Avail uses the BABE/GRANDPA consensus algorithm. BABE is a block production mechanism that is used to create new blocks in the Avail blockchain. GRANDPA is a finality gadget that is used to finalize blocks.",
        "blockTime": 20,
        "consensusFinality": 60,
        "unbondingPeriod": 1814400
      },
      "dataAvailabilitySampling": {
        "erasureCodingScheme": {
          "type": "TwoDReedSolomon",
          "value": "2D Reed-Solomon",
          "description": "TODO"
        },
        "erasureCodingProof": {
          "type": "ValidityProofs",
          "value": "Validity proofs",
          "description": "TODO"
        }
      },
      "pruningWindow": 0,
      "risks": {
        "economicSecurity": {
          "type": "OnChainQuantifiable",
          "value": "Staked assets",
          "sentiment": "good",
          "description": "There are staked assets on the DA layer that can be slashed in case of a data withholding attack. A dishonest majority of validators must collude to validate a block with missing or invalid data. The invalid block would be added to the chain but rejected by honest full nodes.\n    "
        },
        "fraudDetection": {
          "type": "DasWithNoBlobsReconstruction",
          "value": "DAS with no reconstruction",
          "sentiment": "warning",
          "description": "\n    The DA layer uses data availability sampling (DAS) to protect against data withholding attacks. However, there is no mechanism in place to reconstruct the data if some of it is withheld or the minimum number of light nodes\n    required to perform DAS is not available. This means that the data may be lost if a block producer withholds data or if there are not enough honest light nodes to perform DAS.\n    "
        }
      },
      "economicSecurity": { "type": "Avail" }
    },
    {
      "id": "celestia",
      "type": "DaLayer",
      "kind": "PublicBlockchain",
      "systemCategory": "public",
      "display": {
        "name": "Celestia",
        "slug": "celestia",
        "description": "Celestia is a modular data availability network that allows scaling solutions to post arbitrary data as blobs.",
        "links": {
          "websites": ["https://celestia.org/"],
          "documentation": ["https://docs.celestia.org/"],
          "repositories": ["https://github.com/celestiaorg"],
          "apps": [],
          "explorers": ["https://celenium.io/"],
          "socialMedia": [
            "https://x.com/CelestiaOrg",
            "https://discord.com/invite/YsnTPcSfWQ",
            "https://t.me/CelestiaCommunity"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    \n    ![Celestia architecture](/images/da-layer-technology/celestia/architecture.png#center)\n\n    ## Consensus\n    Celestia uses CometBTF, the canonical implementation of Tendermint consensus protocol. The consensus protocol is fork-free by construction under an honest majority of stake assumption.\n    Celestia achieves finality at each block, with an average time between blocks of 12 seconds.\n    ## Blobs\n    In Celestia, blobs are user-submitted data that does not modify the blockchain state.  \n    Each blob has two components, one is a binary object of raw data bytes, and the other is the namespace of the specific application for which the blob data is intended for.\n\n    \n    ![Blobs](/images/da-layer-technology/celestia/blobs.png#center)\n\n    All data posted in a Celestia blob is divided into chunks of fixed size, called shares, and each blob is arranged in a k * k matrix of shares.\n\n\n    ![Blobs matrix](/images/da-layer-technology/celestia/blobs-matrix.png#center)\n\n    Celestia shares' rows and columns are erasure-coded into a 2k * 2k matrix and committed to in a Namespace Merkle Trees (NMTs), a version of a standard Merkle tree using a namespaced hash function. \n    In NMTs, every node in the tree includes the range of namespaces of all its child nodes, allowing applications to request and retrieve data for a specific namespace sub-tree while maintaining all functionalities (e.g., inclusion and range proofs) of a standard Merkle tree.\n\n\n    ![Matrix proofs](/images/da-layer-technology/celestia/matrix-proofs.png#center)\n\n    Ultimately, a single data root (availableDataRoot) of the Merkle tree is computed with the row and column roots as leaves. This data root is included in the block header as the root of commitments to erasure-coded data so that individual shares in the matrix can be proven to belong to a single data root.\n\n\n    ![Data root](/images/da-layer-technology/celestia/data-root.png#center)\n\n    ## Data Availability Sampling (DAS)\n\n    To ensure data availability, Celestia light nodes perform sampling on the 2k x 2k data matrix. Each light node randomly selects a set of unique coordinates within the extended matrix and requests the corresponding data shares and Merkle proofs from full nodes.\n    Currently, a Celestia light node must perform a minimum of 16 samples before declaring that a block is available.\n    This sampling rate ensures that given the minimum number of unavailable shares, a light client will sample at least one unavailable share with a 99% probability.\n\n    \n    ![DAS](/images/da-layer-technology/celestia/das.png#center)\n\n    ## Erasure Coding Proof\n    Light nodes performing data availability sampling must have the guarantee that the sampled data is erasure coded correctly. In Celestia, light nodes can be notified of a maliciously encoded block through Bad Encoding Fraud Proofs (BEFPs). Full nodes receiving invalid erasure-coded data can generate a fraud-proof to be transmitted to all light and full nodes in the DA network. The proof is generated by full nodes reconstructing the original data from the block data, and verifying that the recomputed data root matches the data root of the block header. \n    Upon receiving and verifying the BEFP, all Celestia nodes should halt providing services (e.g., submitTx).\n\n    ## L2s Data Availability\n    Scaling solutions can post data to Celestia by submitting blobs through a payForBlobs transaction. The transaction can include data as a single blob or multiple blobs, with the total maximum size determined by the maximum block size. The transaction fee is determined by the size of the data and the current gas price. \n    Applications can then retrieve the data by querying the Celestia blockchain for the data root of the blob and the namespace of the application. The data can be reconstructed by querying the Celestia network for the shares of the data matrix and reconstructing the data using the erasure coding scheme.\n\n    ",
        "risks": [
          {
            "category": "Funds can be lost if",
            "text": "a dishonest majority of Celestia validators finalize an unavailable block, and there aren't light nodes on the network verifying data availability, or they fail at social signaling unavailable data."
          },
          {
            "category": "Funds can be lost if",
            "text": "a dishonest majority of Celestia validators finalize an unavailable block, and the number of light nodes on the network is not enough to ensure block reconstruction."
          },
          {
            "category": "Funds can be lost if",
            "text": "a dishonest majority of Celestia validators finalize an unavailable block, and full nodes block reconstruction time is longer than the erasure-coding fraud proof window."
          }
        ]
      },
      "bridges": [
        {
          "id": "no-bridge",
          "type": "NoBridge",
          "createdAt": "1721138888",
          "display": {
            "name": "No bridge",
            "slug": "no-bridge",
            "description": "The risk profile in this page refers to scaling solutions that do not integrate with a data availability bridge.",
            "links": {
              "websites": [],
              "documentation": [],
              "repositories": [],
              "apps": [],
              "explorers": [],
              "socialMedia": []
            }
          },
          "risks": {
            "committeeSecurity": {
              "type": "NoBridge",
              "value": "N/A",
              "sentiment": "bad",
              "description": "Without a DA bridge, there is no committee attesting to the availability of data. The scaling solution using this DA layer relies only on the honesty of the sequencer."
            },
            "upgradeability": {
              "type": "NoBridge",
              "value": "N/A",
              "sentiment": "bad",
              "description": "There is no DA bridge from the DA layer to Ethereum. Projects using this layer without a bridge rely entirely on the sequencer's honesty (i.e., not publishing unavailable or invalid data). Without the bridge, users cannot react in time to malicious actions by the sequencer."
            },
            "relayerFailure": {
              "type": "NoBridge",
              "value": "N/A",
              "sentiment": "bad",
              "description": "The relayer does not contribute to the DA bridge liveness since data availability attestations are not integrated in the scaling solution's proof system."
            }
          },
          "technology": {
            "description": "No DA bridge is selected. Without a DA bridge, Ethereum has no proof of data availability for this project.\n",
            "risks": null
          },
          "usedIn": [
            { "id": "aevo", "name": "Aevo", "slug": "aevo" },
            { "id": "ancient", "name": "Ancient8", "slug": "ancient8" },
            { "id": "hypr", "name": "Hypr", "slug": "hypr" },
            { "id": "karak", "name": "Karak", "slug": "karak" },
            { "id": "lyra", "name": "Derive", "slug": "derive" },
            {
              "id": "mantapacific",
              "name": "Manta Pacific",
              "slug": "mantapacific"
            },
            { "id": "orderly", "name": "Orderly Network", "slug": "orderly" },
            {
              "id": "publicgoodsnetwork",
              "name": "Public Goods Network",
              "slug": "publicgoodsnetwork"
            },
            { "id": "ham", "name": "Ham", "slug": "ham" },
            { "id": "stack", "name": "Stack", "slug": "stack" }
          ],
          "otherConsiderations": null
        },
        {
          "type": "OnChainBridge",
          "id": "blobstream",
          "createdAt": "1729253328",
          "display": {
            "name": "Blobstream",
            "slug": "blobstream",
            "description": "The Blobstream bridge serves as a ZK light client, enabling the bridging of data availability commitments between Celestia and Ethereum.",
            "links": {
              "websites": [],
              "documentation": [
                "https://docs.celestia.org/developers/blobstream"
              ],
              "repositories": [
                "https://github.com/succinctlabs/sp1-blobstream"
              ],
              "apps": [],
              "explorers": ["https://etherscan.io/"],
              "socialMedia": []
            }
          },
          "risks": {
            "committeeSecurity": {
              "type": "RobustAndDiverseCommittee",
              "value": "Validators set",
              "sentiment": "good",
              "description": "The committee requires an honest minority (1/3 or less) of members (or the network stake) to prevent the DA bridge from accepting an unavailable data commitment. \n    Participation in the committee is permissionless, based only on stake requirements and an honest majority of validators processing the new operator's request to join the active set."
            },
            "upgradeability": {
              "type": "LowOrNoDelay",
              "value": "None",
              "sentiment": "bad",
              "description": "There is no delay in the upgradeability of the bridge. Users have no time to exit the system before the bridge implementation update is completed."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          },
          "chain": "ethereum",
          "validation": {
            "type": "zk-proof",
            "relayer": "SuccinctGateway",
            "proverSource": "https://hackmd.io/@succinctlabs/HJE7XRrup"
          },
          "contracts": {
            "addresses": [
              {
                "name": "Blobstream",
                "address": "0x7Cf3876F681Dbb6EdA8f6FfC45D66B996Df08fAe",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x0000000000000000000000000000000000000000"],
                  "implementations": [
                    "0x47fd660D5252Bd6F9D2c71507E46aa1d6e957c23"
                  ]
                },
                "chain": "ethereum",
                "description": "The Blobstream DA bridge. This contract is used to bridge data commitments between Celestia and Ethereum."
              },
              {
                "name": "blobstreamVerifier",
                "address": "0x1764C29FBd94865198588f10FC75D4f6636d158d",
                "description": "Verifier contract for the header range [latestBlock, targetBlock] proof.\n        A request for a header range can be at most 1000 blocks long. The proof is generated by an off-chain prover and submitted by a relayer."
              },
              {
                "name": "SuccinctGatewaySP1",
                "address": "0x3B6041173B80E77f038f3F2C0f9744f04837185e",
                "upgradeability": null,
                "chain": "ethereum",
                "description": "This contract is the router for the bridge proofs verification. It stores the mapping between the identifier of the bridge circuit and the address of the on-chain verifier contract.\n        "
              },
              {
                "name": "SuccinctGateway",
                "address": "0x6c7a05e0AE641c6559fD76ac56641778B6eCd776",
                "upgradeability": null,
                "chain": "ethereum",
                "description": "Users can interact with this contract to request proofs on-chain, emitting a RequestCall event for off-chain provers to consume."
              }
            ],
            "nativeAddresses": {
              "arbitrum": [
                {
                  "name": "Blobstream",
                  "address": "0xA83ca7775Bc2889825BcDeDfFa5b758cf69e8794",
                  "upgradeability": {
                    "proxyType": "EIP1967 proxy",
                    "admins": ["0x0000000000000000000000000000000000000000"],
                    "implementations": [
                      "0x47fd660D5252Bd6F9D2c71507E46aa1d6e957c23"
                    ]
                  },
                  "chain": "arbitrum",
                  "description": "The Blobstream DA bridge. This contract is used to bridge data commitments between Celestia and Ethereum."
                },
                {
                  "name": "blobstreamVerifier",
                  "chain": "arbitrum",
                  "address": "0x1764C29FBd94865198588f10FC75D4f6636d158d",
                  "description": "Verifier contract for the header range [latestBlock, targetBlock] proof.\n          A request for a header range can be at most 1000 blocks long. The proof is generated by an off-chain prover and submitted by a relayer."
                },
                {
                  "name": "SuccinctGatewaySP1",
                  "address": "0x3B6041173B80E77f038f3F2C0f9744f04837185e",
                  "upgradeability": null,
                  "chain": "arbitrum",
                  "description": "This contract is the router for the bridge proofs verification. It stores the mapping between the identifier of the bridge circuit and the address of the on-chain verifier contract.\n          "
                },
                {
                  "name": "SuccinctGateway",
                  "address": "0x6c7a05e0AE641c6559fD76ac56641778B6eCd776",
                  "upgradeability": null,
                  "chain": "arbitrum",
                  "description": "Users can interact with this contract to request proofs on-chain, emitting a RequestCall event for off-chain provers to consume."
                }
              ],
              "base": [
                {
                  "name": "Blobstream",
                  "address": "0xA83ca7775Bc2889825BcDeDfFa5b758cf69e8794",
                  "upgradeability": {
                    "proxyType": "EIP1967 proxy",
                    "admins": ["0x0000000000000000000000000000000000000000"],
                    "implementations": [
                      "0x47fd660D5252Bd6F9D2c71507E46aa1d6e957c23"
                    ]
                  },
                  "chain": "base",
                  "description": "The Blobstream DA bridge. This contract is used to bridge data commitments between Celestia and Ethereum."
                },
                {
                  "name": "blobstreamVerifier",
                  "chain": "base",
                  "address": "0x1764C29FBd94865198588f10FC75D4f6636d158d",
                  "description": "Verifier contract for the header range [latestBlock, targetBlock] proof.\n          A request for a header range can be at most 1000 blocks long. The proof is generated by an off-chain prover and submitted by a relayer."
                },
                {
                  "name": "SuccinctGatewaySP1",
                  "address": "0x3B6041173B80E77f038f3F2C0f9744f04837185e",
                  "upgradeability": null,
                  "chain": "base",
                  "description": "This contract is the router for the bridge proofs verification. It stores the mapping between the identifier of the bridge circuit and the address of the on-chain verifier contract.\n          "
                },
                {
                  "name": "SuccinctGateway",
                  "address": "0x6c7a05e0AE641c6559fD76ac56641778B6eCd776",
                  "upgradeability": null,
                  "chain": "base",
                  "description": "Users can interact with this contract to request proofs on-chain, emitting a RequestCall event for off-chain provers to consume."
                }
              ]
            },
            "risks": [
              {
                "category": "Funds can be lost if",
                "text": "the bridge contract or its dependencies receive a malicious code upgrade. There is no delay on code upgrades."
              },
              {
                "category": "Funds can be frozen if",
                "text": "the bridge contract is frozen by the Guardian (BlobstreamMultisig)."
              }
            ]
          },
          "technology": {
            "description": "\n\n    ## Architecture\n      \n    ![Celestia blobstream architecture](/images/da-bridge-technology/celestia/blobstream/architecture.png#center)\n    \n     The Blobstream bridge is a data availability bridge that facilitates data availability commitments to be bridged between Celestia and Ethereum.\n     The Blobstream bridge is composed of three main components: the **Blobstream** contract, the **Succinct Gateway** contracts, and the **Verifier** contracts.  <br /> \n     By default, Blobstream operates asynchronously, handling requests in a fulfillment-based manner. First, zero-knowledge proofs of Celestia block ranges are requested for proving. Requests can be submitted either off-chain through the Succinct API, or onchain through the requestCall() method of the Succinct Gateway smart contract.\n     Alternatively, it is possible to run an SP1 Blobstream operator with local proving, allowing for self-generating the proofs.\n     Once a proving request is received, the off-chain prover generates the proof and submits it to Blobstream contract. The Blobstream contract verifies the proof with the corresponding verifier contract and, if successful, stores the data commitment in storage. <br /> \n\n     Verifying a header range includes verifying tendermint consensus (header signatures are 2/3 of stake) and verifying the data commitment root.\n      By default, Blobstream on Ethereum is updated by the Succinct operator at a regular cadence of 4 hour.\n      For Blobstream on Arbitrum, the update interval is 1 hour, and for Blobstream on Base, the update interval is 1 hour.\n    ",
            "risks": [
              {
                "category": "Funds can be lost if",
                "text": "the DA bridge accepts an incorrect or malicious data commitment provided by a dishonest majority of Celestia validators."
              },
              {
                "category": "Funds can be frozen if",
                "text": "the permissioned relayers are unable to submit DA commitments to the Blobstream contract."
              }
            ]
          },
          "permissions": [
            {
              "name": "BlobstreamMultisig",
              "description": "This is a Gnosis Safe with 4 / 6 threshold.  This multisig is the admin of the Blobstream contract. It holds the power to change the contract state and upgrade the bridge.",
              "accounts": [
                {
                  "address": "0x8bF34D8df1eF0A8A7f27fC587202848E528018E6",
                  "type": "MultiSig"
                }
              ],
              "chain": "ethereum",
              "references": null,
              "participants": [
                {
                  "address": "0x0449689f2ce80fE45B32092e0d878ad87F0156a9",
                  "type": "EOA"
                },
                {
                  "address": "0x793979789Ec179183E396e76c1e241bE0c9eE899",
                  "type": "EOA"
                },
                {
                  "address": "0x1358eaCFE3a7F4FEB06c0Ae722072F134bcE7caf",
                  "type": "EOA"
                },
                {
                  "address": "0x45878fdF56B372D944c6Fc1865B7a65462f6D1b0",
                  "type": "EOA"
                },
                {
                  "address": "0xA3fC931613a4E2440a199d47B0076e8b85F33099",
                  "type": "EOA"
                },
                {
                  "address": "0x91D456f83f4a117B07866fdEdC29306f7E974e15",
                  "type": "EOA"
                }
              ]
            },
            {
              "name": "SuccinctGatewaySP1Multisig",
              "description": "This is a Gnosis Safe with 2 / 3 threshold.  This multisig is the admin of the SuccinctGatewaySP1 contract. As the manager of router for proof verification, it holds the power to affect the liveness and safety of the bridge.",
              "accounts": [
                {
                  "address": "0xCafEf00d348Adbd57c37d1B77e0619C6244C6878",
                  "type": "MultiSig"
                }
              ],
              "chain": "ethereum",
              "references": null,
              "participants": [
                {
                  "address": "0xBaB2c2aF5b91695e65955DA60d63aD1b2aE81126",
                  "type": "EOA"
                },
                {
                  "address": "0x72Ff26D9517324eEFA89A48B75c5df41132c4f54",
                  "type": "EOA"
                },
                {
                  "address": "0x9395e83720bf2D8ac6435f9c520b48E289Cb8885",
                  "type": "EOA"
                }
              ]
            },
            {
              "name": "Relayers",
              "description": "List of prover (relayer) addresses that are allowed to call commitHeaderRange() to commit block ranges to the Blobstream contract.",
              "accounts": [
                {
                  "address": "0x44eB418A966ff47f5AF6f48AEa6Afde0bf193a8d",
                  "type": "EOA"
                }
              ]
            },
            {
              "name": "Guardians",
              "description": "The Blobstream guardians hold the power to freeze the bridge contract, update the SuccinctGateway contract and update the list of authorized relayers.",
              "accounts": [
                {
                  "address": "0x8bF34D8df1eF0A8A7f27fC587202848E528018E6",
                  "type": "MultiSig"
                }
              ]
            }
          ],
          "nativePermissions": {
            "arbitrum": [
              {
                "name": "BlobstreamMultisig",
                "description": "This is a Gnosis Safe with 4 / 6 threshold.  This multisig is the admin of the Blobstream contract. It holds the power to change the contract state and upgrade the bridge.",
                "accounts": [
                  {
                    "address": "0x738a9b55304f9fcF776B3BA285e50c0f9eF77997",
                    "type": "MultiSig"
                  }
                ],
                "chain": "arbitrum",
                "references": null,
                "participants": [
                  {
                    "address": "0x0449689f2ce80fE45B32092e0d878ad87F0156a9",
                    "type": "EOA"
                  },
                  {
                    "address": "0x91D456f83f4a117B07866fdEdC29306f7E974e15",
                    "type": "EOA"
                  },
                  {
                    "address": "0x793979789Ec179183E396e76c1e241bE0c9eE899",
                    "type": "EOA"
                  },
                  {
                    "address": "0xA3fC931613a4E2440a199d47B0076e8b85F33099",
                    "type": "EOA"
                  },
                  {
                    "address": "0x45878fdF56B372D944c6Fc1865B7a65462f6D1b0",
                    "type": "EOA"
                  },
                  {
                    "address": "0x1358eaCFE3a7F4FEB06c0Ae722072F134bcE7caf",
                    "type": "EOA"
                  }
                ]
              },
              {
                "name": "SuccinctGatewaySP1Multisig",
                "description": "This is a Gnosis Safe with 2 / 3 threshold.  This multisig is the admin of the SuccinctGatewaySP1 contract. As the manager of router for proof verification, it holds the power to affect the liveness and safety of the bridge.",
                "accounts": [
                  {
                    "address": "0xCafEf00d348Adbd57c37d1B77e0619C6244C6878",
                    "type": "MultiSig"
                  }
                ],
                "chain": "arbitrum",
                "references": null,
                "participants": [
                  {
                    "address": "0xBaB2c2aF5b91695e65955DA60d63aD1b2aE81126",
                    "type": "EOA"
                  },
                  {
                    "address": "0x72Ff26D9517324eEFA89A48B75c5df41132c4f54",
                    "type": "EOA"
                  },
                  {
                    "address": "0x9395e83720bf2D8ac6435f9c520b48E289Cb8885",
                    "type": "EOA"
                  }
                ]
              },
              {
                "name": "Relayers",
                "chain": "arbitrum",
                "description": "List of prover (relayer) addresses that are allowed to call commitHeaderRange() to commit block ranges to the Blobstream contract.",
                "accounts": [
                  {
                    "address": "0x44eB418A966ff47f5AF6f48AEa6Afde0bf193a8d",
                    "type": "EOA"
                  }
                ]
              }
            ],
            "base": [
              {
                "name": "BlobstreamMultisig",
                "description": "This is a Gnosis Safe with 4 / 6 threshold.  This multisig is the admin of the Blobstream contract. It holds the power to change the contract state and upgrade the bridge.",
                "accounts": [
                  {
                    "address": "0x6ABa5D2084362038C9640a8851ff3b8BCbA81Ca6",
                    "type": "MultiSig"
                  }
                ],
                "chain": "base",
                "references": null,
                "participants": [
                  {
                    "address": "0x0449689f2ce80fE45B32092e0d878ad87F0156a9",
                    "type": "EOA"
                  },
                  {
                    "address": "0x793979789Ec179183E396e76c1e241bE0c9eE899",
                    "type": "EOA"
                  },
                  {
                    "address": "0x1358eaCFE3a7F4FEB06c0Ae722072F134bcE7caf",
                    "type": "EOA"
                  },
                  {
                    "address": "0x45878fdF56B372D944c6Fc1865B7a65462f6D1b0",
                    "type": "EOA"
                  },
                  {
                    "address": "0xA3fC931613a4E2440a199d47B0076e8b85F33099",
                    "type": "EOA"
                  },
                  {
                    "address": "0x91D456f83f4a117B07866fdEdC29306f7E974e15",
                    "type": "EOA"
                  }
                ]
              },
              {
                "name": "SuccinctGatewaySP1Multisig",
                "description": "This is a Gnosis Safe with 2 / 3 threshold.  This multisig is the admin of the SuccinctGatewaySP1 contract. As the manager of router for proof verification, it holds the power to affect the liveness and safety of the bridge.",
                "accounts": [
                  {
                    "address": "0xCafEf00d348Adbd57c37d1B77e0619C6244C6878",
                    "type": "MultiSig"
                  }
                ],
                "chain": "base",
                "references": null,
                "participants": [
                  {
                    "address": "0xBaB2c2aF5b91695e65955DA60d63aD1b2aE81126",
                    "type": "EOA"
                  },
                  {
                    "address": "0x72Ff26D9517324eEFA89A48B75c5df41132c4f54",
                    "type": "EOA"
                  },
                  {
                    "address": "0x9395e83720bf2D8ac6435f9c520b48E289Cb8885",
                    "type": "EOA"
                  }
                ]
              },
              {
                "name": "Relayers",
                "chain": "base",
                "description": "List of prover (relayer) addresses that are allowed to call commitHeaderRange() to commit block ranges to the Blobstream contract.",
                "accounts": [
                  {
                    "address": "0x44eB418A966ff47f5AF6f48AEa6Afde0bf193a8d",
                    "type": "EOA"
                  }
                ]
              }
            ]
          },
          "usedIn": []
        }
      ],
      "usedIn": [
        { "id": "aevo", "name": "Aevo", "slug": "aevo" },
        { "id": "ancient", "name": "Ancient8", "slug": "ancient8" },
        { "id": "hypr", "name": "Hypr", "slug": "hypr" },
        { "id": "karak", "name": "Karak", "slug": "karak" },
        { "id": "lyra", "name": "Derive", "slug": "derive" },
        {
          "id": "mantapacific",
          "name": "Manta Pacific",
          "slug": "mantapacific"
        },
        { "id": "orderly", "name": "Orderly Network", "slug": "orderly" },
        {
          "id": "publicgoodsnetwork",
          "name": "Public Goods Network",
          "slug": "publicgoodsnetwork"
        },
        { "id": "ham", "name": "Ham", "slug": "ham" },
        { "id": "stack", "name": "Stack", "slug": "stack" }
      ],
      "consensusAlgorithm": {
        "name": "CometBFT",
        "description": "CometBFT is the canonical implementation of the Tendermint consensus algorithm.\n    CometBFT allows for a state transition machine to be written in any programming language, and it allows for secure replication across many machines.\n    The consensus protocol is fork-free by construction under an honest majority of stake assumption.",
        "blockTime": 15,
        "consensusFinality": 1,
        "unbondingPeriod": 1814400
      },
      "dataAvailabilitySampling": {
        "erasureCodingScheme": {
          "type": "TwoDReedSolomon",
          "value": "2D Reed-Solomon",
          "description": "TODO"
        },
        "erasureCodingProof": {
          "type": "FraudProofs",
          "value": "Fraud proofs",
          "description": "TODO"
        }
      },
      "pruningWindow": 2592000,
      "risks": {
        "economicSecurity": {
          "type": "OnChainQuantifiable",
          "value": "Staked assets",
          "sentiment": "good",
          "description": "There are staked assets on the DA layer that can be slashed in case of a data withholding attack. A dishonest majority of validators must collude to validate a block with missing or invalid data. The invalid block would be added to the chain but rejected by honest full nodes.\n    "
        },
        "fraudDetection": {
          "type": "DasWithNoBlobsReconstruction",
          "value": "DAS with no reconstruction",
          "sentiment": "warning",
          "description": "\n    The DA layer uses data availability sampling (DAS) to protect against data withholding attacks. However, there is no mechanism in place to reconstruct the data if some of it is withheld or the minimum number of light nodes\n    required to perform DAS is not available. This means that the data may be lost if a block producer withholds data or if there are not enough honest light nodes to perform DAS.\n    "
        }
      },
      "economicSecurity": { "type": "Celestia" }
    },
    {
      "id": "near",
      "type": "DaLayer",
      "kind": "PublicBlockchain",
      "systemCategory": "public",
      "display": {
        "name": "NEAR DA",
        "slug": "near",
        "description": "NEAR's Data Availability Layer (NEAR DA) leverages the sharded architecture of the NEAR Protocol to provide a modular data availability layer for layer 2 solutions.",
        "links": {
          "websites": ["https://near.org/", "https://nuff.tech/"],
          "documentation": [
            "https://docs.near.org/build/chain-abstraction/data-availability"
          ],
          "repositories": [
            "https://github.com/near",
            "https://github.com/Nuffle-Labs/data-availability"
          ],
          "apps": [],
          "explorers": ["https://nearblocks.io/"],
          "socialMedia": [
            "https://x.com/NEARProtocol",
            "https://discord.com/invite/zfhfRpaM4m"
          ]
        }
      },
      "consensusAlgorithm": {
        "name": "Nightshade",
        "description": "Nightshade is a sharding-based, Proof-of-Stake (PoS) consensus protocol enabling parallel transaction processing.\n    Near Nightshade has one single main chain producing blocks. Main chain blocks do not contain actual transactions, but they include one chunk header for each shard, where\n    a chunk is the equivalent of a block in a standard, non-shared blockchain. At the beginning of the epoch, both the block and chunk production schedule\n    are randomly generated. For each block on the main chain, and for every shard, one of the assigned chunk producers is responsible to produce the part of the main chain block\n    related to the shard, and share the chunk header with the network. Finality is determined by the NFG (Nightshade finality gadget), and after 2 consecutive blocks are built on the same fork the t-2 block is considered final.\n    Reverting a finalized block will require at least 1/3 of the total stake to be slashed.",
        "blockTime": 1.2,
        "consensusFinality": 2.4,
        "unbondingPeriod": 172800
      },
      "technology": {
        "description": "\n  ## Architecture\n\n  ![Near architecture](/images/da-layer-technology/near/architecture.png#center)\n\n  ## Near Nightshade\n\n  ### Consensus\n  NEAR's Nightshade consensus operates a Proof-of-Stake (PoS) system that enables parallel processing of transactions through a sharded architecture. As with any PoS system, validators are required to lock a stake to be eligible for block production and attestations.\n  The main differentiator of the NEAR blockchain is that its blocks do not contain actual transactions but rather block headers of separate blockchains, known as shards.\n  The ***main chain*** can contain many shards, and the current NEAR implementation supports 6 shards.\n  \n\n  ![Near Shards](/images/da-layer-technology/near/nearShards.png#center)\n\n\n\n  Each shard is composed of chunks, which are equivalent to standard blockchain blocks.\n  Essentially, the state of the main chain is split into n shards, and only the shards block headers end up being part of the main chain.\n\n\n  ![Near Chunks](/images/da-layer-technology/near/nearChunks.png#center)\n\n  \n\n  Becoming a block producer requires locking (staking) a certain amount of tokens, currently 25,500 NEAR. Staking operates through a threshold PoS mechanism, where a user’s stake must exceed the protocol's seat price—determined by the total NEAR tokens staked by other validators—in order to become a validator. The largest stakers at the beginning of a particular epoch are selected as block producers for that epoch. Each block producer is randomly assigned a certain number of shards to manage.\n  Before the epoch starts, the block producer downloads the state of the shard(s) they are assigned to (they have 1 epoch to complete this download). Throughout the epoch, they collect transactions that affect their assigned shard(s) and apply them to the state. NEAR nodes have an automatic 'garbage collection' routine that deletes the state of previous shards after five epochs, freeing up unused storage.\n  Within an epoch (12 hours), the main chain block and shard block production schedule is determined by a randomness seed generated at the beginning of the epoch. For each block height, a main chain block producer is assigned.\n  Validators participate in several validation rounds within the epoch. For each round, one validator in each shard is chosen to be the chunk producer, and one validator from the entire set is chosen to be the block producer. Validators can serve as both block and chunk producers, but they maintain separate stakes for these roles.\n  The shard block producer is responsible for producing the part of the block related to their shard, known as a chunk. The chunk contains the list of transactions for the shard to be included in the block, as well as the Merkle root of the resulting state. Each main chain block contains either one or zero chunks per shard, depending on whether the shard can keep up with the main chain block production speed.\n  \n  \n  ![Near Validators](/images/da-layer-technology/near/nearValidators.png#center)\n\n  \n\n  A block on the main chain will only contain a small header of the chunk, composed of the Merkle root of all applied transactions and the Merkle root of the final state. When a block producer generates a chunk, they also produce an associated state witness, which is necessary for executing the chunk.\n\n  Chunk producers maintain the full state of their shard. Validators, on the other hand, do not maintain the state of any shard locally; instead, they download and verify all the block headers. They validate chunks using the state witness created by the chunk producers.\n  \n  ### Data Availability\n  Since only shard chunk producers maintain the shard state (while main chain validators do not), and main chain block producers need to attest to the chunk headers, data availability of the shard data must be ensured.\n\n  After a block producer creates a chunk, they generate an erasure-coded version of it using Reed-Solomon encoding. The extended chunk is then split into multiple parts, which are distributed to all main chain validators.\n\n  ![Near Erasure Coding](/images/da-layer-technology/near/nearErasureCoding.png)\n\n\n  A block producer will not process a main chain block if they do not have the corresponding chunk sample for at least one chunk included in the block, or if they are unable to reconstruct the entire chunk for any shard for which they maintain the state.\n\n  For a particular chunk to be considered available, it is sufficient that [mainChainBlockProducer/nOfShards] + 1 of the block producers possess their respective parts and are able to serve them. As long as the number of malicious actors does not exceed one-third of the validators (block producers), any chain built by more than half of the block producers will have all its chunks available.\n\n  ![Near Erasure Distribution](/images/da-layer-technology/near/nearErasureDistribution.png)\n\n  \n\n  ### Finality\n  Finality is determined by the Nightshade Finality Gadget (NFG). A block is considered final after two consecutive blocks are built on the same fork, making the block that is two blocks behind (t-2) final. Reverting a finalized block would require slashing at least one-third of the total stake.\n\n  ## L2s Data Availability\n  A rollup can utilize a dedicated Data Availability (DA) smart contract on a NEAR shard, known as a Blob Store contract, where it posts data as standard NEAR transactions. All transactions are converted into Receipts, and depending on their actions, some receipts may be processed over two blocks.\n  Regarding data retrieval, full nodes prune Receipts after 3 epochs (approximately 36 hours). Once the pruning window expires, the data remains accessible only through archive nodes.\n  "
      },
      "bridges": [
        {
          "id": "no-bridge",
          "type": "NoBridge",
          "createdAt": "1721664340",
          "display": {
            "name": "No bridge",
            "slug": "no-bridge",
            "description": "This project does not have a DA bridge on Ethereum.",
            "links": {
              "websites": [],
              "documentation": [],
              "repositories": [],
              "apps": [],
              "explorers": [],
              "socialMedia": []
            }
          },
          "risks": {
            "committeeSecurity": {
              "type": "NoBridge",
              "value": "N/A",
              "sentiment": "bad",
              "description": "Without a DA bridge, there is no committee attesting to the availability of data. The scaling solution using this DA layer relies only on the honesty of the sequencer."
            },
            "upgradeability": {
              "type": "NoBridge",
              "value": "N/A",
              "sentiment": "bad",
              "description": "There is no DA bridge from the DA layer to Ethereum. Projects using this layer without a bridge rely entirely on the sequencer's honesty (i.e., not publishing unavailable or invalid data). Without the bridge, users cannot react in time to malicious actions by the sequencer."
            },
            "relayerFailure": {
              "type": "NoBridge",
              "value": "N/A",
              "sentiment": "bad",
              "description": "The relayer does not contribute to the DA bridge liveness since data availability attestations are not integrated in the scaling solution's proof system."
            }
          },
          "technology": {
            "description": "There is no DA bridge on Ethereum allowing to verify blob inclusion in the NEAR blockchain.",
            "risks": null
          },
          "usedIn": [
            { "id": "rss3", "name": "RSS3 Value Sublayer", "slug": "rss3" }
          ],
          "otherConsiderations": null
        }
      ],
      "usedIn": [
        { "id": "rss3", "name": "RSS3 Value Sublayer", "slug": "rss3" }
      ],
      "pruningWindow": 129600,
      "risks": {
        "economicSecurity": {
          "type": "OnChainQuantifiable",
          "value": "Staked assets",
          "sentiment": "good",
          "description": "There are staked assets on the DA layer that can be slashed in case of a data withholding attack. A dishonest majority of validators must collude to validate a block with missing or invalid data. The invalid block would be added to the chain but rejected by honest full nodes.\n    "
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      },
      "economicSecurity": { "type": "Near" }
    },
    {
      "id": "memo",
      "type": "DaLayer",
      "kind": "PublicBlockchain",
      "systemCategory": "public",
      "display": {
        "name": "Meeda",
        "slug": "memo",
        "description": "Meeda (MemoDA) is a blockchain-based cloud storage protocol developed by MEMO Labs.",
        "links": {
          "websites": ["https://www.memolabs.org/"],
          "documentation": ["https://memolabs.gitbook.io/meeda"],
          "repositories": ["https://github.com/memoio"],
          "apps": [],
          "explorers": ["https://scan.metamemo.one:8080/"],
          "socialMedia": [
            "https://x.com/MemoLabsOrg",
            "https://discord.com/invite/YG4Ydv2E7X"
          ]
        }
      },
      "consensusAlgorithm": {
        "name": "",
        "description": "",
        "blockTime": 0,
        "consensusFinality": 0,
        "unbondingPeriod": 0
      },
      "technology": {
        "description": "\n    ## Architecture\n\n    ![Meeda architecture](/images/da-layer-technology/meeda/architecture.png#center)\n\n    Meeda's architecture consists of several components. \n    Storage Nodes store blob data and generate data availability commitments, with node deployment available to all users. \n    Light Nodes are responsible for challenging storage nodes through onchain verification, and their deployment is also open to all users. \n    The Operator, currently deployed by the project itself, handles the erasure coding of data and data chunks distribution, as well as the aggregation of KZG commitment proofs from Storage Nodes. \n    \n    Storage Nodes, based on seed information generated periodically on the Memo chain, submit KZG data commitments to the Operator. \n    The Verification Contract is responsible for onchain verification on Memo chain, and it will generate seed information through the VRF-Sampling (Verifiable Random Function) cycle to determine which files to select for verification.\n    Not all data commitments are verified onchain, but only a subset of data is verified, with the sampling determined by the random seed produced by the Verification Contract.\n    The operator will then collect and aggregate the KZG commitments for the selected files from storage nodes, and submit the aggregate proof to the Verification Contract.\n   \n    Optimistic verification assumes that the aggregation commitment submitted by the operator node is correct and only requires checking the accuracy of the associated proof.\n    If no light node challenges the commitment within the specified validity period, the proof of availability is considered successful. <br/>\n\n    Submitting a fraud proof is expected to require multiple rounds of interaction, with pledges and rewards for both the challenger and the challenged.\n    The proving smart contracts ([FileProof](https://scan.metamemo.one:8080/address/0x58C3Ab98546879a859EDBa3252A9d38E43C9cbee/), [ControlFileProof](https://scan.metamemo.one:8080/address/0x6eEc7578dBAD9dcc1CA159A9Df0A73233548b89a/), [ProxyFileProof](https://scan.metamemo.one:8080/address/0x0c7B5A9Ce5e33B4fa1BcFaF9e8722B1c1c23243B/)) are deployed to the Memo chain and their code is not public, so the logic and security of the proving contracts is not verifiable.\n\n    ## L2s Data Availability\n    L2s can upload transaction data to Meeda through the MemoDA RPC, and the Meeda operator will generate an aggregated KZG polynomial commitment based on the transaction data. \n    Nodes can request transaction data on Meeda based on the commitment value of the transaction data.\n  "
      },
      "bridges": [
        {
          "id": "no-bridge",
          "type": "NoBridge",
          "createdAt": "1725887947",
          "display": {
            "name": "No bridge",
            "slug": "no-bridge",
            "description": "This project does not have a DA bridge on Ethereum.",
            "links": {
              "websites": [],
              "documentation": [],
              "repositories": [],
              "apps": [],
              "explorers": [],
              "socialMedia": []
            }
          },
          "risks": {
            "committeeSecurity": {
              "type": "NoBridge",
              "value": "N/A",
              "sentiment": "bad",
              "description": "Without a DA bridge, there is no committee attesting to the availability of data. The scaling solution using this DA layer relies only on the honesty of the sequencer."
            },
            "upgradeability": {
              "type": "NoBridge",
              "value": "N/A",
              "sentiment": "bad",
              "description": "There is no DA bridge from the DA layer to Ethereum. Projects using this layer without a bridge rely entirely on the sequencer's honesty (i.e., not publishing unavailable or invalid data). Without the bridge, users cannot react in time to malicious actions by the sequencer."
            },
            "relayerFailure": {
              "type": "NoBridge",
              "value": "N/A",
              "sentiment": "bad",
              "description": "The relayer does not contribute to the DA bridge liveness since data availability attestations are not integrated in the scaling solution's proof system."
            }
          },
          "technology": {
            "description": "There is no DA bridge on Ethereum.",
            "risks": null
          },
          "usedIn": [
            { "id": "metis", "name": "Metis Andromeda", "slug": "metis" }
          ],
          "otherConsiderations": null
        }
      ],
      "usedIn": [{ "id": "metis", "name": "Metis Andromeda", "slug": "metis" }],
      "pruningWindow": 0,
      "risks": {
        "economicSecurity": {
          "type": "OnChainNotSlashable",
          "value": "No slashing",
          "sentiment": "bad",
          "description": "Although node operators are required to stake  MEMO tokens to become members of the DA network, there is no slashing mechanism in place for misbehaving nodes."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      }
    },
    {
      "id": "dac",
      "type": "DaLayer",
      "kind": "DAC",
      "systemCategory": "custom",
      "display": {
        "name": "FraxtalDA",
        "slug": "fraxtal",
        "description": "FraxtalDA is a custom data availability solution built by the Fraxtal team.",
        "links": {
          "websites": ["https://frax.com/"],
          "apps": ["https://app.frax.finance/"],
          "documentation": ["https://docs.frax.com/"],
          "explorers": ["https://fraxscan.com/"],
          "repositories": ["https://github.com/FraxFinance"],
          "socialMedia": [
            "https://discord.com/invite/UJVtDTFRaA",
            "https://twitter.com/fraxfinance",
            "https://t.me/fraxfinance"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n    FraxtalDA is a custom data availability solution built by the Fraxtal team. \n    The data is posted by the OP batcher to three separate locations: AWS, IPFS, and Cloudfare R2. \n    The IPFS hash is then submitted to the on-chain inbox contract on Ethereum.\n    FraxtalDA relies on a single DA endpoint to manage data posting between the three different locations. \n\n    ![FraxtalDA](/images/da-layer-technology/fraxtalDA/FraxtalDA.png#center)\n    "
      },
      "bridges": [
        {
          "id": "no-bridge",
          "type": "NoBridge",
          "createdAt": "1726754891",
          "display": {
            "name": "No bridge",
            "slug": "no-bridge",
            "description": "The risk profile in this page refers to scaling solutions that do not integrate with a data availability bridge.",
            "links": {
              "websites": [],
              "documentation": [],
              "repositories": [],
              "apps": [],
              "explorers": [],
              "socialMedia": []
            }
          },
          "risks": {
            "committeeSecurity": {
              "type": "NoBridge",
              "value": "N/A",
              "sentiment": "bad",
              "description": "Without a DA bridge, there is no committee attesting to the availability of data. The scaling solution using this DA layer relies only on the honesty of the sequencer."
            },
            "upgradeability": {
              "type": "NoBridge",
              "value": "N/A",
              "sentiment": "bad",
              "description": "There is no DA bridge from the DA layer to Ethereum. Projects using this layer without a bridge rely entirely on the sequencer's honesty (i.e., not publishing unavailable or invalid data). Without the bridge, users cannot react in time to malicious actions by the sequencer."
            },
            "relayerFailure": {
              "type": "NoBridge",
              "value": "N/A",
              "sentiment": "bad",
              "description": "The relayer does not contribute to the DA bridge liveness since data availability attestations are not integrated in the scaling solution's proof system."
            }
          },
          "technology": {
            "description": "No DA bridge is selected. Without a DA bridge, Ethereum has no proof of data availability for this project.\n",
            "risks": null
          },
          "usedIn": [{ "id": "fraxtal", "name": "Fraxtal", "slug": "fraxtal" }],
          "otherConsiderations": null
        }
      ],
      "usedIn": [{ "id": "fraxtal", "name": "Fraxtal", "slug": "fraxtal" }],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      }
    },
    {
      "id": "dac",
      "type": "DaLayer",
      "kind": "DAC",
      "systemCategory": "custom",
      "display": {
        "name": "Mantle DA",
        "slug": "mantle",
        "description": "Mantle DA is a data availability solution built on EigenDA contracts, which have been forked and significantly modified.",
        "links": {
          "websites": ["https://mantle.xyz"],
          "documentation": [
            "https://docs-v2.mantle.xyz/intro/risk-management/da"
          ],
          "repositories": ["https://github.com/mantlenetworkio"],
          "apps": [],
          "explorers": ["https://explorer.mantle.xyz/mantle-da"],
          "socialMedia": [
            "https://twitter.com/0xMantle",
            "https://t.me/mantlenetwork"
          ]
        }
      },
      "technology": {
        "description": "\n    ## Architecture\n\n    Mantle DA is an independent DA module that is built on top of an early version of EigenDA smart contracts.\n    The system is made up of two main component: onchain smart contracts for storing and verifying data committments, and an offchain network of permissioned nodes storing the data.\n    The permissioned set of nodes is tasked with providing data availability to the Mantle network. \n    They receive Mantle network transaction data, sign it using a BLS signature scheme, and send back signatures to the sequencer to post commitments to the DataLayrServiceManager (DA Bridge) contract on Ethereum.\n    The DA DataLayrServiceManager acts as a verifier smart contract,  verifying that the signatures provided by the sequencer are indeed from node operators who have agreed to be in the quorum.\n    To become members of the DA network, node operators are required to stake 100,000 MNT tokens, and can only be registered by an authorized entity. There is no slashing mechanism in place for misbehaving nodes.\n    "
      },
      "bridges": [
        {
          "id": "mantleDABridge",
          "createdAt": "1723022143",
          "type": "DAC",
          "display": {
            "name": "Mantle DAC",
            "slug": "dac",
            "description": "There is a Mantle DA bridge on Ethereum storing data availability commitments.",
            "links": {
              "websites": ["https://mantle.xyz"],
              "documentation": [
                "https://docs.mantle.xyz/network/introduction/concepts/data-availability"
              ],
              "repositories": ["https://github.com/mantlenetworkio"],
              "apps": [],
              "explorers": ["https://explorer.mantle.xyz/mantle-da"],
              "socialMedia": [
                "https://twitter.com/0xMantle",
                "https://t.me/mantlenetwork"
              ]
            }
          },
          "contracts": {
            "addresses": [
              {
                "name": "DataLayrServiceManager",
                "address": "0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x47D58744D8515d9aaEAf961bc03625118bd91EBb"],
                  "implementations": [
                    "0xAB42127980a3bff124E6465e097a5fC97228827e"
                  ]
                },
                "chain": "ethereum",
                "description": "This contract is the entry point for data availability commitments. It is responsible for storing transaction data headers and confirming the data store by verifying operators signatures."
              },
              {
                "name": "BLSRegistry",
                "address": "0x1eD35B793d887e028493dAC4a11AA5Feb811dd67",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x47D58744D8515d9aaEAf961bc03625118bd91EBb"],
                  "implementations": [
                    "0x64F4244eEA17a361bb919A28F614C3ad1aC565ad"
                  ]
                },
                "chain": "ethereum",
                "description": "This contract stores the number of Mantle DA operators and their public keys. It also store the quorum threshold and the minimum stake required to be part of the quorum."
              },
              {
                "name": "RegistryPermission",
                "address": "0xBcF6d8273DAF842b6Fc288b08E48C438Fa911D01",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x2Cd33d3DC4d6Ea24B6941e4741F4Bf4772929e83"],
                  "implementations": [
                    "0xAb00B934DE01c1b4931047125C2ba5B3d6186b85"
                  ]
                },
                "chain": "ethereum",
                "description": "This contract is used to manage permissions for the BLSRegistry contract."
              },
              {
                "name": "PauserRegistry",
                "address": "0x075a48633dc6845f92339741E9c96b88f1b2A86f",
                "upgradeability": null,
                "chain": "ethereum",
                "description": "This contract is used to manage permissions for the DataLayrServiceManager contract."
              }
            ],
            "risks": []
          },
          "technology": {
            "description": " The DA bridge contract is used for storing transaction data headers and confirming the data store by verifying operators signatures.\n      The Mantle sequencer posts the data hash as a commitment to the DataLayrServiceManager contract on Ethereum thorugh an InitDataStore() transaction.\n      Once the commitment is posted, the sequencer sends the data to the permissioned set of nodes, who sign the data and send back the signatures to the sequencer.\n      The sequencer then posts the signatures to the DataLayrServiceManager contract on Ethereum through a confirmDataStore() transaction.\n      The confirmDataStore() function verify the signatures and if the quorum is reached, the data is considered available.\n    "
          },
          "permissions": [
            {
              "name": "MantleEngineeringMultisig",
              "description": "This is a Gnosis Safe with 3 / 7 threshold.  The owner of the DA bridge. This entity is responsible for managing the bridge, it can pause the bridge and change various parameters such as the quorum threshold and service fee for node operators.",
              "accounts": [
                {
                  "address": "0x2F44BD2a54aC3fB20cd7783cF94334069641daC9",
                  "type": "MultiSig"
                }
              ],
              "chain": "ethereum",
              "references": null,
              "participants": [
                {
                  "address": "0xC37642355c18ec9c3b3268AAC67e33516aa115eb",
                  "type": "EOA"
                },
                {
                  "address": "0x207E804758e28F2b3fD6E4219671B327100b82f8",
                  "type": "EOA"
                },
                {
                  "address": "0x5a021DC06A9630bb56099b8aEdfaDC2dEa7eB317",
                  "type": "EOA"
                },
                {
                  "address": "0x00da2F87c56C3a19BD863613995705095F55b524",
                  "type": "EOA"
                },
                {
                  "address": "0xbE73dea9c8DcDdB6b03F7e5797b85982065fe34e",
                  "type": "EOA"
                },
                {
                  "address": "0x3Dc5FcB0Ad5835C6059112e51A75b57DBA668eB8",
                  "type": "EOA"
                },
                {
                  "address": "0x915dc866e2e5E64f912A5ac1D40E3be4597F172a",
                  "type": "EOA"
                }
              ]
            },
            {
              "name": "Permissioned Operators",
              "description": "List of addresses authorized to sign data commitments for the DA bridge.",
              "accounts": [
                {
                  "address": "0x1888e4aC2Ab37A73B33448B87bABdD1ce1dcBAbe",
                  "type": "EOA"
                },
                {
                  "address": "0x717c3DC6Df69c316d6Ac593077BC84Cc86f214A4",
                  "type": "EOA"
                },
                {
                  "address": "0x8BEF0466b7C2CbFD753eF340e062dF06E93ADA7f",
                  "type": "EOA"
                },
                {
                  "address": "0x6cc5A6F5a9E4757790e4068Aa9757226Cb854B64",
                  "type": "EOA"
                },
                {
                  "address": "0xc1dEd495E1dDf089B2b41d6397C0aBa04BDA1A21",
                  "type": "EOA"
                },
                {
                  "address": "0x550b3CB2D5fB5E4F0A08322CaC7b04291558CDa8",
                  "type": "EOA"
                },
                {
                  "address": "0xB61298691FE0df10634A67dd83b2253E74cbF7fb",
                  "type": "EOA"
                },
                {
                  "address": "0xcEb157a9bB9c80a845d5924e8CEAA591Caf705a5",
                  "type": "EOA"
                },
                {
                  "address": "0x0B6F2C77C3740A5e6f88A4eCdd02C10BE8a2e323",
                  "type": "EOA"
                },
                {
                  "address": "0x8A3D6c77E5BAcE8cb0822B28E4Fc56FC06fB5645",
                  "type": "EOA"
                }
              ]
            },
            {
              "name": "Permission Data Store",
              "description": "List of addresses authorized to post data commitments to the DA bridge.",
              "accounts": [
                {
                  "address": "0x2f40D796917ffB642bD2e2bdD2C762A5e40fd749",
                  "type": "EOA"
                },
                {
                  "address": "0x50Fa427235C7C8cAA4A0C21b5009f5a0d015B23A",
                  "type": "EOA"
                }
              ]
            },
            {
              "name": "Permissioned Register Operator",
              "description": "List of addresses authorized to register or change status of DA node operators.",
              "accounts": [
                {
                  "address": "0x1888e4aC2Ab37A73B33448B87bABdD1ce1dcBAbe",
                  "type": "EOA"
                },
                {
                  "address": "0x717c3DC6Df69c316d6Ac593077BC84Cc86f214A4",
                  "type": "EOA"
                },
                {
                  "address": "0x8BEF0466b7C2CbFD753eF340e062dF06E93ADA7f",
                  "type": "EOA"
                },
                {
                  "address": "0xc1dEd495E1dDf089B2b41d6397C0aBa04BDA1A21",
                  "type": "EOA"
                },
                {
                  "address": "0x6cc5A6F5a9E4757790e4068Aa9757226Cb854B64",
                  "type": "EOA"
                },
                {
                  "address": "0x550b3CB2D5fB5E4F0A08322CaC7b04291558CDa8",
                  "type": "EOA"
                },
                {
                  "address": "0x8A3D6c77E5BAcE8cb0822B28E4Fc56FC06fB5645",
                  "type": "EOA"
                },
                {
                  "address": "0xB61298691FE0df10634A67dd83b2253E74cbF7fb",
                  "type": "EOA"
                },
                {
                  "address": "0xcEb157a9bB9c80a845d5924e8CEAA591Caf705a5",
                  "type": "EOA"
                },
                {
                  "address": "0x0B6F2C77C3740A5e6f88A4eCdd02C10BE8a2e323",
                  "type": "EOA"
                }
              ]
            }
          ],
          "chain": 1,
          "transactionDataType": {
            "type": "TransactionData",
            "value": "Transaction data",
            "description": "TODO"
          },
          "requiredMembers": 9,
          "membersCount": 10,
          "usedIn": [{ "id": "mantle", "name": "Mantle", "slug": "mantle" }],
          "risks": {
            "committeeSecurity": {
              "type": "NoCommiteeSecurity",
              "value": "No Committee Security",
              "sentiment": "bad",
              "description": "The committee does not meet basic security standards, either due to insufficient size, lack of member diversity, or poorly defined threshold parameters. \n    The system lacks an effective DA bridge and it is reliant on the assumption of an honest sequencer, creating significant risks to data integrity and availability."
            },
            "upgradeability": {
              "type": "LowOrNoDelay",
              "value": "None",
              "sentiment": "bad",
              "description": "There is no delay in the upgradeability of the bridge. Users have no time to exit the system before the bridge implementation update is completed."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          }
        }
      ],
      "usedIn": [{ "id": "mantle", "name": "Mantle", "slug": "mantle" }],
      "risks": {
        "economicSecurity": {
          "type": "OnChainNotSlashable",
          "value": "No slashing",
          "sentiment": "bad",
          "description": "Although node operators are required to stake  MNT tokens to become members of the DA network, there is no slashing mechanism in place for misbehaving nodes."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      }
    },
    {
      "id": "eigen-da",
      "type": "DaLayer",
      "kind": "DA Service",
      "systemCategory": "public",
      "display": {
        "name": "EigenDA",
        "slug": "eigenda",
        "description": "EigenDA is a data availability solution built on Eigen Layer.",
        "links": {
          "websites": ["https://www.eigenda.xyz/"],
          "documentation": ["https://docs.eigenda.xyz/overview"],
          "repositories": ["https://github.com/Layr-Labs/eigenda"],
          "apps": [],
          "explorers": ["https://blobs.eigenda.xyz/"],
          "socialMedia": ["https://x.com/eigen_da"]
        }
      },
      "technology": {
        "description": "\n\n    ## Architecture\n\n    ![EigenDA architecture](/images/da-layer-technology/eigenda/architecture.png#center)\n\n    EigenDA is composed by three types of off-chain entities: node operators, a disperser and a retriever.\n    - EigenDA **operators** are node operators running the EigenDA node software and are registered to the EigenDA AVS in EigenLayer.\n    - The **disperser** is the entity resposible for collecting the blobs from the sequencer, erasure coding them and generating the encoded blob's KZG commitments for each chunk. Although the disperser could be rollup-operated, it is currently a centralised entity operated by Eigen Labs.\n    - Lastly, the **retriever** client is responsible for querying the EigenDA operators to retrieve blob chunks, verifying their integrity and reconstructs the original blob. \n    \n    ### Operators Registration \n    Operators register with the EigenDAServiceManager via the registerOperatorToAVS() function, enabling them to participate in the data availability network. They are resposible for holding and serving blobs data, and earn rewards for their participation in the network.\n\n    ![EigenDA operator registration](/images/da-layer-technology/eigenda/registration.png#center)\n\n    ### Operators Stake Update  \n    \n    EigenDA operators' stake for quorum verification is fetched from the EigenDA StakeRegistry contract. To keep the stake in sync with changes in share balances in the EigenLayer DelegationManager (e.g., due to tokens delegated/undelegated to operators), the permissionless updateOperatorStake() function on the RegistryCoordinator contract needs to be called periodically. This function updates the operators' quorum weight in the StakeRegistry contract based on the operators' shares in the EigenLayer DelegationManager contract.\n    ![EigenDA operator stake sync](/images/da-layer-technology/eigenda/stakesync.png#center)\n\n    ### Operators Blob Storage and Retrieval \n\n    The process of storing a blob on EigenDA works as follows. A sequencer submits blobs to the EigenDA Disperser, which erasure codes the blobs into chunks and generates KZG commitments and proofs for each chunk, certifying the correctness of the data. The disperser then sends the chunks, KZG commitments, and KZG proofs to the operators.\n    Multiple operators are responsible for storing chunks of the encoded data blobs and their associated KZG commitment and proof.\n    Once the chunks, KZG commitments, and KZG proofs are sent to the operators, each of them generates a signature certifying that they have stored the data. These signatures are then sent to the Disperser which aggregates them and uploads them to Ethereum by sending a transaction to the EigenDAServiceManager (the DA bridge).\n    \n    ![EigenDA storing/retrieving](/images/da-layer-technology/eigenda/storing-retrieving.png#center)\n\n    ## L2 Data Availability\n    The Disperser collects the operators' signatures and submits them to the EigenDAServiceManager contract via the confirmBatch() function. This submission includes a call to the BLSRegistry contract to verify signatures and check whether the required quorum of operators' stake has been achieved.\n    Threshold BLS signatures are not used. Instead, the threshold check is performed on the signers' total stake fetched by the StakeRegistry, and the stake threshold percentage to reach is provided in the batch header input data.\n\n    The EigenDARollupUtils.sol library's verifyBlob() function can then used by scaling solutions to verify that a data blob is included within a confirmed batch in the EigenDAServiceManager. \n\n  ",
        "risks": [
          {
            "category": "Funds can be lost if",
            "text": "the disperser posts an invalid commitment and EigenDA operators do not make the data available for verification."
          },
          {
            "category": "Users can be censored if",
            "text": "the disperser does not distribute data to EigenDA operators."
          }
        ]
      },
      "bridges": [
        {
          "id": "no-bridge",
          "type": "NoBridge",
          "createdAt": "1724426960",
          "display": {
            "name": "No bridge",
            "slug": "no-bridge",
            "description": "The risk profile in this page refers to scaling solutions that do not integrate with a data availability bridge.",
            "links": {
              "websites": [],
              "documentation": [],
              "repositories": [],
              "apps": [],
              "explorers": [],
              "socialMedia": []
            }
          },
          "risks": {
            "committeeSecurity": {
              "type": "NoBridge",
              "value": "N/A",
              "sentiment": "bad",
              "description": "Without a DA bridge, there is no committee attesting to the availability of data. The scaling solution using this DA layer relies only on the honesty of the sequencer."
            },
            "upgradeability": {
              "type": "NoBridge",
              "value": "N/A",
              "sentiment": "bad",
              "description": "There is no DA bridge from the DA layer to Ethereum. Projects using this layer without a bridge rely entirely on the sequencer's honesty (i.e., not publishing unavailable or invalid data). Without the bridge, users cannot react in time to malicious actions by the sequencer."
            },
            "relayerFailure": {
              "type": "NoBridge",
              "value": "N/A",
              "sentiment": "bad",
              "description": "The relayer does not contribute to the DA bridge liveness since data availability attestations are not integrated in the scaling solution's proof system."
            }
          },
          "technology": {
            "description": "No DA bridge is selected. Without a DA bridge, Ethereum has no proof of data availability for this project.\n",
            "risks": null
          },
          "usedIn": [{ "id": "donatuz", "name": "Donatuz", "slug": "donatuz" }],
          "otherConsiderations": null
        },
        {
          "id": "eigenda-bridge",
          "createdAt": "1724426960",
          "type": "DAC",
          "display": {
            "name": "ServiceManager",
            "slug": "bridge",
            "description": "EigenDA DA attestations are bridged to Ethereum through the EigenDAServiceManager smart contract.",
            "links": {
              "websites": [],
              "documentation": [],
              "repositories": [],
              "apps": [],
              "explorers": [],
              "socialMedia": []
            }
          },
          "contracts": {
            "addresses": [
              {
                "name": "EigenDAServiceManager",
                "address": "0x870679E138bCdf293b7Ff14dD44b70FC97e12fc0",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x8247EF5705d3345516286B72bFE6D690197C2E99"],
                  "implementations": [
                    "0x58fDE694Db83e589ABb21A6Fe66cb20Ce5554a07"
                  ]
                },
                "chain": "ethereum",
                "description": "The EigenDAServiceManager contract is the bridge contract that accepts blob batches data availability attestations. Batches availability is attested by EigenDA operators signatures and relayed to the service manager contract by the EigenDA disperser.",
                "upgradableBy": ["EigenDAProxyAdmin"],
                "upgradeDelay": "No delay"
              },
              {
                "name": "RegistryCoordinator",
                "address": "0x0BAAc79acD45A023E19345c352d8a7a83C4e5656",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x8247EF5705d3345516286B72bFE6D690197C2E99"],
                  "implementations": [
                    "0xdcabf0bE991d4609096CCe316df08d091356E03F"
                  ]
                },
                "chain": "ethereum",
                "description": "Contract used by operators to register with the EigenDA AVS. The coordinator has three registries: a StakeRegistry that keeps track of operators' stakes, a BLSApkRegistry that keeps track of operators' BLS public keys and aggregate BLS public keys for each quorum, and an IndexRegistry that keeps track of an ordered list of operators for each quorum.",
                "upgradableBy": ["EigenDAProxyAdmin"],
                "upgradeDelay": "No delay"
              },
              {
                "name": "StakeRegistry",
                "address": "0x006124Ae7976137266feeBFb3F4D2BE4C073139D",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x8247EF5705d3345516286B72bFE6D690197C2E99"],
                  "implementations": [
                    "0x1C468cf7089D263c2f53e2579b329B16aBc4dd96"
                  ]
                },
                "chain": "ethereum",
                "description": "The StakeRegistry contract keeps track of the total stake of each operator.",
                "upgradableBy": ["EigenDAProxyAdmin"],
                "upgradeDelay": "No delay"
              },
              {
                "name": "BLSApkRegistry",
                "address": "0x00A5Fd09F6CeE6AE9C8b0E5e33287F7c82880505",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x8247EF5705d3345516286B72bFE6D690197C2E99"],
                  "implementations": [
                    "0x5d0B9cE2e277Daf508528E9f6Bf6314E79e4eD2b"
                  ]
                },
                "chain": "ethereum",
                "description": "The BLSApkRegistry contract keeps track of the BLS public keys of each operator and the quorum aggregated keys.",
                "upgradableBy": ["EigenDAProxyAdmin"],
                "upgradeDelay": "No delay"
              },
              {
                "name": "EjectionManager",
                "address": "0x130d8EA0052B45554e4C99079B84df292149Bd5E",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x8247EF5705d3345516286B72bFE6D690197C2E99"],
                  "implementations": [
                    "0x33A517608999DF5CEfFa2b2EbA88B4461c26Af6f"
                  ]
                },
                "chain": "ethereum",
                "description": "The EjectionManager contract is responsible for ejecting operators from a quorum for violating the Service Legal Agreement (SLA).",
                "upgradableBy": ["EigenDAProxyAdmin"],
                "upgradeDelay": "No delay"
              },
              {
                "name": "PauserRegistry",
                "address": "0x0c431C66F4dE941d089625E5B423D00707977060",
                "upgradeability": null,
                "chain": "ethereum",
                "description": "Defines and stores pauser and unpauser roles for EigenLayer contracts and the EigenDAServiceManager."
              },
              {
                "name": "DelegationManager",
                "address": "0x39053D51B77DC0d36036Fc1fCc8Cb819df8Ef37A",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x8b9566AdA63B64d1E1dcF1418b43fd1433b72444"],
                  "implementations": [
                    "0x1784BE6401339Fc0Fedf7E9379409f5c1BfE9dda"
                  ]
                },
                "chain": "ethereum",
                "description": "The DelegationManager contract is responsible for registering EigenLayer operators and managing the EigenLayer strategies delegations. The EigenDA StakeRegistry contract reads from the DelegationManager to track the total stake of each EigenDA operator.",
                "upgradableBy": [
                  "EigenLayerCommunityMultisig",
                  "EigenLayerOperationsMultisig"
                ],
                "upgradeDelay": "10d delay via EigenLayerOperationsMultisig, no delay via EigenLayerCommunityMultisig."
              },
              {
                "name": "StrategyManager",
                "address": "0x858646372CC42E1A627fcE94aa7A7033e7CF075A",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x8b9566AdA63B64d1E1dcF1418b43fd1433b72444"],
                  "implementations": [
                    "0x70f44C13944d49a236E3cD7a94f48f5daB6C619b"
                  ]
                },
                "chain": "ethereum",
                "description": "The StrategyManager contract is responsible for managing the EigenLayer token strategies. Each EigenDA quorum has at least one strategy that defines the operators quorum stake.",
                "upgradableBy": [
                  "EigenLayerCommunityMultisig",
                  "EigenLayerOperationsMultisig"
                ],
                "upgradeDelay": "10d delay via EigenLayerOperationsMultisig, no delay via EigenLayerCommunityMultisig."
              },
              {
                "name": "EigenStrategy",
                "address": "0xaCB55C530Acdb2849e6d4f36992Cd8c9D50ED8F7",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0x8b9566AdA63B64d1E1dcF1418b43fd1433b72444"],
                  "implementations": [
                    "0x27e7a3A81741B9fcc5Ad7edCBf9F8a72a5c00428"
                  ]
                },
                "chain": "ethereum",
                "description": "The EigenStrategy contract is responsible for managing the bEIGEN token strategy, representing the stake for the second EigenDA quorum.",
                "upgradableBy": [
                  "EigenLayerCommunityMultisig",
                  "EigenLayerOperationsMultisig"
                ],
                "upgradeDelay": "10d delay via EigenLayerOperationsMultisig, no delay via EigenLayerCommunityMultisig."
              },
              {
                "name": "EIGEN token",
                "address": "0xec53bF9167f50cDEB3Ae105f56099aaaB9061F83",
                "upgradeability": {
                  "proxyType": "EIP1967 proxy",
                  "admins": ["0xB8915E195121f2B5D989Ec5727fd47a5259F1CEC"],
                  "implementations": [
                    "0x17f56E911C279bad67eDC08acbC9cf3DC4eF26A0"
                  ]
                },
                "chain": "ethereum",
                "description": "The EIGEN token can be socially forked to slash operators for data withholding attacks (and other intersubjectively attributable faults).\n              EIGEN is a wrapper over a second token, bEIGEN, which will be used solely for intersubjective staking. Forking EIGEN means changing the canonical implementation of the bEIGEN token in the EIGEN token contract.",
                "upgradableBy": ["EIGEN Timelock"],
                "upgradeDelay": "10d delay."
              }
            ],
            "risks": [
              {
                "category": "Funds can be lost if",
                "text": "the bridge (EigenDAServiceManager) contract receives a malicious code upgrade. There is no delay on code upgrades."
              },
              {
                "category": "Funds can be lost if",
                "text": "EigenLayer core contracts (DelegationManager, StrategyManager) receive a malicious code upgrade. There is no delay on code upgrades."
              },
              {
                "category": "Funds can be lost if",
                "text": "EigenLayer EIGEN token contract receives a malicious code upgrade. There is a 10d delay on code upgrades."
              },
              {
                "category": "Funds can be lost if",
                "text": "the churn approver or ejectors act maliciously and eject EigenDA operators from a quorum without cause."
              }
            ]
          },
          "technology": {
            "description": "\n    ## Architecture\n\n    ![EigenDA architecture once stored](/images/da-bridge-technology/eigenda/architecture1.png#center)\n\n    The EigenDAServiceManager acts as a DA bridge smart contract verifying data availability claims from operators via signature verification.\n    The checkSignature function checks that the signature of all signers plus non-signers is equal to the registered quorum aggregated public key from the BLS registry. The quorum aggregated public key gets updated every time an operator is registered.\n    The bridge requires a threshold of signatures to be met before the data commitment is accepted. \n    To verify the threshold is met, the function takes the total stake at the reference block for the quorum from the StakeRegistry, and it subtracts the stake of non signers to get the signed stake.\n    Finally, it checks that the signed stake over the total stake is more than the required stake threshold.\n\n    ![EigenDA bridge architecture](/images/da-bridge-technology/eigenda/architecture2.png#center)\n\n    Although thresholds are not enforced by the confirmBatch method, current quorum thresholds are set to 55% of registered stake for the ETH quorum and 55% for the EIGEN token quorum. The quorum thresholds are set on the EigenDAServiceManager contract and can be changed by the contract owner.\n    There is a maximum of 200 operators that can register for the ETH quorum and 200 for the EIGEN token quorum. Once the cap is reached, new operators must have 10% more weight than the lowest-weighted operator to join the active set. Entering the quorum is subject to the approval of the churn approver. Operators can be ejected from a quorum by the ejectors without delay should they violate the Service Legal Agreement (SLA). \n\n\n    Ejectors can eject maximum 33.33% of the total stake in a 7d window for the ETH quorum, and the same stake percentage over a 3d window for the EIGEN quorum.\n    An ejected operator can rejoin the quorum after 3d. \n  ",
            "risks": [
              {
                "category": "Funds can be frozen if",
                "text": "the permissioned relayers are unable to submit DA commitments to the Vector contract."
              },
              {
                "category": "Funds can be frozen if",
                "text": "the bridge (EigenDAServiceManager) contract is paused by the pausers."
              }
            ]
          },
          "permissions": [
            {
              "name": "EigenDAProxyAdmin",
              "description": "The contract authorized to upgrade the core EigenDA contracts.",
              "accounts": [
                {
                  "address": "0x8247EF5705d3345516286B72bFE6D690197C2E99",
                  "type": "Contract"
                }
              ],
              "participants": [
                {
                  "address": "0x369e6F597e22EaB55fFb173C6d9cD234BD699111",
                  "type": "MultiSig"
                }
              ]
            },
            {
              "name": "BatchConfirmers",
              "description": "The list of addresses authorized to confirm the availability of blobs batches to the DA bridge.",
              "accounts": [
                {
                  "address": "0x8ED83c6Bb12E441Ca2C3a544F525d4a3Fb6484D8",
                  "type": "EOA"
                },
                {
                  "address": "0x5A49Bf6c5690E22dFff3eB37F7dd18254eC361ED",
                  "type": "EOA"
                },
                {
                  "address": "0x454Ef2f69f91527856E06659f92a66f464C1ca4e",
                  "type": "EOA"
                }
              ]
            },
            {
              "name": "Pausers",
              "description": "The list of addresses authorized to pause the EigenDAServiceManager contract.",
              "accounts": [
                {
                  "address": "0xBE1685C81aA44FF9FB319dD389addd9374383e90",
                  "type": "EOA"
                },
                {
                  "address": "0x5050389572f2d220ad927CcbeA0D406831012390",
                  "type": "EOA"
                },
                {
                  "address": "0x369e6F597e22EaB55fFb173C6d9cD234BD699111",
                  "type": "EOA"
                }
              ]
            },
            {
              "name": "ChurnApprover",
              "description": "The address authorized to approve the replacement of churned EigenDA operators from a quorum.",
              "accounts": [
                {
                  "address": "0xe0550117Cb066D3b330eBd764B0d75D3BA378734",
                  "type": "EOA"
                }
              ]
            },
            {
              "name": "Ejectors",
              "description": "The list of addresses authorized to eject EigenDA operators from a quorum.",
              "accounts": [
                {
                  "address": "0xD2Ee81Cf07B12140C793FcE5B26313CDd9d78eA8",
                  "type": "EOA"
                }
              ]
            },
            {
              "name": "EigenLayerProxyAdmin",
              "description": "The contract authorized to upgrade the core EigenLayer contracts.",
              "accounts": [
                {
                  "address": "0x8b9566AdA63B64d1E1dcF1418b43fd1433b72444",
                  "type": "Contract"
                }
              ],
              "participants": [
                {
                  "address": "0x369e6F597e22EaB55fFb173C6d9cD234BD699111",
                  "type": "MultiSig"
                }
              ]
            },
            {
              "name": "EigenLayerExecutorMultisig",
              "description": "This is a Gnosis Safe with 1 / 2 threshold.  The proxy contract authorized to unpause the EigenDAServiceManager contract and upgrade core contracts through the EigenDAProxyAdmin contract.",
              "accounts": [
                {
                  "address": "0x369e6F597e22EaB55fFb173C6d9cD234BD699111",
                  "type": "MultiSig"
                }
              ],
              "chain": "ethereum",
              "references": null,
              "participants": [
                {
                  "address": "0xA6Db1A8C5a981d1536266D2a393c5F8dDb210EAF",
                  "type": "Contract"
                },
                {
                  "address": "0xFEA47018D632A77bA579846c840d5706705Dc598",
                  "type": "MultiSig"
                }
              ]
            },
            {
              "name": "EigenLayerOperationsMultisig",
              "description": "This is a Gnosis Safe with 3 / 6 threshold.  This multisig is the owner of the EigenDAServiceManager contract. It holds the power to change the contract state and upgrade the bridge.",
              "accounts": [
                {
                  "address": "0xBE1685C81aA44FF9FB319dD389addd9374383e90",
                  "type": "MultiSig"
                }
              ],
              "chain": "ethereum",
              "references": null,
              "participants": [
                {
                  "address": "0xdC541e2B4adD96888b2C79006F49A9748A4f1bDF",
                  "type": "EOA"
                },
                {
                  "address": "0xa2425B00F9A9457AEdd51d4C36d9917eA1Aa7a02",
                  "type": "EOA"
                },
                {
                  "address": "0xb7Ae34BB33da55f12797e793E01e63a17B11d108",
                  "type": "EOA"
                },
                {
                  "address": "0x27ff193A6A1574A611E21c39FDA636fA1d61ba30",
                  "type": "EOA"
                },
                {
                  "address": "0x422e2F724faFE75F3635458aD7D3Ac803DCD7ff1",
                  "type": "EOA"
                },
                {
                  "address": "0xe7fFd467F7526abf9c8796EDeE0AD30110419127",
                  "type": "EOA"
                }
              ]
            },
            {
              "name": "EigenLayerCommunityMultisig",
              "description": "This is a Gnosis Safe with 9 / 13 threshold.  This multisig is one of the owners of EigenLayerExecutorMultisig and can upgrade EigenLayer core contracts without delay.",
              "accounts": [
                {
                  "address": "0xFEA47018D632A77bA579846c840d5706705Dc598",
                  "type": "MultiSig"
                }
              ],
              "chain": "ethereum",
              "references": null,
              "participants": [
                {
                  "address": "0x17919FAC7024d5b770322E5Cb81607D247654116",
                  "type": "EOA"
                },
                {
                  "address": "0x34C37613e1680efD9e203C979658e1d058b4B2BC",
                  "type": "EOA"
                },
                {
                  "address": "0x72Ff26D9517324eEFA89A48B75c5df41132c4f54",
                  "type": "EOA"
                },
                {
                  "address": "0x80cb2DA66A3ccb6064f16B15B6ae11d8E089C6D7",
                  "type": "EOA"
                },
                {
                  "address": "0x313011Ee87b12700E29B0D1136Ae3d64665F3939",
                  "type": "EOA"
                },
                {
                  "address": "0x97b4A6E0471A7c5906fF1Cc2a5970ed569B04815",
                  "type": "EOA"
                },
                {
                  "address": "0x65C4799061c0D1e3E87ADdB65b02E92a558F842F",
                  "type": "EOA"
                },
                {
                  "address": "0xe37756BEdDC89e94A8d557fd5b95a4D2a57e9D60",
                  "type": "EOA"
                },
                {
                  "address": "0x8ffCF07A59631f0578f3E84B51C48cF0dEADCd95",
                  "type": "EOA"
                },
                {
                  "address": "0xAF4D94Cd299211de542530399290877E2c85F061",
                  "type": "EOA"
                },
                {
                  "address": "0xe8F09A9D42aEA0a3B393aD06F25CF512eA51707e",
                  "type": "EOA"
                },
                {
                  "address": "0x6A662c5DdCe0b76BD081b8A4ec3A4F8a671b0b1f",
                  "type": "EOA"
                },
                {
                  "address": "0x33E816008E7bc7798A73d0eaa640CC24f34d1626",
                  "type": "EOA"
                }
              ]
            },
            {
              "name": "EigenLayer Timelock",
              "accounts": [
                {
                  "address": "0xA6Db1A8C5a981d1536266D2a393c5F8dDb210EAF",
                  "type": "Contract"
                }
              ],
              "chain": "ethereum",
              "description": "The timelock contract for upgrading EigenLayer core contracts via EigenLayerOperationsMultisig."
            }
          ],
          "chain": 1,
          "requiredMembers": 0,
          "membersCount": 400,
          "transactionDataType": {
            "type": "TransactionData",
            "value": "Transaction data",
            "description": "TODO"
          },
          "usedIn": [],
          "risks": {
            "committeeSecurity": {
              "type": "LimitedCommitteeSecurity",
              "value": "Permissioned",
              "sentiment": "warning",
              "description": "The committee requires an honest minority (1/3 or less) of members (or the network stake) to prevent the DA bridge from accepting an unavailable data commitment.\n    There are at least 5 external actors in the committee, but entry or exit of members is partially controlled by a centralized entity."
            },
            "upgradeability": {
              "type": "LowOrNoDelay",
              "value": "None",
              "sentiment": "bad",
              "description": "There is no delay in the upgradeability of the bridge. Users have no time to exit the system before the bridge implementation update is completed."
            },
            "relayerFailure": {
              "type": "NoMechanism",
              "value": "No mechanism",
              "sentiment": "bad",
              "description": "The DA bridge does not have a Security Council or a governance mechanism to propose new relayers.\n    In case of relayer failure, the DA bridge will halt and be unable to recover without the intervention of a centralized entity."
            }
          }
        }
      ],
      "usedIn": [],
      "risks": {
        "economicSecurity": {
          "type": "OnChainNotSlashable",
          "value": "Slashing under development",
          "sentiment": "bad",
          "description": "Node operators are required to stake a minimum of 32 ETH (first quorum) or 1 EIGEN (second quorum) to become members of the DA network. However, there is no slashing mechanism in place for misbehaving nodes. The EIGEN token social forking protocol for intersubjective attributable faults is under active development."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      }
    },
    {
      "id": "redstone-da",
      "type": "DaLayer",
      "kind": "DAC",
      "systemCategory": "custom",
      "display": {
        "name": "RedstoneDA",
        "slug": "redstone",
        "description": "RedstoneDA is a data availability solution using data availability challenges (DA Challenges).",
        "links": {
          "websites": ["https://redstone.xyz/"],
          "apps": ["https://redstone.xyz/deposit"],
          "documentation": ["https://redstone.xyz/docs"],
          "explorers": ["https://explorer.redstone.xyz/"],
          "repositories": ["https://github.com/latticexyz/redstone"],
          "socialMedia": [
            "https://twitter.com/redstonexyz",
            "https://discord.com/invite/latticexyz"
          ]
        }
      },
      "hasChallengeMechanism": true,
      "technology": {
        "description": "\n    ## Data Availability Challenges\n    Redstone relies on DA challenges for data availability. \n    The DA Provider submits an input commitment on Ethereum, and users can request the data behind the commitment off-chain from the DA Provider.\n    If a DA challenger finds that the data behind a tx data commitment is not available, they can submit a challenge which requires locking a bond within 12h. \n    A challenge can be resolved by publishing the preimage data within an additional 12h.\n    In such case, a portion of the challenger bond is burned, with the exact amount estimated as the cost incurred by the resolver to publish the full data, meaning that the resolver and challenger will approximately lose the same amount of funds.\n    The system is not secure if the malicious sequencer is able to outspend the altruistic challengers. \n    If instead, after a challenge, the preimage data is not published, the chain reorgs to the last fully derivable state.\n  "
      },
      "bridges": [
        {
          "id": "no-bridge",
          "type": "NoBridge",
          "createdAt": "1726747460",
          "display": {
            "name": "No bridge",
            "slug": "no-bridge",
            "description": "The risk profile in this page refers to scaling solutions that do not integrate with a data availability bridge.",
            "links": {
              "websites": [],
              "documentation": [],
              "repositories": [],
              "apps": [],
              "explorers": [],
              "socialMedia": []
            }
          },
          "risks": {
            "committeeSecurity": {
              "type": "NoBridge",
              "value": "N/A",
              "sentiment": "bad",
              "description": "Without a DA bridge, there is no committee attesting to the availability of data. The scaling solution using this DA layer relies only on the honesty of the sequencer."
            },
            "upgradeability": {
              "type": "NoBridge",
              "value": "N/A",
              "sentiment": "bad",
              "description": "There is no DA bridge from the DA layer to Ethereum. Projects using this layer without a bridge rely entirely on the sequencer's honesty (i.e., not publishing unavailable or invalid data). Without the bridge, users cannot react in time to malicious actions by the sequencer."
            },
            "relayerFailure": {
              "type": "NoBridge",
              "value": "N/A",
              "sentiment": "bad",
              "description": "The relayer does not contribute to the DA bridge liveness since data availability attestations are not integrated in the scaling solution's proof system."
            }
          },
          "technology": {
            "description": "No DA bridge is selected. Without a DA bridge, Ethereum has no proof of data availability for this project.\n        However, there is a mechanism that allows users to challenge unavailability of data. \n",
            "risks": null
          },
          "usedIn": [],
          "otherConsiderations": null
        }
      ],
      "usedIn": [{ "id": "redstone", "name": "Redstone", "slug": "redstone" }],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      }
    },
    {
      "id": "xterio-da",
      "type": "DaLayer",
      "kind": "DAC",
      "systemCategory": "custom",
      "display": {
        "name": "XterioDA",
        "slug": "xterio",
        "description": "XterioDA is a data availability solution using data availability challenges (DA Challenges).",
        "links": {
          "websites": ["https://xter.io/"],
          "apps": ["https://xter.io/", "https://eth-bridge.xter.io/"],
          "documentation": ["https://stack.optimism.io/"],
          "explorers": ["https://eth.xterscan.io/"],
          "repositories": ["https://github.com/XterioTech"],
          "socialMedia": [
            "https://x.com/XterioGames",
            "https://discord.gg/xterio",
            "https://medium.com/@XterioGames"
          ]
        }
      },
      "hasChallengeMechanism": true,
      "technology": {
        "description": "\n    ## Data Availability Challenges\n    Xterio relies on DA challenges for data availability. \n    The DA Provider submits an input commitment on Ethereum, and users can request the data behind the commitment off-chain from the DA Provider.\n    If a DA challenger finds that the data behind a tx data commitment is not available, they can submit a challenge which requires locking a bond within 12h. \n    A challenge can be resolved by publishing the preimage data within an additional 12h.\n    In such case, a portion of the challenger bond is burned, with the exact amount estimated as the cost incurred by the resolver to publish the full data, meaning that the resolver and challenger will approximately lose the same amount of funds.\n    The system is not secure if the malicious sequencer is able to outspend the altruistic challengers. \n    If instead, after a challenge, the preimage data is not published, the chain reorgs to the last fully derivable state.\n  "
      },
      "bridges": [
        {
          "id": "no-bridge",
          "type": "NoBridge",
          "createdAt": "1726747460",
          "display": {
            "name": "No bridge",
            "slug": "no-bridge",
            "description": "The risk profile in this page refers to scaling solutions that do not integrate with a data availability bridge.",
            "links": {
              "websites": [],
              "documentation": [],
              "repositories": [],
              "apps": [],
              "explorers": [],
              "socialMedia": []
            }
          },
          "risks": {
            "committeeSecurity": {
              "type": "NoBridge",
              "value": "N/A",
              "sentiment": "bad",
              "description": "Without a DA bridge, there is no committee attesting to the availability of data. The scaling solution using this DA layer relies only on the honesty of the sequencer."
            },
            "upgradeability": {
              "type": "NoBridge",
              "value": "N/A",
              "sentiment": "bad",
              "description": "There is no DA bridge from the DA layer to Ethereum. Projects using this layer without a bridge rely entirely on the sequencer's honesty (i.e., not publishing unavailable or invalid data). Without the bridge, users cannot react in time to malicious actions by the sequencer."
            },
            "relayerFailure": {
              "type": "NoBridge",
              "value": "N/A",
              "sentiment": "bad",
              "description": "The relayer does not contribute to the DA bridge liveness since data availability attestations are not integrated in the scaling solution's proof system."
            }
          },
          "technology": {
            "description": "No DA bridge is selected. Without a DA bridge, Ethereum has no proof of data availability for this project.\n        However, there is a mechanism that allows users to challenge unavailability of data. \n",
            "risks": null
          },
          "usedIn": [],
          "otherConsiderations": null
        }
      ],
      "usedIn": [{ "id": "xterio", "name": "Xterio Chain", "slug": "xterio" }],
      "risks": {
        "economicSecurity": {
          "type": "Unknown",
          "value": "None",
          "sentiment": "bad",
          "description": "There are no onchain assets at risk of being slashed in case of a data withholding attack, and the committee members are not publicly known."
        },
        "fraudDetection": {
          "type": "NoFraudDetection",
          "value": "None",
          "sentiment": "bad",
          "description": "There is no fraud detection mechanism in place. A data withholding attack can only be detected by nodes downloading the full data from the DA layer."
        }
      }
    }
  ],
  "meta": {
    "values": {
      "0.hasChallengeMechanism": ["undefined"],
      "0.technology.risks": ["undefined"],
      "0.bridges.0.createdAt": [["custom", "UnixTime"]],
      "0.bridges.0.display.warning": ["undefined"],
      "0.bridges.0.technology.risks": ["undefined"],
      "0.bridges.0.otherConsiderations": ["undefined"],
      "0.otherConsiderations": ["undefined"],
      "1.fallback": ["undefined"],
      "1.hasChallengeMechanism": ["undefined"],
      "1.technology.risks": ["undefined"],
      "1.bridges.0.createdAt": [["custom", "UnixTime"]],
      "1.bridges.0.contracts.addresses.0.upgradeability": ["undefined"],
      "1.bridges.0.display.warning": ["undefined"],
      "1.bridges.0.display.redWarning": ["undefined"],
      "1.bridges.0.technology.risks": ["undefined"],
      "1.bridges.0.otherConsiderations": ["undefined"],
      "1.otherConsiderations": ["undefined"],
      "2.hasChallengeMechanism": ["undefined"],
      "2.technology.risks": ["undefined"],
      "2.bridges.0.createdAt": [["custom", "UnixTime"]],
      "2.bridges.0.display.warning": ["undefined"],
      "2.bridges.0.technology.risks": ["undefined"],
      "2.bridges.0.otherConsiderations": ["undefined"],
      "2.otherConsiderations": ["undefined"],
      "3.fallback": ["undefined"],
      "3.hasChallengeMechanism": ["undefined"],
      "3.technology.risks": ["undefined"],
      "3.bridges.0.createdAt": [["custom", "UnixTime"]],
      "3.bridges.0.contracts.addresses.0.upgradeability": ["undefined"],
      "3.bridges.0.contracts.addresses.1.upgradeability": ["undefined"],
      "3.bridges.0.display.warning": ["undefined"],
      "3.bridges.0.display.redWarning": ["undefined"],
      "3.bridges.0.technology.risks": ["undefined"],
      "3.bridges.0.otherConsiderations": ["undefined"],
      "3.otherConsiderations": ["undefined"],
      "4.fallback": ["undefined"],
      "4.hasChallengeMechanism": ["undefined"],
      "4.technology.risks": ["undefined"],
      "4.bridges.0.createdAt": [["custom", "UnixTime"]],
      "4.bridges.0.technology.risks": ["undefined"],
      "4.bridges.0.permissions.1.references": ["undefined"],
      "4.bridges.0.display.warning": ["undefined"],
      "4.bridges.0.display.redWarning": ["undefined"],
      "4.bridges.0.otherConsiderations": ["undefined"],
      "4.otherConsiderations": ["undefined"],
      "5.hasChallengeMechanism": ["undefined"],
      "5.technology.risks": ["undefined"],
      "5.bridges.0.createdAt": [["custom", "UnixTime"]],
      "5.bridges.0.display.warning": ["undefined"],
      "5.bridges.0.technology.risks": ["undefined"],
      "5.bridges.0.otherConsiderations": ["undefined"],
      "5.otherConsiderations": ["undefined"],
      "6.fallback": ["undefined"],
      "6.hasChallengeMechanism": ["undefined"],
      "6.technology.risks": ["undefined"],
      "6.bridges.0.createdAt": [["custom", "UnixTime"]],
      "6.bridges.0.display.warning": ["undefined"],
      "6.bridges.0.display.redWarning": ["undefined"],
      "6.bridges.0.technology.risks": ["undefined"],
      "6.bridges.0.otherConsiderations": ["undefined"],
      "6.otherConsiderations": ["undefined"],
      "7.fallback": ["undefined"],
      "7.hasChallengeMechanism": ["undefined"],
      "7.technology.risks": ["undefined"],
      "7.bridges.0.createdAt": [["custom", "UnixTime"]],
      "7.bridges.0.contracts.addresses.0.upgradeability": ["undefined"],
      "7.bridges.0.display.warning": ["undefined"],
      "7.bridges.0.display.redWarning": ["undefined"],
      "7.bridges.0.technology.risks": ["undefined"],
      "7.bridges.0.otherConsiderations": ["undefined"],
      "7.otherConsiderations": ["undefined"],
      "8.fallback": ["undefined"],
      "8.hasChallengeMechanism": ["undefined"],
      "8.technology.risks": ["undefined"],
      "8.bridges.0.createdAt": [["custom", "UnixTime"]],
      "8.bridges.0.permissions.1.references": ["undefined"],
      "8.bridges.0.display.warning": ["undefined"],
      "8.bridges.0.display.redWarning": ["undefined"],
      "8.bridges.0.technology.risks": ["undefined"],
      "8.bridges.0.otherConsiderations": ["undefined"],
      "8.otherConsiderations": ["undefined"],
      "9.fallback": ["undefined"],
      "9.hasChallengeMechanism": ["undefined"],
      "9.technology.risks": ["undefined"],
      "9.bridges.0.createdAt": [["custom", "UnixTime"]],
      "9.bridges.0.display.warning": ["undefined"],
      "9.bridges.0.display.redWarning": ["undefined"],
      "9.bridges.0.technology.risks": ["undefined"],
      "9.bridges.0.otherConsiderations": ["undefined"],
      "9.otherConsiderations": ["undefined"],
      "10.fallback": ["undefined"],
      "10.hasChallengeMechanism": ["undefined"],
      "10.technology.risks": ["undefined"],
      "10.bridges.0.createdAt": [["custom", "UnixTime"]],
      "10.bridges.0.contracts.addresses.0.upgradeability": ["undefined"],
      "10.bridges.0.display.warning": ["undefined"],
      "10.bridges.0.display.redWarning": ["undefined"],
      "10.bridges.0.technology.risks": ["undefined"],
      "10.bridges.0.otherConsiderations": ["undefined"],
      "10.otherConsiderations": ["undefined"],
      "11.hasChallengeMechanism": ["undefined"],
      "11.technology.risks": ["undefined"],
      "11.bridges.0.createdAt": [["custom", "UnixTime"]],
      "11.bridges.0.display.warning": ["undefined"],
      "11.bridges.0.technology.risks": ["undefined"],
      "11.bridges.0.otherConsiderations": ["undefined"],
      "11.otherConsiderations": ["undefined"],
      "12.hasChallengeMechanism": ["undefined"],
      "12.technology.risks": ["undefined"],
      "12.bridges.0.createdAt": [["custom", "UnixTime"]],
      "12.bridges.0.display.warning": ["undefined"],
      "12.bridges.0.technology.risks": ["undefined"],
      "12.bridges.0.otherConsiderations": ["undefined"],
      "12.otherConsiderations": ["undefined"],
      "13.fallback": ["undefined"],
      "13.hasChallengeMechanism": ["undefined"],
      "13.technology.risks": ["undefined"],
      "13.bridges.0.createdAt": [["custom", "UnixTime"]],
      "13.bridges.0.permissions.1.references": ["undefined"],
      "13.bridges.0.display.warning": ["undefined"],
      "13.bridges.0.display.redWarning": ["undefined"],
      "13.bridges.0.technology.risks": ["undefined"],
      "13.bridges.0.otherConsiderations": ["undefined"],
      "13.otherConsiderations": ["undefined"],
      "14.fallback": ["undefined"],
      "14.hasChallengeMechanism": ["undefined"],
      "14.technology.risks": ["undefined"],
      "14.bridges.0.createdAt": [["custom", "UnixTime"]],
      "14.bridges.0.contracts.addresses.0.upgradeability": ["undefined"],
      "14.bridges.0.display.warning": ["undefined"],
      "14.bridges.0.display.redWarning": ["undefined"],
      "14.bridges.0.technology.risks": ["undefined"],
      "14.bridges.0.otherConsiderations": ["undefined"],
      "14.otherConsiderations": ["undefined"],
      "15.hasChallengeMechanism": ["undefined"],
      "15.technology.risks": ["undefined"],
      "15.bridges.0.createdAt": [["custom", "UnixTime"]],
      "15.bridges.0.display.warning": ["undefined"],
      "15.bridges.0.technology.risks": ["undefined"],
      "15.bridges.0.otherConsiderations": ["undefined"],
      "15.otherConsiderations": ["undefined"],
      "16.hasChallengeMechanism": ["undefined"],
      "16.technology.risks": ["undefined"],
      "16.bridges.0.createdAt": [["custom", "UnixTime"]],
      "16.bridges.0.display.warning": ["undefined"],
      "16.bridges.0.technology.risks": ["undefined"],
      "16.bridges.0.otherConsiderations": ["undefined"],
      "16.otherConsiderations": ["undefined"],
      "17.hasChallengeMechanism": ["undefined"],
      "17.technology.risks": ["undefined"],
      "17.bridges.0.createdAt": [["custom", "UnixTime"]],
      "17.bridges.0.display.warning": ["undefined"],
      "17.bridges.0.technology.risks": ["undefined"],
      "17.bridges.0.otherConsiderations": ["undefined"],
      "17.otherConsiderations": ["undefined"],
      "18.hasChallengeMechanism": ["undefined"],
      "18.technology.risks": ["undefined"],
      "18.bridges.0.createdAt": [["custom", "UnixTime"]],
      "18.bridges.0.display.warning": ["undefined"],
      "18.bridges.0.technology.risks": ["undefined"],
      "18.bridges.0.otherConsiderations": ["undefined"],
      "18.otherConsiderations": ["undefined"],
      "19.fallback": ["undefined"],
      "19.hasChallengeMechanism": ["undefined"],
      "19.technology.risks": ["undefined"],
      "19.bridges.0.createdAt": [["custom", "UnixTime"]],
      "19.bridges.0.contracts.addresses.0.upgradeability": ["undefined"],
      "19.bridges.0.display.warning": ["undefined"],
      "19.bridges.0.display.redWarning": ["undefined"],
      "19.bridges.0.technology.risks": ["undefined"],
      "19.bridges.0.otherConsiderations": ["undefined"],
      "19.otherConsiderations": ["undefined"],
      "20.hasChallengeMechanism": ["undefined"],
      "20.technology.risks": ["undefined"],
      "20.bridges.0.createdAt": [["custom", "UnixTime"]],
      "20.bridges.0.display.warning": ["undefined"],
      "20.bridges.0.technology.risks": ["undefined"],
      "20.bridges.0.otherConsiderations": ["undefined"],
      "20.otherConsiderations": ["undefined"],
      "21.hasChallengeMechanism": ["undefined"],
      "21.technology.risks": ["undefined"],
      "21.bridges.0.createdAt": [["custom", "UnixTime"]],
      "21.bridges.0.display.warning": ["undefined"],
      "21.bridges.0.technology.risks": ["undefined"],
      "21.bridges.0.otherConsiderations": ["undefined"],
      "21.otherConsiderations": ["undefined"],
      "22.hasChallengeMechanism": ["undefined"],
      "22.technology.risks": ["undefined"],
      "22.bridges.0.createdAt": [["custom", "UnixTime"]],
      "22.bridges.0.display.warning": ["undefined"],
      "22.bridges.0.technology.risks": ["undefined"],
      "22.bridges.0.otherConsiderations": ["undefined"],
      "22.otherConsiderations": ["undefined"],
      "23.fallback": ["undefined"],
      "23.hasChallengeMechanism": ["undefined"],
      "23.technology.risks": ["undefined"],
      "23.bridges.0.createdAt": [["custom", "UnixTime"]],
      "23.bridges.0.display.warning": ["undefined"],
      "23.bridges.0.technology.risks": ["undefined"],
      "23.bridges.0.otherConsiderations": ["undefined"],
      "23.otherConsiderations": ["undefined"],
      "24.fallback": ["undefined"],
      "24.hasChallengeMechanism": ["undefined"],
      "24.technology.risks": ["undefined"],
      "24.bridges.0.createdAt": [["custom", "UnixTime"]],
      "24.bridges.0.display.warning": ["undefined"],
      "24.bridges.0.technology.risks": ["undefined"],
      "24.bridges.0.otherConsiderations": ["undefined"],
      "24.otherConsiderations": ["undefined"],
      "25.fallback": ["undefined"],
      "25.hasChallengeMechanism": ["undefined"],
      "25.technology.risks": ["undefined"],
      "25.bridges.0.createdAt": [["custom", "UnixTime"]],
      "25.bridges.0.display.warning": ["undefined"],
      "25.bridges.0.technology.risks": ["undefined"],
      "25.bridges.0.otherConsiderations": ["undefined"],
      "25.otherConsiderations": ["undefined"],
      "26.hasChallengeMechanism": ["undefined"],
      "26.technology.risks": ["undefined"],
      "26.bridges.0.createdAt": [["custom", "UnixTime"]],
      "26.bridges.0.permissions.1.references": ["undefined"],
      "26.bridges.0.display.warning": ["undefined"],
      "26.bridges.0.technology.risks": ["undefined"],
      "26.bridges.0.otherConsiderations": ["undefined"],
      "26.otherConsiderations": ["undefined"],
      "27.hasChallengeMechanism": ["undefined"],
      "27.technology.risks": ["undefined"],
      "27.bridges.0.createdAt": [["custom", "UnixTime"]],
      "27.bridges.0.display.warning": ["undefined"],
      "27.bridges.0.technology.risks": ["undefined"],
      "27.bridges.0.otherConsiderations": ["undefined"],
      "27.otherConsiderations": ["undefined"],
      "28.hasChallengeMechanism": ["undefined"],
      "28.technology.risks": ["undefined"],
      "28.bridges.0.createdAt": [["custom", "UnixTime"]],
      "28.bridges.0.display.warning": ["undefined"],
      "28.bridges.0.technology.risks": ["undefined"],
      "28.bridges.0.otherConsiderations": ["undefined"],
      "28.otherConsiderations": ["undefined"],
      "29.hasChallengeMechanism": ["undefined"],
      "29.technology.risks": ["undefined"],
      "29.bridges.0.createdAt": [["custom", "UnixTime"]],
      "29.bridges.0.display.warning": ["undefined"],
      "29.bridges.0.technology.risks": ["undefined"],
      "29.bridges.0.otherConsiderations": ["undefined"],
      "29.otherConsiderations": ["undefined"],
      "30.hasChallengeMechanism": ["undefined"],
      "30.technology.risks": ["undefined"],
      "30.bridges.0.createdAt": [["custom", "UnixTime"]],
      "30.bridges.0.display.warning": ["undefined"],
      "30.bridges.0.technology.risks": ["undefined"],
      "30.bridges.0.otherConsiderations": ["undefined"],
      "30.otherConsiderations": ["undefined"],
      "31.hasChallengeMechanism": ["undefined"],
      "31.technology.risks": ["undefined"],
      "31.bridges.0.createdAt": [["custom", "UnixTime"]],
      "31.bridges.0.display.warning": ["undefined"],
      "31.bridges.0.technology.risks": ["undefined"],
      "31.bridges.0.otherConsiderations": ["undefined"],
      "31.otherConsiderations": ["undefined"],
      "32.hasChallengeMechanism": ["undefined"],
      "32.technology.risks": ["undefined"],
      "32.bridges.0.createdAt": [["custom", "UnixTime"]],
      "32.bridges.0.display.warning": ["undefined"],
      "32.bridges.0.technology.risks": ["undefined"],
      "32.bridges.0.otherConsiderations": ["undefined"],
      "32.otherConsiderations": ["undefined"],
      "33.hasChallengeMechanism": ["undefined"],
      "33.technology.risks": ["undefined"],
      "33.bridges.0.createdAt": [["custom", "UnixTime"]],
      "33.bridges.0.display.warning": ["undefined"],
      "33.bridges.0.display.redWarning": ["undefined"],
      "33.bridges.0.technology.risks": ["undefined"],
      "33.bridges.0.otherConsiderations": ["undefined"],
      "33.otherConsiderations": ["undefined"],
      "34.bridges.0.createdAt": [["custom", "UnixTime"]],
      "34.bridges.0.technology.risks": ["undefined"],
      "34.bridges.0.otherConsiderations": ["undefined"],
      "34.bridges.1.createdAt": [["custom", "UnixTime"]],
      "34.bridges.1.contracts.addresses.2.upgradeability": ["undefined"],
      "34.bridges.1.permissions.0.references": ["undefined"],
      "34.bridges.1.permissions.1.references": ["undefined"],
      "35.bridges.0.createdAt": [["custom", "UnixTime"]],
      "35.bridges.0.technology.risks": ["undefined"],
      "35.bridges.0.otherConsiderations": ["undefined"],
      "35.bridges.1.createdAt": [["custom", "UnixTime"]],
      "35.bridges.1.contracts.addresses.2.upgradeability": ["undefined"],
      "35.bridges.1.contracts.addresses.3.upgradeability": ["undefined"],
      "35.bridges.1.contracts.nativeAddresses.arbitrum.2.upgradeability": [
        "undefined"
      ],
      "35.bridges.1.contracts.nativeAddresses.arbitrum.3.upgradeability": [
        "undefined"
      ],
      "35.bridges.1.contracts.nativeAddresses.base.2.upgradeability": [
        "undefined"
      ],
      "35.bridges.1.contracts.nativeAddresses.base.3.upgradeability": [
        "undefined"
      ],
      "35.bridges.1.permissions.0.references": ["undefined"],
      "35.bridges.1.permissions.1.references": ["undefined"],
      "35.bridges.1.nativePermissions.arbitrum.0.references": ["undefined"],
      "35.bridges.1.nativePermissions.arbitrum.1.references": ["undefined"],
      "35.bridges.1.nativePermissions.base.0.references": ["undefined"],
      "35.bridges.1.nativePermissions.base.1.references": ["undefined"],
      "36.bridges.0.createdAt": [["custom", "UnixTime"]],
      "36.bridges.0.technology.risks": ["undefined"],
      "36.bridges.0.otherConsiderations": ["undefined"],
      "37.bridges.0.createdAt": [["custom", "UnixTime"]],
      "37.bridges.0.technology.risks": ["undefined"],
      "37.bridges.0.otherConsiderations": ["undefined"],
      "38.bridges.0.createdAt": [["custom", "UnixTime"]],
      "38.bridges.0.technology.risks": ["undefined"],
      "38.bridges.0.otherConsiderations": ["undefined"],
      "39.bridges.0.createdAt": [["custom", "UnixTime"]],
      "39.bridges.0.contracts.addresses.3.upgradeability": ["undefined"],
      "39.bridges.0.permissions.0.references": ["undefined"],
      "40.bridges.0.createdAt": [["custom", "UnixTime"]],
      "40.bridges.0.technology.risks": ["undefined"],
      "40.bridges.0.otherConsiderations": ["undefined"],
      "40.bridges.1.createdAt": [["custom", "UnixTime"]],
      "40.bridges.1.contracts.addresses.5.upgradeability": ["undefined"],
      "40.bridges.1.permissions.6.references": ["undefined"],
      "40.bridges.1.permissions.7.references": ["undefined"],
      "40.bridges.1.permissions.8.references": ["undefined"],
      "41.bridges.0.createdAt": [["custom", "UnixTime"]],
      "41.bridges.0.technology.risks": ["undefined"],
      "41.bridges.0.otherConsiderations": ["undefined"],
      "42.bridges.0.createdAt": [["custom", "UnixTime"]],
      "42.bridges.0.technology.risks": ["undefined"],
      "42.bridges.0.otherConsiderations": ["undefined"]
    },
    "referentialEqualities": {
      "0.display.links": ["0.bridges.0.display.links"],
      "0.usedIn": ["0.bridges.0.usedIn"],
      "0.bridges.0.transactionDataType": [
        "2.bridges.0.transactionDataType",
        "4.bridges.0.transactionDataType",
        "5.bridges.0.transactionDataType",
        "11.bridges.0.transactionDataType",
        "12.bridges.0.transactionDataType",
        "15.bridges.0.transactionDataType",
        "16.bridges.0.transactionDataType",
        "17.bridges.0.transactionDataType",
        "18.bridges.0.transactionDataType",
        "20.bridges.0.transactionDataType",
        "21.bridges.0.transactionDataType",
        "22.bridges.0.transactionDataType",
        "26.bridges.0.transactionDataType",
        "27.bridges.0.transactionDataType",
        "28.bridges.0.transactionDataType",
        "29.bridges.0.transactionDataType",
        "30.bridges.0.transactionDataType",
        "31.bridges.0.transactionDataType",
        "32.bridges.0.transactionDataType",
        "33.bridges.0.transactionDataType"
      ],
      "0.bridges.0.risks.upgradeability": [
        "1.bridges.0.risks.upgradeability",
        "2.bridges.0.risks.upgradeability",
        "3.bridges.0.risks.upgradeability",
        "4.bridges.0.risks.upgradeability",
        "5.bridges.0.risks.upgradeability",
        "6.bridges.0.risks.upgradeability",
        "7.bridges.0.risks.upgradeability",
        "8.bridges.0.risks.upgradeability",
        "9.bridges.0.risks.upgradeability",
        "10.bridges.0.risks.upgradeability",
        "11.bridges.0.risks.upgradeability",
        "12.bridges.0.risks.upgradeability",
        "13.bridges.0.risks.upgradeability",
        "14.bridges.0.risks.upgradeability",
        "15.bridges.0.risks.upgradeability",
        "16.bridges.0.risks.upgradeability",
        "17.bridges.0.risks.upgradeability",
        "18.bridges.0.risks.upgradeability",
        "19.bridges.0.risks.upgradeability",
        "20.bridges.0.risks.upgradeability",
        "21.bridges.0.risks.upgradeability",
        "22.bridges.0.risks.upgradeability",
        "23.bridges.0.risks.upgradeability",
        "24.bridges.0.risks.upgradeability",
        "25.bridges.0.risks.upgradeability",
        "26.bridges.0.risks.upgradeability",
        "27.bridges.0.risks.upgradeability",
        "28.bridges.0.risks.upgradeability",
        "29.bridges.0.risks.upgradeability",
        "30.bridges.0.risks.upgradeability",
        "31.bridges.0.risks.upgradeability",
        "32.bridges.0.risks.upgradeability",
        "33.bridges.0.risks.upgradeability"
      ],
      "0.bridges.0.risks.relayerFailure": [
        "1.bridges.0.risks.relayerFailure",
        "2.bridges.0.risks.relayerFailure",
        "3.bridges.0.risks.relayerFailure",
        "4.bridges.0.risks.relayerFailure",
        "5.bridges.0.risks.relayerFailure",
        "6.bridges.0.risks.relayerFailure",
        "7.bridges.0.risks.relayerFailure",
        "8.bridges.0.risks.relayerFailure",
        "9.bridges.0.risks.relayerFailure",
        "10.bridges.0.risks.relayerFailure",
        "11.bridges.0.risks.relayerFailure",
        "12.bridges.0.risks.relayerFailure",
        "13.bridges.0.risks.relayerFailure",
        "14.bridges.0.risks.relayerFailure",
        "15.bridges.0.risks.relayerFailure",
        "16.bridges.0.risks.relayerFailure",
        "17.bridges.0.risks.relayerFailure",
        "18.bridges.0.risks.relayerFailure",
        "19.bridges.0.risks.relayerFailure",
        "20.bridges.0.risks.relayerFailure",
        "21.bridges.0.risks.relayerFailure",
        "22.bridges.0.risks.relayerFailure",
        "23.bridges.0.risks.relayerFailure",
        "24.bridges.0.risks.relayerFailure",
        "25.bridges.0.risks.relayerFailure",
        "26.bridges.0.risks.relayerFailure",
        "27.bridges.0.risks.relayerFailure",
        "28.bridges.0.risks.relayerFailure",
        "29.bridges.0.risks.relayerFailure",
        "30.bridges.0.risks.relayerFailure",
        "31.bridges.0.risks.relayerFailure",
        "32.bridges.0.risks.relayerFailure",
        "33.bridges.0.risks.relayerFailure",
        "34.bridges.1.risks.relayerFailure",
        "35.bridges.1.risks.relayerFailure",
        "39.bridges.0.risks.relayerFailure",
        "40.bridges.1.risks.relayerFailure"
      ],
      "0.risks.economicSecurity": [
        "1.risks.economicSecurity",
        "2.risks.economicSecurity",
        "3.risks.economicSecurity",
        "4.risks.economicSecurity",
        "5.risks.economicSecurity",
        "6.risks.economicSecurity",
        "7.risks.economicSecurity",
        "8.risks.economicSecurity",
        "9.risks.economicSecurity",
        "10.risks.economicSecurity",
        "11.risks.economicSecurity",
        "12.risks.economicSecurity",
        "13.risks.economicSecurity",
        "14.risks.economicSecurity",
        "15.risks.economicSecurity",
        "16.risks.economicSecurity",
        "17.risks.economicSecurity",
        "18.risks.economicSecurity",
        "19.risks.economicSecurity",
        "20.risks.economicSecurity",
        "21.risks.economicSecurity",
        "22.risks.economicSecurity",
        "23.risks.economicSecurity",
        "24.risks.economicSecurity",
        "25.risks.economicSecurity",
        "26.risks.economicSecurity",
        "27.risks.economicSecurity",
        "28.risks.economicSecurity",
        "29.risks.economicSecurity",
        "30.risks.economicSecurity",
        "31.risks.economicSecurity",
        "32.risks.economicSecurity",
        "38.risks.economicSecurity",
        "41.risks.economicSecurity",
        "42.risks.economicSecurity"
      ],
      "0.risks.fraudDetection": [
        "1.risks.fraudDetection",
        "2.risks.fraudDetection",
        "3.risks.fraudDetection",
        "4.risks.fraudDetection",
        "5.risks.fraudDetection",
        "6.risks.fraudDetection",
        "7.risks.fraudDetection",
        "8.risks.fraudDetection",
        "9.risks.fraudDetection",
        "10.risks.fraudDetection",
        "11.risks.fraudDetection",
        "12.risks.fraudDetection",
        "13.risks.fraudDetection",
        "14.risks.fraudDetection",
        "15.risks.fraudDetection",
        "16.risks.fraudDetection",
        "17.risks.fraudDetection",
        "18.risks.fraudDetection",
        "19.risks.fraudDetection",
        "20.risks.fraudDetection",
        "21.risks.fraudDetection",
        "22.risks.fraudDetection",
        "23.risks.fraudDetection",
        "24.risks.fraudDetection",
        "25.risks.fraudDetection",
        "26.risks.fraudDetection",
        "27.risks.fraudDetection",
        "28.risks.fraudDetection",
        "29.risks.fraudDetection",
        "30.risks.fraudDetection",
        "31.risks.fraudDetection",
        "32.risks.fraudDetection",
        "33.risks.fraudDetection",
        "36.risks.fraudDetection",
        "37.risks.fraudDetection",
        "38.risks.fraudDetection",
        "39.risks.fraudDetection",
        "40.risks.fraudDetection",
        "41.risks.fraudDetection",
        "42.risks.fraudDetection"
      ],
      "1.display.links": ["1.bridges.0.display.links"],
      "1.usedIn": ["1.bridges.0.usedIn"],
      "1.bridges.0.transactionDataType": [
        "3.bridges.0.transactionDataType",
        "7.bridges.0.transactionDataType",
        "8.bridges.0.transactionDataType",
        "10.bridges.0.transactionDataType",
        "14.bridges.0.transactionDataType",
        "19.bridges.0.transactionDataType"
      ],
      "2.display.links": ["2.bridges.0.display.links"],
      "2.usedIn": ["2.bridges.0.usedIn"],
      "3.display.links": ["3.bridges.0.display.links"],
      "3.usedIn": ["3.bridges.0.usedIn"],
      "4.display.links": ["4.bridges.0.display.links"],
      "4.usedIn": ["4.bridges.0.usedIn"],
      "4.bridges.0.contracts.addresses.1.upgradableBy": [
        "4.bridges.0.contracts.addresses.2.upgradableBy"
      ],
      "5.display.links": ["5.bridges.0.display.links"],
      "5.usedIn": ["5.bridges.0.usedIn"],
      "6.display.links": ["6.bridges.0.display.links"],
      "6.usedIn": ["6.bridges.0.usedIn"],
      "6.bridges.0.transactionDataType": [
        "9.bridges.0.transactionDataType",
        "13.bridges.0.transactionDataType",
        "23.bridges.0.transactionDataType",
        "24.bridges.0.transactionDataType",
        "25.bridges.0.transactionDataType",
        "39.bridges.0.transactionDataType",
        "40.bridges.1.transactionDataType"
      ],
      "7.display.links": ["7.bridges.0.display.links"],
      "7.usedIn": ["7.bridges.0.usedIn"],
      "8.display.links": ["8.bridges.0.display.links"],
      "8.usedIn": ["8.bridges.0.usedIn"],
      "9.display.links": ["9.bridges.0.display.links"],
      "9.usedIn": ["9.bridges.0.usedIn"],
      "10.display.links": ["10.bridges.0.display.links"],
      "10.usedIn": ["10.bridges.0.usedIn"],
      "11.display.links": ["11.bridges.0.display.links"],
      "11.usedIn": ["11.bridges.0.usedIn"],
      "12.display.links": ["12.bridges.0.display.links"],
      "12.usedIn": ["12.bridges.0.usedIn"],
      "13.display.links": ["13.bridges.0.display.links"],
      "13.usedIn": ["13.bridges.0.usedIn"],
      "14.display.links": ["14.bridges.0.display.links"],
      "14.usedIn": ["14.bridges.0.usedIn"],
      "15.display.links": ["15.bridges.0.display.links"],
      "15.usedIn": ["15.bridges.0.usedIn"],
      "16.display.links": ["16.bridges.0.display.links"],
      "16.usedIn": ["16.bridges.0.usedIn"],
      "17.display.links": ["17.bridges.0.display.links"],
      "17.usedIn": ["17.bridges.0.usedIn"],
      "18.display.links": ["18.bridges.0.display.links"],
      "18.usedIn": ["18.bridges.0.usedIn"],
      "19.display.links": ["19.bridges.0.display.links"],
      "19.usedIn": ["19.bridges.0.usedIn"],
      "20.display.links": ["20.bridges.0.display.links"],
      "20.usedIn": ["20.bridges.0.usedIn"],
      "21.display.links": ["21.bridges.0.display.links"],
      "21.usedIn": ["21.bridges.0.usedIn"],
      "22.display.links": ["22.bridges.0.display.links"],
      "22.usedIn": ["22.bridges.0.usedIn"],
      "23.display.links": ["23.bridges.0.display.links"],
      "23.usedIn": ["23.bridges.0.usedIn"],
      "24.display.links": ["24.bridges.0.display.links"],
      "24.usedIn": ["24.bridges.0.usedIn"],
      "25.display.links": ["25.bridges.0.display.links"],
      "25.usedIn": ["25.bridges.0.usedIn"],
      "26.display.links": ["26.bridges.0.display.links"],
      "26.usedIn": ["26.bridges.0.usedIn"],
      "27.display.links": ["27.bridges.0.display.links"],
      "27.usedIn": ["27.bridges.0.usedIn"],
      "28.display.links": ["28.bridges.0.display.links"],
      "28.usedIn": ["28.bridges.0.usedIn"],
      "29.display.links": ["29.bridges.0.display.links"],
      "29.usedIn": ["29.bridges.0.usedIn"],
      "30.display.links": ["30.bridges.0.display.links"],
      "30.usedIn": ["30.bridges.0.usedIn"],
      "31.display.links": ["31.bridges.0.display.links"],
      "31.usedIn": ["31.bridges.0.usedIn"],
      "32.display.links": ["32.bridges.0.display.links"],
      "32.usedIn": ["32.bridges.0.usedIn"],
      "33.display.links": ["33.bridges.0.display.links"],
      "33.usedIn": ["33.bridges.0.usedIn"],
      "34.bridges.0.risks.committeeSecurity": [
        "35.bridges.0.risks.committeeSecurity",
        "36.bridges.0.risks.committeeSecurity",
        "37.bridges.0.risks.committeeSecurity",
        "38.bridges.0.risks.committeeSecurity",
        "40.bridges.0.risks.committeeSecurity",
        "41.bridges.0.risks.committeeSecurity",
        "42.bridges.0.risks.committeeSecurity"
      ],
      "34.bridges.0.risks.upgradeability": [
        "35.bridges.0.risks.upgradeability",
        "36.bridges.0.risks.upgradeability",
        "37.bridges.0.risks.upgradeability",
        "38.bridges.0.risks.upgradeability",
        "40.bridges.0.risks.upgradeability",
        "41.bridges.0.risks.upgradeability",
        "42.bridges.0.risks.upgradeability"
      ],
      "34.bridges.0.risks.relayerFailure": [
        "35.bridges.0.risks.relayerFailure",
        "36.bridges.0.risks.relayerFailure",
        "37.bridges.0.risks.relayerFailure",
        "38.bridges.0.risks.relayerFailure",
        "40.bridges.0.risks.relayerFailure",
        "41.bridges.0.risks.relayerFailure",
        "42.bridges.0.risks.relayerFailure"
      ],
      "34.dataAvailabilitySampling.erasureCodingScheme": [
        "35.dataAvailabilitySampling.erasureCodingScheme"
      ],
      "34.risks.economicSecurity": [
        "35.risks.economicSecurity",
        "36.risks.economicSecurity"
      ],
      "39.usedIn.0": ["39.bridges.0.usedIn.0"],
      "40.bridges.1.contracts.addresses.0.upgradableBy": [
        "40.bridges.1.contracts.addresses.1.upgradableBy",
        "40.bridges.1.contracts.addresses.2.upgradableBy",
        "40.bridges.1.contracts.addresses.3.upgradableBy",
        "40.bridges.1.contracts.addresses.4.upgradableBy"
      ],
      "40.bridges.1.contracts.addresses.6.upgradableBy": [
        "40.bridges.1.contracts.addresses.7.upgradableBy",
        "40.bridges.1.contracts.addresses.8.upgradableBy"
      ]
    }
  }
}
